// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ibeam-proto-rawpanel/ibeam-rawpanel.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3013000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3013000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[28]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
namespace ibeam_rawpanel {
class AbsoluteEvent;
class AbsoluteEventDefaultTypeInternal;
extern AbsoluteEventDefaultTypeInternal _AbsoluteEvent_default_instance_;
class BinaryEvent;
class BinaryEventDefaultTypeInternal;
extern BinaryEventDefaultTypeInternal _BinaryEvent_default_instance_;
class Brightness;
class BrightnessDefaultTypeInternal;
extern BrightnessDefaultTypeInternal _Brightness_default_instance_;
class Color;
class ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class ColorIndex;
class ColorIndexDefaultTypeInternal;
extern ColorIndexDefaultTypeInternal _ColorIndex_default_instance_;
class ColorRGB;
class ColorRGBDefaultTypeInternal;
extern ColorRGBDefaultTypeInternal _ColorRGB_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class HWCColor;
class HWCColorDefaultTypeInternal;
extern HWCColorDefaultTypeInternal _HWCColor_default_instance_;
class HWCEvent;
class HWCEventDefaultTypeInternal;
extern HWCEventDefaultTypeInternal _HWCEvent_default_instance_;
class HWCExtended;
class HWCExtendedDefaultTypeInternal;
extern HWCExtendedDefaultTypeInternal _HWCExtended_default_instance_;
class HWCGfx;
class HWCGfxDefaultTypeInternal;
extern HWCGfxDefaultTypeInternal _HWCGfx_default_instance_;
class HWCMode;
class HWCModeDefaultTypeInternal;
extern HWCModeDefaultTypeInternal _HWCMode_default_instance_;
class HWCState;
class HWCStateDefaultTypeInternal;
extern HWCStateDefaultTypeInternal _HWCState_default_instance_;
class HWCText;
class HWCTextDefaultTypeInternal;
extern HWCTextDefaultTypeInternal _HWCText_default_instance_;
class HWCText_Scale;
class HWCText_ScaleDefaultTypeInternal;
extern HWCText_ScaleDefaultTypeInternal _HWCText_Scale_default_instance_;
class HWCText_TextStyle;
class HWCText_TextStyleDefaultTypeInternal;
extern HWCText_TextStyleDefaultTypeInternal _HWCText_TextStyle_default_instance_;
class HWCText_TextStyle_Font;
class HWCText_TextStyle_FontDefaultTypeInternal;
extern HWCText_TextStyle_FontDefaultTypeInternal _HWCText_TextStyle_Font_default_instance_;
class ImgConvert;
class ImgConvertDefaultTypeInternal;
extern ImgConvertDefaultTypeInternal _ImgConvert_default_instance_;
class InboundMessage;
class InboundMessageDefaultTypeInternal;
extern InboundMessageDefaultTypeInternal _InboundMessage_default_instance_;
class OutboundMessage;
class OutboundMessageDefaultTypeInternal;
extern OutboundMessageDefaultTypeInternal _OutboundMessage_default_instance_;
class OutboundMessage_HWCavailabilityEntry_DoNotUse;
class OutboundMessage_HWCavailabilityEntry_DoNotUseDefaultTypeInternal;
extern OutboundMessage_HWCavailabilityEntry_DoNotUseDefaultTypeInternal _OutboundMessage_HWCavailabilityEntry_DoNotUse_default_instance_;
class PanelInfo;
class PanelInfoDefaultTypeInternal;
extern PanelInfoDefaultTypeInternal _PanelInfo_default_instance_;
class PanelTopology;
class PanelTopologyDefaultTypeInternal;
extern PanelTopologyDefaultTypeInternal _PanelTopology_default_instance_;
class PulsedEvent;
class PulsedEventDefaultTypeInternal;
extern PulsedEventDefaultTypeInternal _PulsedEvent_default_instance_;
class SleepState;
class SleepStateDefaultTypeInternal;
extern SleepStateDefaultTypeInternal _SleepState_default_instance_;
class SleepTimeout;
class SleepTimeoutDefaultTypeInternal;
extern SleepTimeoutDefaultTypeInternal _SleepTimeout_default_instance_;
class SpeedEvent;
class SpeedEventDefaultTypeInternal;
extern SpeedEventDefaultTypeInternal _SpeedEvent_default_instance_;
class WebserverState;
class WebserverStateDefaultTypeInternal;
extern WebserverStateDefaultTypeInternal _WebserverState_default_instance_;
}  // namespace ibeam_rawpanel
PROTOBUF_NAMESPACE_OPEN
template<> ::ibeam_rawpanel::AbsoluteEvent* Arena::CreateMaybeMessage<::ibeam_rawpanel::AbsoluteEvent>(Arena*);
template<> ::ibeam_rawpanel::BinaryEvent* Arena::CreateMaybeMessage<::ibeam_rawpanel::BinaryEvent>(Arena*);
template<> ::ibeam_rawpanel::Brightness* Arena::CreateMaybeMessage<::ibeam_rawpanel::Brightness>(Arena*);
template<> ::ibeam_rawpanel::Color* Arena::CreateMaybeMessage<::ibeam_rawpanel::Color>(Arena*);
template<> ::ibeam_rawpanel::ColorIndex* Arena::CreateMaybeMessage<::ibeam_rawpanel::ColorIndex>(Arena*);
template<> ::ibeam_rawpanel::ColorRGB* Arena::CreateMaybeMessage<::ibeam_rawpanel::ColorRGB>(Arena*);
template<> ::ibeam_rawpanel::Command* Arena::CreateMaybeMessage<::ibeam_rawpanel::Command>(Arena*);
template<> ::ibeam_rawpanel::HWCColor* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCColor>(Arena*);
template<> ::ibeam_rawpanel::HWCEvent* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCEvent>(Arena*);
template<> ::ibeam_rawpanel::HWCExtended* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCExtended>(Arena*);
template<> ::ibeam_rawpanel::HWCGfx* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCGfx>(Arena*);
template<> ::ibeam_rawpanel::HWCMode* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCMode>(Arena*);
template<> ::ibeam_rawpanel::HWCState* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCState>(Arena*);
template<> ::ibeam_rawpanel::HWCText* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCText>(Arena*);
template<> ::ibeam_rawpanel::HWCText_Scale* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCText_Scale>(Arena*);
template<> ::ibeam_rawpanel::HWCText_TextStyle* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCText_TextStyle>(Arena*);
template<> ::ibeam_rawpanel::HWCText_TextStyle_Font* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCText_TextStyle_Font>(Arena*);
template<> ::ibeam_rawpanel::ImgConvert* Arena::CreateMaybeMessage<::ibeam_rawpanel::ImgConvert>(Arena*);
template<> ::ibeam_rawpanel::InboundMessage* Arena::CreateMaybeMessage<::ibeam_rawpanel::InboundMessage>(Arena*);
template<> ::ibeam_rawpanel::OutboundMessage* Arena::CreateMaybeMessage<::ibeam_rawpanel::OutboundMessage>(Arena*);
template<> ::ibeam_rawpanel::OutboundMessage_HWCavailabilityEntry_DoNotUse* Arena::CreateMaybeMessage<::ibeam_rawpanel::OutboundMessage_HWCavailabilityEntry_DoNotUse>(Arena*);
template<> ::ibeam_rawpanel::PanelInfo* Arena::CreateMaybeMessage<::ibeam_rawpanel::PanelInfo>(Arena*);
template<> ::ibeam_rawpanel::PanelTopology* Arena::CreateMaybeMessage<::ibeam_rawpanel::PanelTopology>(Arena*);
template<> ::ibeam_rawpanel::PulsedEvent* Arena::CreateMaybeMessage<::ibeam_rawpanel::PulsedEvent>(Arena*);
template<> ::ibeam_rawpanel::SleepState* Arena::CreateMaybeMessage<::ibeam_rawpanel::SleepState>(Arena*);
template<> ::ibeam_rawpanel::SleepTimeout* Arena::CreateMaybeMessage<::ibeam_rawpanel::SleepTimeout>(Arena*);
template<> ::ibeam_rawpanel::SpeedEvent* Arena::CreateMaybeMessage<::ibeam_rawpanel::SpeedEvent>(Arena*);
template<> ::ibeam_rawpanel::WebserverState* Arena::CreateMaybeMessage<::ibeam_rawpanel::WebserverState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ibeam_rawpanel {

enum InboundMessage_FlowMsg : int {
  InboundMessage_FlowMsg_NONE = 0,
  InboundMessage_FlowMsg_PING = 1,
  InboundMessage_FlowMsg_ACK = 2,
  InboundMessage_FlowMsg_NACK = 3,
  InboundMessage_FlowMsg_InboundMessage_FlowMsg_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  InboundMessage_FlowMsg_InboundMessage_FlowMsg_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool InboundMessage_FlowMsg_IsValid(int value);
constexpr InboundMessage_FlowMsg InboundMessage_FlowMsg_FlowMsg_MIN = InboundMessage_FlowMsg_NONE;
constexpr InboundMessage_FlowMsg InboundMessage_FlowMsg_FlowMsg_MAX = InboundMessage_FlowMsg_NACK;
constexpr int InboundMessage_FlowMsg_FlowMsg_ARRAYSIZE = InboundMessage_FlowMsg_FlowMsg_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InboundMessage_FlowMsg_descriptor();
template<typename T>
inline const std::string& InboundMessage_FlowMsg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InboundMessage_FlowMsg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InboundMessage_FlowMsg_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InboundMessage_FlowMsg_descriptor(), enum_t_value);
}
inline bool InboundMessage_FlowMsg_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InboundMessage_FlowMsg* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InboundMessage_FlowMsg>(
    InboundMessage_FlowMsg_descriptor(), name, value);
}
enum HWCMode_State : int {
  HWCMode_State_OFF = 0,
  HWCMode_State_ON = 4,
  HWCMode_State_DIMMED = 5,
  HWCMode_State_HWCMode_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCMode_State_HWCMode_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCMode_State_IsValid(int value);
constexpr HWCMode_State HWCMode_State_State_MIN = HWCMode_State_OFF;
constexpr HWCMode_State HWCMode_State_State_MAX = HWCMode_State_DIMMED;
constexpr int HWCMode_State_State_ARRAYSIZE = HWCMode_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCMode_State_descriptor();
template<typename T>
inline const std::string& HWCMode_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCMode_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCMode_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCMode_State_descriptor(), enum_t_value);
}
inline bool HWCMode_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCMode_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCMode_State>(
    HWCMode_State_descriptor(), name, value);
}
enum HWCExtended_Interpretation : int {
  HWCExtended_Interpretation_NONE = 0,
  HWCExtended_Interpretation_STRENGTH = 1,
  HWCExtended_Interpretation_STEPS = 3,
  HWCExtended_Interpretation_VU = 4,
  HWCExtended_Interpretation_FADER = 5,
  HWCExtended_Interpretation_HWCExtended_Interpretation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCExtended_Interpretation_HWCExtended_Interpretation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCExtended_Interpretation_IsValid(int value);
constexpr HWCExtended_Interpretation HWCExtended_Interpretation_Interpretation_MIN = HWCExtended_Interpretation_NONE;
constexpr HWCExtended_Interpretation HWCExtended_Interpretation_Interpretation_MAX = HWCExtended_Interpretation_FADER;
constexpr int HWCExtended_Interpretation_Interpretation_ARRAYSIZE = HWCExtended_Interpretation_Interpretation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCExtended_Interpretation_descriptor();
template<typename T>
inline const std::string& HWCExtended_Interpretation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCExtended_Interpretation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCExtended_Interpretation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCExtended_Interpretation_descriptor(), enum_t_value);
}
inline bool HWCExtended_Interpretation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCExtended_Interpretation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCExtended_Interpretation>(
    HWCExtended_Interpretation_descriptor(), name, value);
}
enum ColorIndex_Colors : int {
  ColorIndex_Colors_DEFAULT = 0,
  ColorIndex_Colors_OFF = 1,
  ColorIndex_Colors_WHITE = 2,
  ColorIndex_Colors_WARM = 3,
  ColorIndex_Colors_RED = 4,
  ColorIndex_Colors_ROSE = 5,
  ColorIndex_Colors_PINK = 6,
  ColorIndex_Colors_PURPLE = 7,
  ColorIndex_Colors_AMBER = 8,
  ColorIndex_Colors_YELLOW = 9,
  ColorIndex_Colors_DARKBLUE = 10,
  ColorIndex_Colors_BLUE = 11,
  ColorIndex_Colors_ICE = 12,
  ColorIndex_Colors_CYAN = 13,
  ColorIndex_Colors_SPRING = 14,
  ColorIndex_Colors_GREEN = 15,
  ColorIndex_Colors_MINT = 16,
  ColorIndex_Colors_ColorIndex_Colors_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ColorIndex_Colors_ColorIndex_Colors_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ColorIndex_Colors_IsValid(int value);
constexpr ColorIndex_Colors ColorIndex_Colors_Colors_MIN = ColorIndex_Colors_DEFAULT;
constexpr ColorIndex_Colors ColorIndex_Colors_Colors_MAX = ColorIndex_Colors_MINT;
constexpr int ColorIndex_Colors_Colors_ARRAYSIZE = ColorIndex_Colors_Colors_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ColorIndex_Colors_descriptor();
template<typename T>
inline const std::string& ColorIndex_Colors_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ColorIndex_Colors>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ColorIndex_Colors_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ColorIndex_Colors_descriptor(), enum_t_value);
}
inline bool ColorIndex_Colors_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ColorIndex_Colors* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ColorIndex_Colors>(
    ColorIndex_Colors_descriptor(), name, value);
}
enum HWCText_Scale_ScaleType : int {
  HWCText_Scale_ScaleType_ST_OFF = 0,
  HWCText_Scale_ScaleType_ST_STRENGTH = 1,
  HWCText_Scale_ScaleType_ST_CENTER_MARKER = 2,
  HWCText_Scale_ScaleType_ST_CENTER_BAR = 3,
  HWCText_Scale_ScaleType_HWCText_Scale_ScaleType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCText_Scale_ScaleType_HWCText_Scale_ScaleType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCText_Scale_ScaleType_IsValid(int value);
constexpr HWCText_Scale_ScaleType HWCText_Scale_ScaleType_ScaleType_MIN = HWCText_Scale_ScaleType_ST_OFF;
constexpr HWCText_Scale_ScaleType HWCText_Scale_ScaleType_ScaleType_MAX = HWCText_Scale_ScaleType_ST_CENTER_BAR;
constexpr int HWCText_Scale_ScaleType_ScaleType_ARRAYSIZE = HWCText_Scale_ScaleType_ScaleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCText_Scale_ScaleType_descriptor();
template<typename T>
inline const std::string& HWCText_Scale_ScaleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCText_Scale_ScaleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCText_Scale_ScaleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCText_Scale_ScaleType_descriptor(), enum_t_value);
}
inline bool HWCText_Scale_ScaleType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCText_Scale_ScaleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCText_Scale_ScaleType>(
    HWCText_Scale_ScaleType_descriptor(), name, value);
}
enum HWCText_TextStyle_Font_FontFace : int {
  HWCText_TextStyle_Font_FontFace_ST_DEFAULT = 0,
  HWCText_TextStyle_Font_FontFace_ST_BOLD = 1,
  HWCText_TextStyle_Font_FontFace_ST_TINY = 2,
  HWCText_TextStyle_Font_FontFace_HWCText_TextStyle_Font_FontFace_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCText_TextStyle_Font_FontFace_HWCText_TextStyle_Font_FontFace_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCText_TextStyle_Font_FontFace_IsValid(int value);
constexpr HWCText_TextStyle_Font_FontFace HWCText_TextStyle_Font_FontFace_FontFace_MIN = HWCText_TextStyle_Font_FontFace_ST_DEFAULT;
constexpr HWCText_TextStyle_Font_FontFace HWCText_TextStyle_Font_FontFace_FontFace_MAX = HWCText_TextStyle_Font_FontFace_ST_TINY;
constexpr int HWCText_TextStyle_Font_FontFace_FontFace_ARRAYSIZE = HWCText_TextStyle_Font_FontFace_FontFace_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCText_TextStyle_Font_FontFace_descriptor();
template<typename T>
inline const std::string& HWCText_TextStyle_Font_FontFace_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCText_TextStyle_Font_FontFace>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCText_TextStyle_Font_FontFace_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCText_TextStyle_Font_FontFace_descriptor(), enum_t_value);
}
inline bool HWCText_TextStyle_Font_FontFace_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCText_TextStyle_Font_FontFace* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCText_TextStyle_Font_FontFace>(
    HWCText_TextStyle_Font_FontFace_descriptor(), name, value);
}
enum HWCText_Formatting : int {
  HWCText_Formatting_FMT_INTEGER = 0,
  HWCText_Formatting_FMT_PERCENTAGE = 2,
  HWCText_Formatting_FMT_DB = 3,
  HWCText_Formatting_FMT_FRAMES = 4,
  HWCText_Formatting_FMT_ONEOVERX = 5,
  HWCText_Formatting_FMT_KELVIN = 6,
  HWCText_Formatting_FMT_HIDE = 7,
  HWCText_Formatting_FMT_FLOAT_X_XXX = 8,
  HWCText_Formatting_FMT_FLOAT_XX_XX = 9,
  HWCText_Formatting_FMT_ONELINE = 10,
  HWCText_Formatting_FMT_TWOLINES = 11,
  HWCText_Formatting_FMT_FLOAT_XXX_X = 12,
  HWCText_Formatting_HWCText_Formatting_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCText_Formatting_HWCText_Formatting_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCText_Formatting_IsValid(int value);
constexpr HWCText_Formatting HWCText_Formatting_Formatting_MIN = HWCText_Formatting_FMT_INTEGER;
constexpr HWCText_Formatting HWCText_Formatting_Formatting_MAX = HWCText_Formatting_FMT_FLOAT_XXX_X;
constexpr int HWCText_Formatting_Formatting_ARRAYSIZE = HWCText_Formatting_Formatting_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCText_Formatting_descriptor();
template<typename T>
inline const std::string& HWCText_Formatting_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCText_Formatting>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCText_Formatting_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCText_Formatting_descriptor(), enum_t_value);
}
inline bool HWCText_Formatting_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCText_Formatting* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCText_Formatting>(
    HWCText_Formatting_descriptor(), name, value);
}
enum HWCText_StateIcon : int {
  HWCText_StateIcon_SI_NONE = 0,
  HWCText_StateIcon_SI_FINE = 1,
  HWCText_StateIcon_SI_LOCK = 2,
  HWCText_StateIcon_SI_NOACCESS = 3,
  HWCText_StateIcon_HWCText_StateIcon_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCText_StateIcon_HWCText_StateIcon_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCText_StateIcon_IsValid(int value);
constexpr HWCText_StateIcon HWCText_StateIcon_StateIcon_MIN = HWCText_StateIcon_SI_NONE;
constexpr HWCText_StateIcon HWCText_StateIcon_StateIcon_MAX = HWCText_StateIcon_SI_NOACCESS;
constexpr int HWCText_StateIcon_StateIcon_ARRAYSIZE = HWCText_StateIcon_StateIcon_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCText_StateIcon_descriptor();
template<typename T>
inline const std::string& HWCText_StateIcon_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCText_StateIcon>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCText_StateIcon_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCText_StateIcon_descriptor(), enum_t_value);
}
inline bool HWCText_StateIcon_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCText_StateIcon* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCText_StateIcon>(
    HWCText_StateIcon_descriptor(), name, value);
}
enum HWCText_ModifierIcon : int {
  HWCText_ModifierIcon_MI_NONE = 0,
  HWCText_ModifierIcon_MI_CYCLE = 1,
  HWCText_ModifierIcon_MI_DOWN = 2,
  HWCText_ModifierIcon_MI_UP = 3,
  HWCText_ModifierIcon_MI_HOLD = 4,
  HWCText_ModifierIcon_MI_TOGGLE = 5,
  HWCText_ModifierIcon_MI_OK = 6,
  HWCText_ModifierIcon_MI_QUESTION = 7,
  HWCText_ModifierIcon_HWCText_ModifierIcon_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCText_ModifierIcon_HWCText_ModifierIcon_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCText_ModifierIcon_IsValid(int value);
constexpr HWCText_ModifierIcon HWCText_ModifierIcon_ModifierIcon_MIN = HWCText_ModifierIcon_MI_NONE;
constexpr HWCText_ModifierIcon HWCText_ModifierIcon_ModifierIcon_MAX = HWCText_ModifierIcon_MI_QUESTION;
constexpr int HWCText_ModifierIcon_ModifierIcon_ARRAYSIZE = HWCText_ModifierIcon_ModifierIcon_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCText_ModifierIcon_descriptor();
template<typename T>
inline const std::string& HWCText_ModifierIcon_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCText_ModifierIcon>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCText_ModifierIcon_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCText_ModifierIcon_descriptor(), enum_t_value);
}
inline bool HWCText_ModifierIcon_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCText_ModifierIcon* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCText_ModifierIcon>(
    HWCText_ModifierIcon_descriptor(), name, value);
}
enum HWCText_PairMode : int {
  HWCText_PairMode_PM_OFF = 0,
  HWCText_PairMode_PM_UNMARKED = 1,
  HWCText_PairMode_PM_UPPER_MARKED = 2,
  HWCText_PairMode_PM_LOWER_MARKED = 3,
  HWCText_PairMode_PM_BOTH_MARKED = 4,
  HWCText_PairMode_HWCText_PairMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCText_PairMode_HWCText_PairMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCText_PairMode_IsValid(int value);
constexpr HWCText_PairMode HWCText_PairMode_PairMode_MIN = HWCText_PairMode_PM_OFF;
constexpr HWCText_PairMode HWCText_PairMode_PairMode_MAX = HWCText_PairMode_PM_BOTH_MARKED;
constexpr int HWCText_PairMode_PairMode_ARRAYSIZE = HWCText_PairMode_PairMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCText_PairMode_descriptor();
template<typename T>
inline const std::string& HWCText_PairMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCText_PairMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCText_PairMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCText_PairMode_descriptor(), enum_t_value);
}
inline bool HWCText_PairMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCText_PairMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCText_PairMode>(
    HWCText_PairMode_descriptor(), name, value);
}
enum HWCGfx_ImageType : int {
  HWCGfx_ImageType_MONO = 0,
  HWCGfx_ImageType_RGB16bit = 1,
  HWCGfx_ImageType_HWCGfx_ImageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCGfx_ImageType_HWCGfx_ImageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCGfx_ImageType_IsValid(int value);
constexpr HWCGfx_ImageType HWCGfx_ImageType_ImageType_MIN = HWCGfx_ImageType_MONO;
constexpr HWCGfx_ImageType HWCGfx_ImageType_ImageType_MAX = HWCGfx_ImageType_RGB16bit;
constexpr int HWCGfx_ImageType_ImageType_ARRAYSIZE = HWCGfx_ImageType_ImageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCGfx_ImageType_descriptor();
template<typename T>
inline const std::string& HWCGfx_ImageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCGfx_ImageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCGfx_ImageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCGfx_ImageType_descriptor(), enum_t_value);
}
inline bool HWCGfx_ImageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCGfx_ImageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCGfx_ImageType>(
    HWCGfx_ImageType_descriptor(), name, value);
}
enum ImgConvert_FileType : int {
  ImgConvert_FileType_PNG = 0,
  ImgConvert_FileType_JPEG = 1,
  ImgConvert_FileType_ImgConvert_FileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImgConvert_FileType_ImgConvert_FileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImgConvert_FileType_IsValid(int value);
constexpr ImgConvert_FileType ImgConvert_FileType_FileType_MIN = ImgConvert_FileType_PNG;
constexpr ImgConvert_FileType ImgConvert_FileType_FileType_MAX = ImgConvert_FileType_JPEG;
constexpr int ImgConvert_FileType_FileType_ARRAYSIZE = ImgConvert_FileType_FileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImgConvert_FileType_descriptor();
template<typename T>
inline const std::string& ImgConvert_FileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImgConvert_FileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImgConvert_FileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImgConvert_FileType_descriptor(), enum_t_value);
}
inline bool ImgConvert_FileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImgConvert_FileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImgConvert_FileType>(
    ImgConvert_FileType_descriptor(), name, value);
}
enum ImgConvert_Scaling : int {
  ImgConvert_Scaling_FILL = 0,
  ImgConvert_Scaling_FIT = 1,
  ImgConvert_Scaling_CROP = 2,
  ImgConvert_Scaling_ImgConvert_Scaling_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImgConvert_Scaling_ImgConvert_Scaling_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImgConvert_Scaling_IsValid(int value);
constexpr ImgConvert_Scaling ImgConvert_Scaling_Scaling_MIN = ImgConvert_Scaling_FILL;
constexpr ImgConvert_Scaling ImgConvert_Scaling_Scaling_MAX = ImgConvert_Scaling_CROP;
constexpr int ImgConvert_Scaling_Scaling_ARRAYSIZE = ImgConvert_Scaling_Scaling_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImgConvert_Scaling_descriptor();
template<typename T>
inline const std::string& ImgConvert_Scaling_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImgConvert_Scaling>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImgConvert_Scaling_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImgConvert_Scaling_descriptor(), enum_t_value);
}
inline bool ImgConvert_Scaling_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImgConvert_Scaling* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImgConvert_Scaling>(
    ImgConvert_Scaling_descriptor(), name, value);
}
enum OutboundMessage_FlowMsg : int {
  OutboundMessage_FlowMsg_NONE = 0,
  OutboundMessage_FlowMsg_PING = 1,
  OutboundMessage_FlowMsg_ACK = 2,
  OutboundMessage_FlowMsg_NACK = 3,
  OutboundMessage_FlowMsg_HELLO = 100,
  OutboundMessage_FlowMsg_OutboundMessage_FlowMsg_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OutboundMessage_FlowMsg_OutboundMessage_FlowMsg_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OutboundMessage_FlowMsg_IsValid(int value);
constexpr OutboundMessage_FlowMsg OutboundMessage_FlowMsg_FlowMsg_MIN = OutboundMessage_FlowMsg_NONE;
constexpr OutboundMessage_FlowMsg OutboundMessage_FlowMsg_FlowMsg_MAX = OutboundMessage_FlowMsg_HELLO;
constexpr int OutboundMessage_FlowMsg_FlowMsg_ARRAYSIZE = OutboundMessage_FlowMsg_FlowMsg_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OutboundMessage_FlowMsg_descriptor();
template<typename T>
inline const std::string& OutboundMessage_FlowMsg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OutboundMessage_FlowMsg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OutboundMessage_FlowMsg_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OutboundMessage_FlowMsg_descriptor(), enum_t_value);
}
inline bool OutboundMessage_FlowMsg_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OutboundMessage_FlowMsg* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OutboundMessage_FlowMsg>(
    OutboundMessage_FlowMsg_descriptor(), name, value);
}
enum OutboundMessage_HWCavail : int {
  OutboundMessage_HWCavail_HIDDEN = 0,
  OutboundMessage_HWCavail_ON = 1,
  OutboundMessage_HWCavail_OFF = 2,
  OutboundMessage_HWCavail_OutboundMessage_HWCavail_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OutboundMessage_HWCavail_OutboundMessage_HWCavail_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OutboundMessage_HWCavail_IsValid(int value);
constexpr OutboundMessage_HWCavail OutboundMessage_HWCavail_HWCavail_MIN = OutboundMessage_HWCavail_HIDDEN;
constexpr OutboundMessage_HWCavail OutboundMessage_HWCavail_HWCavail_MAX = OutboundMessage_HWCavail_OFF;
constexpr int OutboundMessage_HWCavail_HWCavail_ARRAYSIZE = OutboundMessage_HWCavail_HWCavail_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OutboundMessage_HWCavail_descriptor();
template<typename T>
inline const std::string& OutboundMessage_HWCavail_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OutboundMessage_HWCavail>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OutboundMessage_HWCavail_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OutboundMessage_HWCavail_descriptor(), enum_t_value);
}
inline bool OutboundMessage_HWCavail_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OutboundMessage_HWCavail* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OutboundMessage_HWCavail>(
    OutboundMessage_HWCavail_descriptor(), name, value);
}
enum BinaryEvent_EdgeID : int {
  BinaryEvent_EdgeID_UNKNOWN = 0,
  BinaryEvent_EdgeID_TOP = 1,
  BinaryEvent_EdgeID_LEFT = 2,
  BinaryEvent_EdgeID_BOTTOM = 4,
  BinaryEvent_EdgeID_RIGHT = 8,
  BinaryEvent_EdgeID_BinaryEvent_EdgeID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BinaryEvent_EdgeID_BinaryEvent_EdgeID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BinaryEvent_EdgeID_IsValid(int value);
constexpr BinaryEvent_EdgeID BinaryEvent_EdgeID_EdgeID_MIN = BinaryEvent_EdgeID_UNKNOWN;
constexpr BinaryEvent_EdgeID BinaryEvent_EdgeID_EdgeID_MAX = BinaryEvent_EdgeID_RIGHT;
constexpr int BinaryEvent_EdgeID_EdgeID_ARRAYSIZE = BinaryEvent_EdgeID_EdgeID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BinaryEvent_EdgeID_descriptor();
template<typename T>
inline const std::string& BinaryEvent_EdgeID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BinaryEvent_EdgeID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BinaryEvent_EdgeID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BinaryEvent_EdgeID_descriptor(), enum_t_value);
}
inline bool BinaryEvent_EdgeID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BinaryEvent_EdgeID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BinaryEvent_EdgeID>(
    BinaryEvent_EdgeID_descriptor(), name, value);
}
// ===================================================================

class InboundMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.InboundMessage) */ {
 public:
  inline InboundMessage() : InboundMessage(nullptr) {}
  virtual ~InboundMessage();

  InboundMessage(const InboundMessage& from);
  InboundMessage(InboundMessage&& from) noexcept
    : InboundMessage() {
    *this = ::std::move(from);
  }

  inline InboundMessage& operator=(const InboundMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InboundMessage& operator=(InboundMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InboundMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InboundMessage* internal_default_instance() {
    return reinterpret_cast<const InboundMessage*>(
               &_InboundMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InboundMessage& a, InboundMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InboundMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InboundMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InboundMessage* New() const final {
    return CreateMaybeMessage<InboundMessage>(nullptr);
  }

  InboundMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InboundMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InboundMessage& from);
  void MergeFrom(const InboundMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InboundMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.InboundMessage";
  }
  protected:
  explicit InboundMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef InboundMessage_FlowMsg FlowMsg;
  static constexpr FlowMsg NONE =
    InboundMessage_FlowMsg_NONE;
  static constexpr FlowMsg PING =
    InboundMessage_FlowMsg_PING;
  static constexpr FlowMsg ACK =
    InboundMessage_FlowMsg_ACK;
  static constexpr FlowMsg NACK =
    InboundMessage_FlowMsg_NACK;
  static inline bool FlowMsg_IsValid(int value) {
    return InboundMessage_FlowMsg_IsValid(value);
  }
  static constexpr FlowMsg FlowMsg_MIN =
    InboundMessage_FlowMsg_FlowMsg_MIN;
  static constexpr FlowMsg FlowMsg_MAX =
    InboundMessage_FlowMsg_FlowMsg_MAX;
  static constexpr int FlowMsg_ARRAYSIZE =
    InboundMessage_FlowMsg_FlowMsg_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FlowMsg_descriptor() {
    return InboundMessage_FlowMsg_descriptor();
  }
  template<typename T>
  static inline const std::string& FlowMsg_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FlowMsg>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FlowMsg_Name.");
    return InboundMessage_FlowMsg_Name(enum_t_value);
  }
  static inline bool FlowMsg_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FlowMsg* value) {
    return InboundMessage_FlowMsg_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatesFieldNumber = 8,
    kCommandFieldNumber = 2,
    kFlowMessageFieldNumber = 1,
  };
  // repeated .ibeam_rawpanel.HWCState States = 8;
  int states_size() const;
  private:
  int _internal_states_size() const;
  public:
  void clear_states();
  ::ibeam_rawpanel::HWCState* mutable_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCState >*
      mutable_states();
  private:
  const ::ibeam_rawpanel::HWCState& _internal_states(int index) const;
  ::ibeam_rawpanel::HWCState* _internal_add_states();
  public:
  const ::ibeam_rawpanel::HWCState& states(int index) const;
  ::ibeam_rawpanel::HWCState* add_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCState >&
      states() const;

  // .ibeam_rawpanel.Command Command = 2;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::ibeam_rawpanel::Command& command() const;
  ::ibeam_rawpanel::Command* release_command();
  ::ibeam_rawpanel::Command* mutable_command();
  void set_allocated_command(::ibeam_rawpanel::Command* command);
  private:
  const ::ibeam_rawpanel::Command& _internal_command() const;
  ::ibeam_rawpanel::Command* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::ibeam_rawpanel::Command* command);
  ::ibeam_rawpanel::Command* unsafe_arena_release_command();

  // .ibeam_rawpanel.InboundMessage.FlowMsg flowMessage = 1;
  void clear_flowmessage();
  ::ibeam_rawpanel::InboundMessage_FlowMsg flowmessage() const;
  void set_flowmessage(::ibeam_rawpanel::InboundMessage_FlowMsg value);
  private:
  ::ibeam_rawpanel::InboundMessage_FlowMsg _internal_flowmessage() const;
  void _internal_set_flowmessage(::ibeam_rawpanel::InboundMessage_FlowMsg value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.InboundMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCState > states_;
  ::ibeam_rawpanel::Command* command_;
  int flowmessage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class Command PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.Command) */ {
 public:
  inline Command() : Command(nullptr) {}
  virtual ~Command();

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.Command";
  }
  protected:
  explicit Command(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetSleepTimeoutFieldNumber = 21,
    kSetWebserverEnabledFieldNumber = 22,
    kPanelBrightnessFieldNumber = 23,
    kActivatePanelFieldNumber = 1,
    kSendPanelInfoFieldNumber = 2,
    kSendPanelTopologyFieldNumber = 3,
    kReportHWCavailabilityFieldNumber = 4,
    kClearAllFieldNumber = 10,
    kClearLEDsFieldNumber = 11,
    kClearDisplaysFieldNumber = 12,
    kWakeUpFieldNumber = 5,
    kGetSleepTimeoutFieldNumber = 20,
  };
  // .ibeam_rawpanel.SleepTimeout SetSleepTimeout = 21;
  bool has_setsleeptimeout() const;
  private:
  bool _internal_has_setsleeptimeout() const;
  public:
  void clear_setsleeptimeout();
  const ::ibeam_rawpanel::SleepTimeout& setsleeptimeout() const;
  ::ibeam_rawpanel::SleepTimeout* release_setsleeptimeout();
  ::ibeam_rawpanel::SleepTimeout* mutable_setsleeptimeout();
  void set_allocated_setsleeptimeout(::ibeam_rawpanel::SleepTimeout* setsleeptimeout);
  private:
  const ::ibeam_rawpanel::SleepTimeout& _internal_setsleeptimeout() const;
  ::ibeam_rawpanel::SleepTimeout* _internal_mutable_setsleeptimeout();
  public:
  void unsafe_arena_set_allocated_setsleeptimeout(
      ::ibeam_rawpanel::SleepTimeout* setsleeptimeout);
  ::ibeam_rawpanel::SleepTimeout* unsafe_arena_release_setsleeptimeout();

  // .ibeam_rawpanel.WebserverState SetWebserverEnabled = 22;
  bool has_setwebserverenabled() const;
  private:
  bool _internal_has_setwebserverenabled() const;
  public:
  void clear_setwebserverenabled();
  const ::ibeam_rawpanel::WebserverState& setwebserverenabled() const;
  ::ibeam_rawpanel::WebserverState* release_setwebserverenabled();
  ::ibeam_rawpanel::WebserverState* mutable_setwebserverenabled();
  void set_allocated_setwebserverenabled(::ibeam_rawpanel::WebserverState* setwebserverenabled);
  private:
  const ::ibeam_rawpanel::WebserverState& _internal_setwebserverenabled() const;
  ::ibeam_rawpanel::WebserverState* _internal_mutable_setwebserverenabled();
  public:
  void unsafe_arena_set_allocated_setwebserverenabled(
      ::ibeam_rawpanel::WebserverState* setwebserverenabled);
  ::ibeam_rawpanel::WebserverState* unsafe_arena_release_setwebserverenabled();

  // .ibeam_rawpanel.Brightness PanelBrightness = 23;
  bool has_panelbrightness() const;
  private:
  bool _internal_has_panelbrightness() const;
  public:
  void clear_panelbrightness();
  const ::ibeam_rawpanel::Brightness& panelbrightness() const;
  ::ibeam_rawpanel::Brightness* release_panelbrightness();
  ::ibeam_rawpanel::Brightness* mutable_panelbrightness();
  void set_allocated_panelbrightness(::ibeam_rawpanel::Brightness* panelbrightness);
  private:
  const ::ibeam_rawpanel::Brightness& _internal_panelbrightness() const;
  ::ibeam_rawpanel::Brightness* _internal_mutable_panelbrightness();
  public:
  void unsafe_arena_set_allocated_panelbrightness(
      ::ibeam_rawpanel::Brightness* panelbrightness);
  ::ibeam_rawpanel::Brightness* unsafe_arena_release_panelbrightness();

  // bool ActivatePanel = 1;
  void clear_activatepanel();
  bool activatepanel() const;
  void set_activatepanel(bool value);
  private:
  bool _internal_activatepanel() const;
  void _internal_set_activatepanel(bool value);
  public:

  // bool SendPanelInfo = 2;
  void clear_sendpanelinfo();
  bool sendpanelinfo() const;
  void set_sendpanelinfo(bool value);
  private:
  bool _internal_sendpanelinfo() const;
  void _internal_set_sendpanelinfo(bool value);
  public:

  // bool SendPanelTopology = 3;
  void clear_sendpaneltopology();
  bool sendpaneltopology() const;
  void set_sendpaneltopology(bool value);
  private:
  bool _internal_sendpaneltopology() const;
  void _internal_set_sendpaneltopology(bool value);
  public:

  // bool ReportHWCavailability = 4;
  void clear_reporthwcavailability();
  bool reporthwcavailability() const;
  void set_reporthwcavailability(bool value);
  private:
  bool _internal_reporthwcavailability() const;
  void _internal_set_reporthwcavailability(bool value);
  public:

  // bool ClearAll = 10;
  void clear_clearall();
  bool clearall() const;
  void set_clearall(bool value);
  private:
  bool _internal_clearall() const;
  void _internal_set_clearall(bool value);
  public:

  // bool ClearLEDs = 11;
  void clear_clearleds();
  bool clearleds() const;
  void set_clearleds(bool value);
  private:
  bool _internal_clearleds() const;
  void _internal_set_clearleds(bool value);
  public:

  // bool ClearDisplays = 12;
  void clear_cleardisplays();
  bool cleardisplays() const;
  void set_cleardisplays(bool value);
  private:
  bool _internal_cleardisplays() const;
  void _internal_set_cleardisplays(bool value);
  public:

  // bool WakeUp = 5;
  void clear_wakeup();
  bool wakeup() const;
  void set_wakeup(bool value);
  private:
  bool _internal_wakeup() const;
  void _internal_set_wakeup(bool value);
  public:

  // bool GetSleepTimeout = 20;
  void clear_getsleeptimeout();
  bool getsleeptimeout() const;
  void set_getsleeptimeout(bool value);
  private:
  bool _internal_getsleeptimeout() const;
  void _internal_set_getsleeptimeout(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.Command)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ibeam_rawpanel::SleepTimeout* setsleeptimeout_;
  ::ibeam_rawpanel::WebserverState* setwebserverenabled_;
  ::ibeam_rawpanel::Brightness* panelbrightness_;
  bool activatepanel_;
  bool sendpanelinfo_;
  bool sendpaneltopology_;
  bool reporthwcavailability_;
  bool clearall_;
  bool clearleds_;
  bool cleardisplays_;
  bool wakeup_;
  bool getsleeptimeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class SleepTimeout PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.SleepTimeout) */ {
 public:
  inline SleepTimeout() : SleepTimeout(nullptr) {}
  virtual ~SleepTimeout();

  SleepTimeout(const SleepTimeout& from);
  SleepTimeout(SleepTimeout&& from) noexcept
    : SleepTimeout() {
    *this = ::std::move(from);
  }

  inline SleepTimeout& operator=(const SleepTimeout& from) {
    CopyFrom(from);
    return *this;
  }
  inline SleepTimeout& operator=(SleepTimeout&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SleepTimeout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SleepTimeout* internal_default_instance() {
    return reinterpret_cast<const SleepTimeout*>(
               &_SleepTimeout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SleepTimeout& a, SleepTimeout& b) {
    a.Swap(&b);
  }
  inline void Swap(SleepTimeout* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SleepTimeout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SleepTimeout* New() const final {
    return CreateMaybeMessage<SleepTimeout>(nullptr);
  }

  SleepTimeout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SleepTimeout>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SleepTimeout& from);
  void MergeFrom(const SleepTimeout& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SleepTimeout* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.SleepTimeout";
  }
  protected:
  explicit SleepTimeout(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 Value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.SleepTimeout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class WebserverState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.WebserverState) */ {
 public:
  inline WebserverState() : WebserverState(nullptr) {}
  virtual ~WebserverState();

  WebserverState(const WebserverState& from);
  WebserverState(WebserverState&& from) noexcept
    : WebserverState() {
    *this = ::std::move(from);
  }

  inline WebserverState& operator=(const WebserverState& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebserverState& operator=(WebserverState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WebserverState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WebserverState* internal_default_instance() {
    return reinterpret_cast<const WebserverState*>(
               &_WebserverState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WebserverState& a, WebserverState& b) {
    a.Swap(&b);
  }
  inline void Swap(WebserverState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebserverState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WebserverState* New() const final {
    return CreateMaybeMessage<WebserverState>(nullptr);
  }

  WebserverState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WebserverState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WebserverState& from);
  void MergeFrom(const WebserverState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebserverState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.WebserverState";
  }
  protected:
  explicit WebserverState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // bool Enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.WebserverState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class Brightness PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.Brightness) */ {
 public:
  inline Brightness() : Brightness(nullptr) {}
  virtual ~Brightness();

  Brightness(const Brightness& from);
  Brightness(Brightness&& from) noexcept
    : Brightness() {
    *this = ::std::move(from);
  }

  inline Brightness& operator=(const Brightness& from) {
    CopyFrom(from);
    return *this;
  }
  inline Brightness& operator=(Brightness&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Brightness& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Brightness* internal_default_instance() {
    return reinterpret_cast<const Brightness*>(
               &_Brightness_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Brightness& a, Brightness& b) {
    a.Swap(&b);
  }
  inline void Swap(Brightness* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Brightness* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Brightness* New() const final {
    return CreateMaybeMessage<Brightness>(nullptr);
  }

  Brightness* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Brightness>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Brightness& from);
  void MergeFrom(const Brightness& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Brightness* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.Brightness";
  }
  protected:
  explicit Brightness(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOLEDsFieldNumber = 1,
    kLEDsFieldNumber = 2,
  };
  // uint32 OLEDs = 1;
  void clear_oleds();
  ::PROTOBUF_NAMESPACE_ID::uint32 oleds() const;
  void set_oleds(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_oleds() const;
  void _internal_set_oleds(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 LEDs = 2;
  void clear_leds();
  ::PROTOBUF_NAMESPACE_ID::uint32 leds() const;
  void set_leds(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_leds() const;
  void _internal_set_leds(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.Brightness)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 oleds_;
  ::PROTOBUF_NAMESPACE_ID::uint32 leds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCState) */ {
 public:
  inline HWCState() : HWCState(nullptr) {}
  virtual ~HWCState();

  HWCState(const HWCState& from);
  HWCState(HWCState&& from) noexcept
    : HWCState() {
    *this = ::std::move(from);
  }

  inline HWCState& operator=(const HWCState& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCState& operator=(HWCState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HWCState* internal_default_instance() {
    return reinterpret_cast<const HWCState*>(
               &_HWCState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HWCState& a, HWCState& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCState* New() const final {
    return CreateMaybeMessage<HWCState>(nullptr);
  }

  HWCState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCState& from);
  void MergeFrom(const HWCState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCState";
  }
  protected:
  explicit HWCState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHWCIDsFieldNumber = 1,
    kHWCModeFieldNumber = 2,
    kHWCColorFieldNumber = 3,
    kHWCExtendedFieldNumber = 4,
    kHWCTextFieldNumber = 5,
    kHWCGfxFieldNumber = 6,
  };
  // repeated uint32 HWCIDs = 1;
  int hwcids_size() const;
  private:
  int _internal_hwcids_size() const;
  public:
  void clear_hwcids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hwcids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_hwcids() const;
  void _internal_add_hwcids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_hwcids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 hwcids(int index) const;
  void set_hwcids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_hwcids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      hwcids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_hwcids();

  // .ibeam_rawpanel.HWCMode HWCMode = 2;
  bool has_hwcmode() const;
  private:
  bool _internal_has_hwcmode() const;
  public:
  void clear_hwcmode();
  const ::ibeam_rawpanel::HWCMode& hwcmode() const;
  ::ibeam_rawpanel::HWCMode* release_hwcmode();
  ::ibeam_rawpanel::HWCMode* mutable_hwcmode();
  void set_allocated_hwcmode(::ibeam_rawpanel::HWCMode* hwcmode);
  private:
  const ::ibeam_rawpanel::HWCMode& _internal_hwcmode() const;
  ::ibeam_rawpanel::HWCMode* _internal_mutable_hwcmode();
  public:
  void unsafe_arena_set_allocated_hwcmode(
      ::ibeam_rawpanel::HWCMode* hwcmode);
  ::ibeam_rawpanel::HWCMode* unsafe_arena_release_hwcmode();

  // .ibeam_rawpanel.HWCColor HWCColor = 3;
  bool has_hwccolor() const;
  private:
  bool _internal_has_hwccolor() const;
  public:
  void clear_hwccolor();
  const ::ibeam_rawpanel::HWCColor& hwccolor() const;
  ::ibeam_rawpanel::HWCColor* release_hwccolor();
  ::ibeam_rawpanel::HWCColor* mutable_hwccolor();
  void set_allocated_hwccolor(::ibeam_rawpanel::HWCColor* hwccolor);
  private:
  const ::ibeam_rawpanel::HWCColor& _internal_hwccolor() const;
  ::ibeam_rawpanel::HWCColor* _internal_mutable_hwccolor();
  public:
  void unsafe_arena_set_allocated_hwccolor(
      ::ibeam_rawpanel::HWCColor* hwccolor);
  ::ibeam_rawpanel::HWCColor* unsafe_arena_release_hwccolor();

  // .ibeam_rawpanel.HWCExtended HWCExtended = 4;
  bool has_hwcextended() const;
  private:
  bool _internal_has_hwcextended() const;
  public:
  void clear_hwcextended();
  const ::ibeam_rawpanel::HWCExtended& hwcextended() const;
  ::ibeam_rawpanel::HWCExtended* release_hwcextended();
  ::ibeam_rawpanel::HWCExtended* mutable_hwcextended();
  void set_allocated_hwcextended(::ibeam_rawpanel::HWCExtended* hwcextended);
  private:
  const ::ibeam_rawpanel::HWCExtended& _internal_hwcextended() const;
  ::ibeam_rawpanel::HWCExtended* _internal_mutable_hwcextended();
  public:
  void unsafe_arena_set_allocated_hwcextended(
      ::ibeam_rawpanel::HWCExtended* hwcextended);
  ::ibeam_rawpanel::HWCExtended* unsafe_arena_release_hwcextended();

  // .ibeam_rawpanel.HWCText HWCText = 5;
  bool has_hwctext() const;
  private:
  bool _internal_has_hwctext() const;
  public:
  void clear_hwctext();
  const ::ibeam_rawpanel::HWCText& hwctext() const;
  ::ibeam_rawpanel::HWCText* release_hwctext();
  ::ibeam_rawpanel::HWCText* mutable_hwctext();
  void set_allocated_hwctext(::ibeam_rawpanel::HWCText* hwctext);
  private:
  const ::ibeam_rawpanel::HWCText& _internal_hwctext() const;
  ::ibeam_rawpanel::HWCText* _internal_mutable_hwctext();
  public:
  void unsafe_arena_set_allocated_hwctext(
      ::ibeam_rawpanel::HWCText* hwctext);
  ::ibeam_rawpanel::HWCText* unsafe_arena_release_hwctext();

  // .ibeam_rawpanel.HWCGfx HWCGfx = 6;
  bool has_hwcgfx() const;
  private:
  bool _internal_has_hwcgfx() const;
  public:
  void clear_hwcgfx();
  const ::ibeam_rawpanel::HWCGfx& hwcgfx() const;
  ::ibeam_rawpanel::HWCGfx* release_hwcgfx();
  ::ibeam_rawpanel::HWCGfx* mutable_hwcgfx();
  void set_allocated_hwcgfx(::ibeam_rawpanel::HWCGfx* hwcgfx);
  private:
  const ::ibeam_rawpanel::HWCGfx& _internal_hwcgfx() const;
  ::ibeam_rawpanel::HWCGfx* _internal_mutable_hwcgfx();
  public:
  void unsafe_arena_set_allocated_hwcgfx(
      ::ibeam_rawpanel::HWCGfx* hwcgfx);
  ::ibeam_rawpanel::HWCGfx* unsafe_arena_release_hwcgfx();

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > hwcids_;
  mutable std::atomic<int> _hwcids_cached_byte_size_;
  ::ibeam_rawpanel::HWCMode* hwcmode_;
  ::ibeam_rawpanel::HWCColor* hwccolor_;
  ::ibeam_rawpanel::HWCExtended* hwcextended_;
  ::ibeam_rawpanel::HWCText* hwctext_;
  ::ibeam_rawpanel::HWCGfx* hwcgfx_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCMode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCMode) */ {
 public:
  inline HWCMode() : HWCMode(nullptr) {}
  virtual ~HWCMode();

  HWCMode(const HWCMode& from);
  HWCMode(HWCMode&& from) noexcept
    : HWCMode() {
    *this = ::std::move(from);
  }

  inline HWCMode& operator=(const HWCMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCMode& operator=(HWCMode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCMode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HWCMode* internal_default_instance() {
    return reinterpret_cast<const HWCMode*>(
               &_HWCMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(HWCMode& a, HWCMode& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCMode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCMode* New() const final {
    return CreateMaybeMessage<HWCMode>(nullptr);
  }

  HWCMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCMode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCMode& from);
  void MergeFrom(const HWCMode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCMode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCMode";
  }
  protected:
  explicit HWCMode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCMode_State State;
  static constexpr State OFF =
    HWCMode_State_OFF;
  static constexpr State ON =
    HWCMode_State_ON;
  static constexpr State DIMMED =
    HWCMode_State_DIMMED;
  static inline bool State_IsValid(int value) {
    return HWCMode_State_IsValid(value);
  }
  static constexpr State State_MIN =
    HWCMode_State_State_MIN;
  static constexpr State State_MAX =
    HWCMode_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    HWCMode_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return HWCMode_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return HWCMode_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return HWCMode_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 2,
    kBlinkPatternFieldNumber = 3,
  };
  // .ibeam_rawpanel.HWCMode.State state = 2;
  void clear_state();
  ::ibeam_rawpanel::HWCMode_State state() const;
  void set_state(::ibeam_rawpanel::HWCMode_State value);
  private:
  ::ibeam_rawpanel::HWCMode_State _internal_state() const;
  void _internal_set_state(::ibeam_rawpanel::HWCMode_State value);
  public:

  // uint32 BlinkPattern = 3;
  void clear_blinkpattern();
  ::PROTOBUF_NAMESPACE_ID::uint32 blinkpattern() const;
  void set_blinkpattern(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_blinkpattern() const;
  void _internal_set_blinkpattern(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int state_;
  ::PROTOBUF_NAMESPACE_ID::uint32 blinkpattern_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCExtended PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCExtended) */ {
 public:
  inline HWCExtended() : HWCExtended(nullptr) {}
  virtual ~HWCExtended();

  HWCExtended(const HWCExtended& from);
  HWCExtended(HWCExtended&& from) noexcept
    : HWCExtended() {
    *this = ::std::move(from);
  }

  inline HWCExtended& operator=(const HWCExtended& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCExtended& operator=(HWCExtended&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCExtended& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HWCExtended* internal_default_instance() {
    return reinterpret_cast<const HWCExtended*>(
               &_HWCExtended_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HWCExtended& a, HWCExtended& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCExtended* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCExtended* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCExtended* New() const final {
    return CreateMaybeMessage<HWCExtended>(nullptr);
  }

  HWCExtended* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCExtended>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCExtended& from);
  void MergeFrom(const HWCExtended& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCExtended* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCExtended";
  }
  protected:
  explicit HWCExtended(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCExtended_Interpretation Interpretation;
  static constexpr Interpretation NONE =
    HWCExtended_Interpretation_NONE;
  static constexpr Interpretation STRENGTH =
    HWCExtended_Interpretation_STRENGTH;
  static constexpr Interpretation STEPS =
    HWCExtended_Interpretation_STEPS;
  static constexpr Interpretation VU =
    HWCExtended_Interpretation_VU;
  static constexpr Interpretation FADER =
    HWCExtended_Interpretation_FADER;
  static inline bool Interpretation_IsValid(int value) {
    return HWCExtended_Interpretation_IsValid(value);
  }
  static constexpr Interpretation Interpretation_MIN =
    HWCExtended_Interpretation_Interpretation_MIN;
  static constexpr Interpretation Interpretation_MAX =
    HWCExtended_Interpretation_Interpretation_MAX;
  static constexpr int Interpretation_ARRAYSIZE =
    HWCExtended_Interpretation_Interpretation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Interpretation_descriptor() {
    return HWCExtended_Interpretation_descriptor();
  }
  template<typename T>
  static inline const std::string& Interpretation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Interpretation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Interpretation_Name.");
    return HWCExtended_Interpretation_Name(enum_t_value);
  }
  static inline bool Interpretation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Interpretation* value) {
    return HWCExtended_Interpretation_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInterpretationFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // .ibeam_rawpanel.HWCExtended.Interpretation interpretation = 2;
  void clear_interpretation();
  ::ibeam_rawpanel::HWCExtended_Interpretation interpretation() const;
  void set_interpretation(::ibeam_rawpanel::HWCExtended_Interpretation value);
  private:
  ::ibeam_rawpanel::HWCExtended_Interpretation _internal_interpretation() const;
  void _internal_set_interpretation(::ibeam_rawpanel::HWCExtended_Interpretation value);
  public:

  // uint32 Value = 3;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCExtended)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int interpretation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCColor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCColor) */ {
 public:
  inline HWCColor() : HWCColor(nullptr) {}
  virtual ~HWCColor();

  HWCColor(const HWCColor& from);
  HWCColor(HWCColor&& from) noexcept
    : HWCColor() {
    *this = ::std::move(from);
  }

  inline HWCColor& operator=(const HWCColor& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCColor& operator=(HWCColor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCColor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HWCColor* internal_default_instance() {
    return reinterpret_cast<const HWCColor*>(
               &_HWCColor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HWCColor& a, HWCColor& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCColor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCColor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCColor* New() const final {
    return CreateMaybeMessage<HWCColor>(nullptr);
  }

  HWCColor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCColor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCColor& from);
  void MergeFrom(const HWCColor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCColor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCColor";
  }
  protected:
  explicit HWCColor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorRGBFieldNumber = 1,
    kColorIndexFieldNumber = 2,
  };
  // .ibeam_rawpanel.ColorRGB colorRGB = 1;
  bool has_colorrgb() const;
  private:
  bool _internal_has_colorrgb() const;
  public:
  void clear_colorrgb();
  const ::ibeam_rawpanel::ColorRGB& colorrgb() const;
  ::ibeam_rawpanel::ColorRGB* release_colorrgb();
  ::ibeam_rawpanel::ColorRGB* mutable_colorrgb();
  void set_allocated_colorrgb(::ibeam_rawpanel::ColorRGB* colorrgb);
  private:
  const ::ibeam_rawpanel::ColorRGB& _internal_colorrgb() const;
  ::ibeam_rawpanel::ColorRGB* _internal_mutable_colorrgb();
  public:
  void unsafe_arena_set_allocated_colorrgb(
      ::ibeam_rawpanel::ColorRGB* colorrgb);
  ::ibeam_rawpanel::ColorRGB* unsafe_arena_release_colorrgb();

  // .ibeam_rawpanel.ColorIndex colorIndex = 2;
  bool has_colorindex() const;
  private:
  bool _internal_has_colorindex() const;
  public:
  void clear_colorindex();
  const ::ibeam_rawpanel::ColorIndex& colorindex() const;
  ::ibeam_rawpanel::ColorIndex* release_colorindex();
  ::ibeam_rawpanel::ColorIndex* mutable_colorindex();
  void set_allocated_colorindex(::ibeam_rawpanel::ColorIndex* colorindex);
  private:
  const ::ibeam_rawpanel::ColorIndex& _internal_colorindex() const;
  ::ibeam_rawpanel::ColorIndex* _internal_mutable_colorindex();
  public:
  void unsafe_arena_set_allocated_colorindex(
      ::ibeam_rawpanel::ColorIndex* colorindex);
  ::ibeam_rawpanel::ColorIndex* unsafe_arena_release_colorindex();

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCColor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ibeam_rawpanel::ColorRGB* colorrgb_;
  ::ibeam_rawpanel::ColorIndex* colorindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class Color PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.Color) */ {
 public:
  inline Color() : Color(nullptr) {}
  virtual ~Color();

  Color(const Color& from);
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Color& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Color* New() const final {
    return CreateMaybeMessage<Color>(nullptr);
  }

  Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.Color";
  }
  protected:
  explicit Color(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorRGBFieldNumber = 1,
    kColorIndexFieldNumber = 2,
  };
  // .ibeam_rawpanel.ColorRGB colorRGB = 1;
  bool has_colorrgb() const;
  private:
  bool _internal_has_colorrgb() const;
  public:
  void clear_colorrgb();
  const ::ibeam_rawpanel::ColorRGB& colorrgb() const;
  ::ibeam_rawpanel::ColorRGB* release_colorrgb();
  ::ibeam_rawpanel::ColorRGB* mutable_colorrgb();
  void set_allocated_colorrgb(::ibeam_rawpanel::ColorRGB* colorrgb);
  private:
  const ::ibeam_rawpanel::ColorRGB& _internal_colorrgb() const;
  ::ibeam_rawpanel::ColorRGB* _internal_mutable_colorrgb();
  public:
  void unsafe_arena_set_allocated_colorrgb(
      ::ibeam_rawpanel::ColorRGB* colorrgb);
  ::ibeam_rawpanel::ColorRGB* unsafe_arena_release_colorrgb();

  // .ibeam_rawpanel.ColorIndex colorIndex = 2;
  bool has_colorindex() const;
  private:
  bool _internal_has_colorindex() const;
  public:
  void clear_colorindex();
  const ::ibeam_rawpanel::ColorIndex& colorindex() const;
  ::ibeam_rawpanel::ColorIndex* release_colorindex();
  ::ibeam_rawpanel::ColorIndex* mutable_colorindex();
  void set_allocated_colorindex(::ibeam_rawpanel::ColorIndex* colorindex);
  private:
  const ::ibeam_rawpanel::ColorIndex& _internal_colorindex() const;
  ::ibeam_rawpanel::ColorIndex* _internal_mutable_colorindex();
  public:
  void unsafe_arena_set_allocated_colorindex(
      ::ibeam_rawpanel::ColorIndex* colorindex);
  ::ibeam_rawpanel::ColorIndex* unsafe_arena_release_colorindex();

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.Color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ibeam_rawpanel::ColorRGB* colorrgb_;
  ::ibeam_rawpanel::ColorIndex* colorindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class ColorRGB PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.ColorRGB) */ {
 public:
  inline ColorRGB() : ColorRGB(nullptr) {}
  virtual ~ColorRGB();

  ColorRGB(const ColorRGB& from);
  ColorRGB(ColorRGB&& from) noexcept
    : ColorRGB() {
    *this = ::std::move(from);
  }

  inline ColorRGB& operator=(const ColorRGB& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorRGB& operator=(ColorRGB&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColorRGB& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColorRGB* internal_default_instance() {
    return reinterpret_cast<const ColorRGB*>(
               &_ColorRGB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ColorRGB& a, ColorRGB& b) {
    a.Swap(&b);
  }
  inline void Swap(ColorRGB* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorRGB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColorRGB* New() const final {
    return CreateMaybeMessage<ColorRGB>(nullptr);
  }

  ColorRGB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColorRGB>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColorRGB& from);
  void MergeFrom(const ColorRGB& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColorRGB* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.ColorRGB";
  }
  protected:
  explicit ColorRGB(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRedFieldNumber = 1,
    kGreenFieldNumber = 2,
    kBlueFieldNumber = 3,
  };
  // uint32 Red = 1;
  void clear_red();
  ::PROTOBUF_NAMESPACE_ID::uint32 red() const;
  void set_red(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_red() const;
  void _internal_set_red(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 Green = 2;
  void clear_green();
  ::PROTOBUF_NAMESPACE_ID::uint32 green() const;
  void set_green(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_green() const;
  void _internal_set_green(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 Blue = 3;
  void clear_blue();
  ::PROTOBUF_NAMESPACE_ID::uint32 blue() const;
  void set_blue(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_blue() const;
  void _internal_set_blue(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.ColorRGB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 red_;
  ::PROTOBUF_NAMESPACE_ID::uint32 green_;
  ::PROTOBUF_NAMESPACE_ID::uint32 blue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class ColorIndex PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.ColorIndex) */ {
 public:
  inline ColorIndex() : ColorIndex(nullptr) {}
  virtual ~ColorIndex();

  ColorIndex(const ColorIndex& from);
  ColorIndex(ColorIndex&& from) noexcept
    : ColorIndex() {
    *this = ::std::move(from);
  }

  inline ColorIndex& operator=(const ColorIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorIndex& operator=(ColorIndex&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColorIndex& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColorIndex* internal_default_instance() {
    return reinterpret_cast<const ColorIndex*>(
               &_ColorIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ColorIndex& a, ColorIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(ColorIndex* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColorIndex* New() const final {
    return CreateMaybeMessage<ColorIndex>(nullptr);
  }

  ColorIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColorIndex>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColorIndex& from);
  void MergeFrom(const ColorIndex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColorIndex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.ColorIndex";
  }
  protected:
  explicit ColorIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ColorIndex_Colors Colors;
  static constexpr Colors DEFAULT =
    ColorIndex_Colors_DEFAULT;
  static constexpr Colors OFF =
    ColorIndex_Colors_OFF;
  static constexpr Colors WHITE =
    ColorIndex_Colors_WHITE;
  static constexpr Colors WARM =
    ColorIndex_Colors_WARM;
  static constexpr Colors RED =
    ColorIndex_Colors_RED;
  static constexpr Colors ROSE =
    ColorIndex_Colors_ROSE;
  static constexpr Colors PINK =
    ColorIndex_Colors_PINK;
  static constexpr Colors PURPLE =
    ColorIndex_Colors_PURPLE;
  static constexpr Colors AMBER =
    ColorIndex_Colors_AMBER;
  static constexpr Colors YELLOW =
    ColorIndex_Colors_YELLOW;
  static constexpr Colors DARKBLUE =
    ColorIndex_Colors_DARKBLUE;
  static constexpr Colors BLUE =
    ColorIndex_Colors_BLUE;
  static constexpr Colors ICE =
    ColorIndex_Colors_ICE;
  static constexpr Colors CYAN =
    ColorIndex_Colors_CYAN;
  static constexpr Colors SPRING =
    ColorIndex_Colors_SPRING;
  static constexpr Colors GREEN =
    ColorIndex_Colors_GREEN;
  static constexpr Colors MINT =
    ColorIndex_Colors_MINT;
  static inline bool Colors_IsValid(int value) {
    return ColorIndex_Colors_IsValid(value);
  }
  static constexpr Colors Colors_MIN =
    ColorIndex_Colors_Colors_MIN;
  static constexpr Colors Colors_MAX =
    ColorIndex_Colors_Colors_MAX;
  static constexpr int Colors_ARRAYSIZE =
    ColorIndex_Colors_Colors_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Colors_descriptor() {
    return ColorIndex_Colors_descriptor();
  }
  template<typename T>
  static inline const std::string& Colors_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Colors>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Colors_Name.");
    return ColorIndex_Colors_Name(enum_t_value);
  }
  static inline bool Colors_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Colors* value) {
    return ColorIndex_Colors_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // .ibeam_rawpanel.ColorIndex.Colors Index = 1;
  void clear_index();
  ::ibeam_rawpanel::ColorIndex_Colors index() const;
  void set_index(::ibeam_rawpanel::ColorIndex_Colors value);
  private:
  ::ibeam_rawpanel::ColorIndex_Colors _internal_index() const;
  void _internal_set_index(::ibeam_rawpanel::ColorIndex_Colors value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.ColorIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCText_Scale PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCText.Scale) */ {
 public:
  inline HWCText_Scale() : HWCText_Scale(nullptr) {}
  virtual ~HWCText_Scale();

  HWCText_Scale(const HWCText_Scale& from);
  HWCText_Scale(HWCText_Scale&& from) noexcept
    : HWCText_Scale() {
    *this = ::std::move(from);
  }

  inline HWCText_Scale& operator=(const HWCText_Scale& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCText_Scale& operator=(HWCText_Scale&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCText_Scale& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HWCText_Scale* internal_default_instance() {
    return reinterpret_cast<const HWCText_Scale*>(
               &_HWCText_Scale_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(HWCText_Scale& a, HWCText_Scale& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCText_Scale* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCText_Scale* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCText_Scale* New() const final {
    return CreateMaybeMessage<HWCText_Scale>(nullptr);
  }

  HWCText_Scale* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCText_Scale>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCText_Scale& from);
  void MergeFrom(const HWCText_Scale& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCText_Scale* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCText.Scale";
  }
  protected:
  explicit HWCText_Scale(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCText_Scale_ScaleType ScaleType;
  static constexpr ScaleType ST_OFF =
    HWCText_Scale_ScaleType_ST_OFF;
  static constexpr ScaleType ST_STRENGTH =
    HWCText_Scale_ScaleType_ST_STRENGTH;
  static constexpr ScaleType ST_CENTER_MARKER =
    HWCText_Scale_ScaleType_ST_CENTER_MARKER;
  static constexpr ScaleType ST_CENTER_BAR =
    HWCText_Scale_ScaleType_ST_CENTER_BAR;
  static inline bool ScaleType_IsValid(int value) {
    return HWCText_Scale_ScaleType_IsValid(value);
  }
  static constexpr ScaleType ScaleType_MIN =
    HWCText_Scale_ScaleType_ScaleType_MIN;
  static constexpr ScaleType ScaleType_MAX =
    HWCText_Scale_ScaleType_ScaleType_MAX;
  static constexpr int ScaleType_ARRAYSIZE =
    HWCText_Scale_ScaleType_ScaleType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScaleType_descriptor() {
    return HWCText_Scale_ScaleType_descriptor();
  }
  template<typename T>
  static inline const std::string& ScaleType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScaleType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScaleType_Name.");
    return HWCText_Scale_ScaleType_Name(enum_t_value);
  }
  static inline bool ScaleType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScaleType* value) {
    return HWCText_Scale_ScaleType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kScaleTypeFieldNumber = 1,
    kRangeLowFieldNumber = 2,
    kRangeHighFieldNumber = 3,
    kLimitLowFieldNumber = 4,
    kLimitHighFieldNumber = 5,
  };
  // .ibeam_rawpanel.HWCText.Scale.ScaleType scaleType = 1;
  void clear_scaletype();
  ::ibeam_rawpanel::HWCText_Scale_ScaleType scaletype() const;
  void set_scaletype(::ibeam_rawpanel::HWCText_Scale_ScaleType value);
  private:
  ::ibeam_rawpanel::HWCText_Scale_ScaleType _internal_scaletype() const;
  void _internal_set_scaletype(::ibeam_rawpanel::HWCText_Scale_ScaleType value);
  public:

  // sint32 RangeLow = 2;
  void clear_rangelow();
  ::PROTOBUF_NAMESPACE_ID::int32 rangelow() const;
  void set_rangelow(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rangelow() const;
  void _internal_set_rangelow(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 RangeHigh = 3;
  void clear_rangehigh();
  ::PROTOBUF_NAMESPACE_ID::int32 rangehigh() const;
  void set_rangehigh(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rangehigh() const;
  void _internal_set_rangehigh(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 LimitLow = 4;
  void clear_limitlow();
  ::PROTOBUF_NAMESPACE_ID::int32 limitlow() const;
  void set_limitlow(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_limitlow() const;
  void _internal_set_limitlow(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 LimitHigh = 5;
  void clear_limithigh();
  ::PROTOBUF_NAMESPACE_ID::int32 limithigh() const;
  void set_limithigh(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_limithigh() const;
  void _internal_set_limithigh(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCText.Scale)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int scaletype_;
  ::PROTOBUF_NAMESPACE_ID::int32 rangelow_;
  ::PROTOBUF_NAMESPACE_ID::int32 rangehigh_;
  ::PROTOBUF_NAMESPACE_ID::int32 limitlow_;
  ::PROTOBUF_NAMESPACE_ID::int32 limithigh_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCText_TextStyle_Font PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCText.TextStyle.Font) */ {
 public:
  inline HWCText_TextStyle_Font() : HWCText_TextStyle_Font(nullptr) {}
  virtual ~HWCText_TextStyle_Font();

  HWCText_TextStyle_Font(const HWCText_TextStyle_Font& from);
  HWCText_TextStyle_Font(HWCText_TextStyle_Font&& from) noexcept
    : HWCText_TextStyle_Font() {
    *this = ::std::move(from);
  }

  inline HWCText_TextStyle_Font& operator=(const HWCText_TextStyle_Font& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCText_TextStyle_Font& operator=(HWCText_TextStyle_Font&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCText_TextStyle_Font& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HWCText_TextStyle_Font* internal_default_instance() {
    return reinterpret_cast<const HWCText_TextStyle_Font*>(
               &_HWCText_TextStyle_Font_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HWCText_TextStyle_Font& a, HWCText_TextStyle_Font& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCText_TextStyle_Font* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCText_TextStyle_Font* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCText_TextStyle_Font* New() const final {
    return CreateMaybeMessage<HWCText_TextStyle_Font>(nullptr);
  }

  HWCText_TextStyle_Font* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCText_TextStyle_Font>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCText_TextStyle_Font& from);
  void MergeFrom(const HWCText_TextStyle_Font& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCText_TextStyle_Font* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCText.TextStyle.Font";
  }
  protected:
  explicit HWCText_TextStyle_Font(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCText_TextStyle_Font_FontFace FontFace;
  static constexpr FontFace ST_DEFAULT =
    HWCText_TextStyle_Font_FontFace_ST_DEFAULT;
  static constexpr FontFace ST_BOLD =
    HWCText_TextStyle_Font_FontFace_ST_BOLD;
  static constexpr FontFace ST_TINY =
    HWCText_TextStyle_Font_FontFace_ST_TINY;
  static inline bool FontFace_IsValid(int value) {
    return HWCText_TextStyle_Font_FontFace_IsValid(value);
  }
  static constexpr FontFace FontFace_MIN =
    HWCText_TextStyle_Font_FontFace_FontFace_MIN;
  static constexpr FontFace FontFace_MAX =
    HWCText_TextStyle_Font_FontFace_FontFace_MAX;
  static constexpr int FontFace_ARRAYSIZE =
    HWCText_TextStyle_Font_FontFace_FontFace_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FontFace_descriptor() {
    return HWCText_TextStyle_Font_FontFace_descriptor();
  }
  template<typename T>
  static inline const std::string& FontFace_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FontFace>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FontFace_Name.");
    return HWCText_TextStyle_Font_FontFace_Name(enum_t_value);
  }
  static inline bool FontFace_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FontFace* value) {
    return HWCText_TextStyle_Font_FontFace_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFontFaceFieldNumber = 1,
    kTextHeightFieldNumber = 2,
    kTextWidthFieldNumber = 3,
  };
  // .ibeam_rawpanel.HWCText.TextStyle.Font.FontFace fontFace = 1;
  void clear_fontface();
  ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFace fontface() const;
  void set_fontface(::ibeam_rawpanel::HWCText_TextStyle_Font_FontFace value);
  private:
  ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFace _internal_fontface() const;
  void _internal_set_fontface(::ibeam_rawpanel::HWCText_TextStyle_Font_FontFace value);
  public:

  // uint32 TextHeight = 2;
  void clear_textheight();
  ::PROTOBUF_NAMESPACE_ID::uint32 textheight() const;
  void set_textheight(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_textheight() const;
  void _internal_set_textheight(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 TextWidth = 3;
  void clear_textwidth();
  ::PROTOBUF_NAMESPACE_ID::uint32 textwidth() const;
  void set_textwidth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_textwidth() const;
  void _internal_set_textwidth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCText.TextStyle.Font)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int fontface_;
  ::PROTOBUF_NAMESPACE_ID::uint32 textheight_;
  ::PROTOBUF_NAMESPACE_ID::uint32 textwidth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCText_TextStyle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCText.TextStyle) */ {
 public:
  inline HWCText_TextStyle() : HWCText_TextStyle(nullptr) {}
  virtual ~HWCText_TextStyle();

  HWCText_TextStyle(const HWCText_TextStyle& from);
  HWCText_TextStyle(HWCText_TextStyle&& from) noexcept
    : HWCText_TextStyle() {
    *this = ::std::move(from);
  }

  inline HWCText_TextStyle& operator=(const HWCText_TextStyle& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCText_TextStyle& operator=(HWCText_TextStyle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCText_TextStyle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HWCText_TextStyle* internal_default_instance() {
    return reinterpret_cast<const HWCText_TextStyle*>(
               &_HWCText_TextStyle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HWCText_TextStyle& a, HWCText_TextStyle& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCText_TextStyle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCText_TextStyle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCText_TextStyle* New() const final {
    return CreateMaybeMessage<HWCText_TextStyle>(nullptr);
  }

  HWCText_TextStyle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCText_TextStyle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCText_TextStyle& from);
  void MergeFrom(const HWCText_TextStyle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCText_TextStyle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCText.TextStyle";
  }
  protected:
  explicit HWCText_TextStyle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCText_TextStyle_Font Font;

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFontFieldNumber = 1,
    kTextFontFieldNumber = 2,
    kFixedWidthFieldNumber = 3,
    kTitleBarPaddingFieldNumber = 4,
    kExtraCharacterSpacingFieldNumber = 5,
    kUnformattedFontSizeFieldNumber = 6,
  };
  // .ibeam_rawpanel.HWCText.TextStyle.Font TitleFont = 1;
  bool has_titlefont() const;
  private:
  bool _internal_has_titlefont() const;
  public:
  void clear_titlefont();
  const ::ibeam_rawpanel::HWCText_TextStyle_Font& titlefont() const;
  ::ibeam_rawpanel::HWCText_TextStyle_Font* release_titlefont();
  ::ibeam_rawpanel::HWCText_TextStyle_Font* mutable_titlefont();
  void set_allocated_titlefont(::ibeam_rawpanel::HWCText_TextStyle_Font* titlefont);
  private:
  const ::ibeam_rawpanel::HWCText_TextStyle_Font& _internal_titlefont() const;
  ::ibeam_rawpanel::HWCText_TextStyle_Font* _internal_mutable_titlefont();
  public:
  void unsafe_arena_set_allocated_titlefont(
      ::ibeam_rawpanel::HWCText_TextStyle_Font* titlefont);
  ::ibeam_rawpanel::HWCText_TextStyle_Font* unsafe_arena_release_titlefont();

  // .ibeam_rawpanel.HWCText.TextStyle.Font TextFont = 2;
  bool has_textfont() const;
  private:
  bool _internal_has_textfont() const;
  public:
  void clear_textfont();
  const ::ibeam_rawpanel::HWCText_TextStyle_Font& textfont() const;
  ::ibeam_rawpanel::HWCText_TextStyle_Font* release_textfont();
  ::ibeam_rawpanel::HWCText_TextStyle_Font* mutable_textfont();
  void set_allocated_textfont(::ibeam_rawpanel::HWCText_TextStyle_Font* textfont);
  private:
  const ::ibeam_rawpanel::HWCText_TextStyle_Font& _internal_textfont() const;
  ::ibeam_rawpanel::HWCText_TextStyle_Font* _internal_mutable_textfont();
  public:
  void unsafe_arena_set_allocated_textfont(
      ::ibeam_rawpanel::HWCText_TextStyle_Font* textfont);
  ::ibeam_rawpanel::HWCText_TextStyle_Font* unsafe_arena_release_textfont();

  // bool FixedWidth = 3;
  void clear_fixedwidth();
  bool fixedwidth() const;
  void set_fixedwidth(bool value);
  private:
  bool _internal_fixedwidth() const;
  void _internal_set_fixedwidth(bool value);
  public:

  // uint32 TitleBarPadding = 4;
  void clear_titlebarpadding();
  ::PROTOBUF_NAMESPACE_ID::uint32 titlebarpadding() const;
  void set_titlebarpadding(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_titlebarpadding() const;
  void _internal_set_titlebarpadding(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 ExtraCharacterSpacing = 5;
  void clear_extracharacterspacing();
  ::PROTOBUF_NAMESPACE_ID::uint32 extracharacterspacing() const;
  void set_extracharacterspacing(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_extracharacterspacing() const;
  void _internal_set_extracharacterspacing(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 UnformattedFontSize = 6;
  void clear_unformattedfontsize();
  ::PROTOBUF_NAMESPACE_ID::uint32 unformattedfontsize() const;
  void set_unformattedfontsize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_unformattedfontsize() const;
  void _internal_set_unformattedfontsize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCText.TextStyle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ibeam_rawpanel::HWCText_TextStyle_Font* titlefont_;
  ::ibeam_rawpanel::HWCText_TextStyle_Font* textfont_;
  bool fixedwidth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 titlebarpadding_;
  ::PROTOBUF_NAMESPACE_ID::uint32 extracharacterspacing_;
  ::PROTOBUF_NAMESPACE_ID::uint32 unformattedfontsize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCText PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCText) */ {
 public:
  inline HWCText() : HWCText(nullptr) {}
  virtual ~HWCText();

  HWCText(const HWCText& from);
  HWCText(HWCText&& from) noexcept
    : HWCText() {
    *this = ::std::move(from);
  }

  inline HWCText& operator=(const HWCText& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCText& operator=(HWCText&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCText& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HWCText* internal_default_instance() {
    return reinterpret_cast<const HWCText*>(
               &_HWCText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HWCText& a, HWCText& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCText* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCText* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCText* New() const final {
    return CreateMaybeMessage<HWCText>(nullptr);
  }

  HWCText* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCText>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCText& from);
  void MergeFrom(const HWCText& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCText* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCText";
  }
  protected:
  explicit HWCText(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCText_Scale Scale;
  typedef HWCText_TextStyle TextStyle;

  typedef HWCText_Formatting Formatting;
  static constexpr Formatting FMT_INTEGER =
    HWCText_Formatting_FMT_INTEGER;
  static constexpr Formatting FMT_PERCENTAGE =
    HWCText_Formatting_FMT_PERCENTAGE;
  static constexpr Formatting FMT_DB =
    HWCText_Formatting_FMT_DB;
  static constexpr Formatting FMT_FRAMES =
    HWCText_Formatting_FMT_FRAMES;
  static constexpr Formatting FMT_ONEOVERX =
    HWCText_Formatting_FMT_ONEOVERX;
  static constexpr Formatting FMT_KELVIN =
    HWCText_Formatting_FMT_KELVIN;
  static constexpr Formatting FMT_HIDE =
    HWCText_Formatting_FMT_HIDE;
  static constexpr Formatting FMT_FLOAT_X_XXX =
    HWCText_Formatting_FMT_FLOAT_X_XXX;
  static constexpr Formatting FMT_FLOAT_XX_XX =
    HWCText_Formatting_FMT_FLOAT_XX_XX;
  static constexpr Formatting FMT_ONELINE =
    HWCText_Formatting_FMT_ONELINE;
  static constexpr Formatting FMT_TWOLINES =
    HWCText_Formatting_FMT_TWOLINES;
  static constexpr Formatting FMT_FLOAT_XXX_X =
    HWCText_Formatting_FMT_FLOAT_XXX_X;
  static inline bool Formatting_IsValid(int value) {
    return HWCText_Formatting_IsValid(value);
  }
  static constexpr Formatting Formatting_MIN =
    HWCText_Formatting_Formatting_MIN;
  static constexpr Formatting Formatting_MAX =
    HWCText_Formatting_Formatting_MAX;
  static constexpr int Formatting_ARRAYSIZE =
    HWCText_Formatting_Formatting_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Formatting_descriptor() {
    return HWCText_Formatting_descriptor();
  }
  template<typename T>
  static inline const std::string& Formatting_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Formatting>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Formatting_Name.");
    return HWCText_Formatting_Name(enum_t_value);
  }
  static inline bool Formatting_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Formatting* value) {
    return HWCText_Formatting_Parse(name, value);
  }

  typedef HWCText_StateIcon StateIcon;
  static constexpr StateIcon SI_NONE =
    HWCText_StateIcon_SI_NONE;
  static constexpr StateIcon SI_FINE =
    HWCText_StateIcon_SI_FINE;
  static constexpr StateIcon SI_LOCK =
    HWCText_StateIcon_SI_LOCK;
  static constexpr StateIcon SI_NOACCESS =
    HWCText_StateIcon_SI_NOACCESS;
  static inline bool StateIcon_IsValid(int value) {
    return HWCText_StateIcon_IsValid(value);
  }
  static constexpr StateIcon StateIcon_MIN =
    HWCText_StateIcon_StateIcon_MIN;
  static constexpr StateIcon StateIcon_MAX =
    HWCText_StateIcon_StateIcon_MAX;
  static constexpr int StateIcon_ARRAYSIZE =
    HWCText_StateIcon_StateIcon_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StateIcon_descriptor() {
    return HWCText_StateIcon_descriptor();
  }
  template<typename T>
  static inline const std::string& StateIcon_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StateIcon>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StateIcon_Name.");
    return HWCText_StateIcon_Name(enum_t_value);
  }
  static inline bool StateIcon_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StateIcon* value) {
    return HWCText_StateIcon_Parse(name, value);
  }

  typedef HWCText_ModifierIcon ModifierIcon;
  static constexpr ModifierIcon MI_NONE =
    HWCText_ModifierIcon_MI_NONE;
  static constexpr ModifierIcon MI_CYCLE =
    HWCText_ModifierIcon_MI_CYCLE;
  static constexpr ModifierIcon MI_DOWN =
    HWCText_ModifierIcon_MI_DOWN;
  static constexpr ModifierIcon MI_UP =
    HWCText_ModifierIcon_MI_UP;
  static constexpr ModifierIcon MI_HOLD =
    HWCText_ModifierIcon_MI_HOLD;
  static constexpr ModifierIcon MI_TOGGLE =
    HWCText_ModifierIcon_MI_TOGGLE;
  static constexpr ModifierIcon MI_OK =
    HWCText_ModifierIcon_MI_OK;
  static constexpr ModifierIcon MI_QUESTION =
    HWCText_ModifierIcon_MI_QUESTION;
  static inline bool ModifierIcon_IsValid(int value) {
    return HWCText_ModifierIcon_IsValid(value);
  }
  static constexpr ModifierIcon ModifierIcon_MIN =
    HWCText_ModifierIcon_ModifierIcon_MIN;
  static constexpr ModifierIcon ModifierIcon_MAX =
    HWCText_ModifierIcon_ModifierIcon_MAX;
  static constexpr int ModifierIcon_ARRAYSIZE =
    HWCText_ModifierIcon_ModifierIcon_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ModifierIcon_descriptor() {
    return HWCText_ModifierIcon_descriptor();
  }
  template<typename T>
  static inline const std::string& ModifierIcon_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ModifierIcon>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ModifierIcon_Name.");
    return HWCText_ModifierIcon_Name(enum_t_value);
  }
  static inline bool ModifierIcon_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ModifierIcon* value) {
    return HWCText_ModifierIcon_Parse(name, value);
  }

  typedef HWCText_PairMode PairMode;
  static constexpr PairMode PM_OFF =
    HWCText_PairMode_PM_OFF;
  static constexpr PairMode PM_UNMARKED =
    HWCText_PairMode_PM_UNMARKED;
  static constexpr PairMode PM_UPPER_MARKED =
    HWCText_PairMode_PM_UPPER_MARKED;
  static constexpr PairMode PM_LOWER_MARKED =
    HWCText_PairMode_PM_LOWER_MARKED;
  static constexpr PairMode PM_BOTH_MARKED =
    HWCText_PairMode_PM_BOTH_MARKED;
  static inline bool PairMode_IsValid(int value) {
    return HWCText_PairMode_IsValid(value);
  }
  static constexpr PairMode PairMode_MIN =
    HWCText_PairMode_PairMode_MIN;
  static constexpr PairMode PairMode_MAX =
    HWCText_PairMode_PairMode_MAX;
  static constexpr int PairMode_ARRAYSIZE =
    HWCText_PairMode_PairMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PairMode_descriptor() {
    return HWCText_PairMode_descriptor();
  }
  template<typename T>
  static inline const std::string& PairMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PairMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PairMode_Name.");
    return HWCText_PairMode_Name(enum_t_value);
  }
  static inline bool PairMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PairMode* value) {
    return HWCText_PairMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 7,
    kTextline1FieldNumber = 9,
    kTextline2FieldNumber = 10,
    kScaleFieldNumber = 13,
    kTextStylingFieldNumber = 14,
    kPixelColorFieldNumber = 16,
    kBackgroundColorFieldNumber = 17,
    kIntegerValueFieldNumber = 2,
    kFormattingFieldNumber = 3,
    kStateIconFieldNumber = 5,
    kModifierIconFieldNumber = 6,
    kIntegerValue2FieldNumber = 11,
    kSolidHeaderBarFieldNumber = 8,
    kInvertedFieldNumber = 15,
    kPairModeFieldNumber = 12,
  };
  // string Title = 7;
  void clear_title();
  const std::string& title() const;
  void set_title(const std::string& value);
  void set_title(std::string&& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string Textline1 = 9;
  void clear_textline1();
  const std::string& textline1() const;
  void set_textline1(const std::string& value);
  void set_textline1(std::string&& value);
  void set_textline1(const char* value);
  void set_textline1(const char* value, size_t size);
  std::string* mutable_textline1();
  std::string* release_textline1();
  void set_allocated_textline1(std::string* textline1);
  private:
  const std::string& _internal_textline1() const;
  void _internal_set_textline1(const std::string& value);
  std::string* _internal_mutable_textline1();
  public:

  // string Textline2 = 10;
  void clear_textline2();
  const std::string& textline2() const;
  void set_textline2(const std::string& value);
  void set_textline2(std::string&& value);
  void set_textline2(const char* value);
  void set_textline2(const char* value, size_t size);
  std::string* mutable_textline2();
  std::string* release_textline2();
  void set_allocated_textline2(std::string* textline2);
  private:
  const std::string& _internal_textline2() const;
  void _internal_set_textline2(const std::string& value);
  std::string* _internal_mutable_textline2();
  public:

  // .ibeam_rawpanel.HWCText.Scale scale = 13;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  const ::ibeam_rawpanel::HWCText_Scale& scale() const;
  ::ibeam_rawpanel::HWCText_Scale* release_scale();
  ::ibeam_rawpanel::HWCText_Scale* mutable_scale();
  void set_allocated_scale(::ibeam_rawpanel::HWCText_Scale* scale);
  private:
  const ::ibeam_rawpanel::HWCText_Scale& _internal_scale() const;
  ::ibeam_rawpanel::HWCText_Scale* _internal_mutable_scale();
  public:
  void unsafe_arena_set_allocated_scale(
      ::ibeam_rawpanel::HWCText_Scale* scale);
  ::ibeam_rawpanel::HWCText_Scale* unsafe_arena_release_scale();

  // .ibeam_rawpanel.HWCText.TextStyle TextStyling = 14;
  bool has_textstyling() const;
  private:
  bool _internal_has_textstyling() const;
  public:
  void clear_textstyling();
  const ::ibeam_rawpanel::HWCText_TextStyle& textstyling() const;
  ::ibeam_rawpanel::HWCText_TextStyle* release_textstyling();
  ::ibeam_rawpanel::HWCText_TextStyle* mutable_textstyling();
  void set_allocated_textstyling(::ibeam_rawpanel::HWCText_TextStyle* textstyling);
  private:
  const ::ibeam_rawpanel::HWCText_TextStyle& _internal_textstyling() const;
  ::ibeam_rawpanel::HWCText_TextStyle* _internal_mutable_textstyling();
  public:
  void unsafe_arena_set_allocated_textstyling(
      ::ibeam_rawpanel::HWCText_TextStyle* textstyling);
  ::ibeam_rawpanel::HWCText_TextStyle* unsafe_arena_release_textstyling();

  // .ibeam_rawpanel.Color PixelColor = 16;
  bool has_pixelcolor() const;
  private:
  bool _internal_has_pixelcolor() const;
  public:
  void clear_pixelcolor();
  const ::ibeam_rawpanel::Color& pixelcolor() const;
  ::ibeam_rawpanel::Color* release_pixelcolor();
  ::ibeam_rawpanel::Color* mutable_pixelcolor();
  void set_allocated_pixelcolor(::ibeam_rawpanel::Color* pixelcolor);
  private:
  const ::ibeam_rawpanel::Color& _internal_pixelcolor() const;
  ::ibeam_rawpanel::Color* _internal_mutable_pixelcolor();
  public:
  void unsafe_arena_set_allocated_pixelcolor(
      ::ibeam_rawpanel::Color* pixelcolor);
  ::ibeam_rawpanel::Color* unsafe_arena_release_pixelcolor();

  // .ibeam_rawpanel.Color BackgroundColor = 17;
  bool has_backgroundcolor() const;
  private:
  bool _internal_has_backgroundcolor() const;
  public:
  void clear_backgroundcolor();
  const ::ibeam_rawpanel::Color& backgroundcolor() const;
  ::ibeam_rawpanel::Color* release_backgroundcolor();
  ::ibeam_rawpanel::Color* mutable_backgroundcolor();
  void set_allocated_backgroundcolor(::ibeam_rawpanel::Color* backgroundcolor);
  private:
  const ::ibeam_rawpanel::Color& _internal_backgroundcolor() const;
  ::ibeam_rawpanel::Color* _internal_mutable_backgroundcolor();
  public:
  void unsafe_arena_set_allocated_backgroundcolor(
      ::ibeam_rawpanel::Color* backgroundcolor);
  ::ibeam_rawpanel::Color* unsafe_arena_release_backgroundcolor();

  // sint32 IntegerValue = 2;
  void clear_integervalue();
  ::PROTOBUF_NAMESPACE_ID::int32 integervalue() const;
  void set_integervalue(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_integervalue() const;
  void _internal_set_integervalue(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .ibeam_rawpanel.HWCText.Formatting formatting = 3;
  void clear_formatting();
  ::ibeam_rawpanel::HWCText_Formatting formatting() const;
  void set_formatting(::ibeam_rawpanel::HWCText_Formatting value);
  private:
  ::ibeam_rawpanel::HWCText_Formatting _internal_formatting() const;
  void _internal_set_formatting(::ibeam_rawpanel::HWCText_Formatting value);
  public:

  // .ibeam_rawpanel.HWCText.StateIcon stateIcon = 5;
  void clear_stateicon();
  ::ibeam_rawpanel::HWCText_StateIcon stateicon() const;
  void set_stateicon(::ibeam_rawpanel::HWCText_StateIcon value);
  private:
  ::ibeam_rawpanel::HWCText_StateIcon _internal_stateicon() const;
  void _internal_set_stateicon(::ibeam_rawpanel::HWCText_StateIcon value);
  public:

  // .ibeam_rawpanel.HWCText.ModifierIcon modifierIcon = 6;
  void clear_modifiericon();
  ::ibeam_rawpanel::HWCText_ModifierIcon modifiericon() const;
  void set_modifiericon(::ibeam_rawpanel::HWCText_ModifierIcon value);
  private:
  ::ibeam_rawpanel::HWCText_ModifierIcon _internal_modifiericon() const;
  void _internal_set_modifiericon(::ibeam_rawpanel::HWCText_ModifierIcon value);
  public:

  // sint32 IntegerValue2 = 11;
  void clear_integervalue2();
  ::PROTOBUF_NAMESPACE_ID::int32 integervalue2() const;
  void set_integervalue2(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_integervalue2() const;
  void _internal_set_integervalue2(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool SolidHeaderBar = 8;
  void clear_solidheaderbar();
  bool solidheaderbar() const;
  void set_solidheaderbar(bool value);
  private:
  bool _internal_solidheaderbar() const;
  void _internal_set_solidheaderbar(bool value);
  public:

  // bool Inverted = 15;
  void clear_inverted();
  bool inverted() const;
  void set_inverted(bool value);
  private:
  bool _internal_inverted() const;
  void _internal_set_inverted(bool value);
  public:

  // .ibeam_rawpanel.HWCText.PairMode pairMode = 12;
  void clear_pairmode();
  ::ibeam_rawpanel::HWCText_PairMode pairmode() const;
  void set_pairmode(::ibeam_rawpanel::HWCText_PairMode value);
  private:
  ::ibeam_rawpanel::HWCText_PairMode _internal_pairmode() const;
  void _internal_set_pairmode(::ibeam_rawpanel::HWCText_PairMode value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCText)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr textline1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr textline2_;
  ::ibeam_rawpanel::HWCText_Scale* scale_;
  ::ibeam_rawpanel::HWCText_TextStyle* textstyling_;
  ::ibeam_rawpanel::Color* pixelcolor_;
  ::ibeam_rawpanel::Color* backgroundcolor_;
  ::PROTOBUF_NAMESPACE_ID::int32 integervalue_;
  int formatting_;
  int stateicon_;
  int modifiericon_;
  ::PROTOBUF_NAMESPACE_ID::int32 integervalue2_;
  bool solidheaderbar_;
  bool inverted_;
  int pairmode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCGfx PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCGfx) */ {
 public:
  inline HWCGfx() : HWCGfx(nullptr) {}
  virtual ~HWCGfx();

  HWCGfx(const HWCGfx& from);
  HWCGfx(HWCGfx&& from) noexcept
    : HWCGfx() {
    *this = ::std::move(from);
  }

  inline HWCGfx& operator=(const HWCGfx& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCGfx& operator=(HWCGfx&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCGfx& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HWCGfx* internal_default_instance() {
    return reinterpret_cast<const HWCGfx*>(
               &_HWCGfx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HWCGfx& a, HWCGfx& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCGfx* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCGfx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCGfx* New() const final {
    return CreateMaybeMessage<HWCGfx>(nullptr);
  }

  HWCGfx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCGfx>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCGfx& from);
  void MergeFrom(const HWCGfx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCGfx* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCGfx";
  }
  protected:
  explicit HWCGfx(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCGfx_ImageType ImageType;
  static constexpr ImageType MONO =
    HWCGfx_ImageType_MONO;
  static constexpr ImageType RGB16bit =
    HWCGfx_ImageType_RGB16bit;
  static inline bool ImageType_IsValid(int value) {
    return HWCGfx_ImageType_IsValid(value);
  }
  static constexpr ImageType ImageType_MIN =
    HWCGfx_ImageType_ImageType_MIN;
  static constexpr ImageType ImageType_MAX =
    HWCGfx_ImageType_ImageType_MAX;
  static constexpr int ImageType_ARRAYSIZE =
    HWCGfx_ImageType_ImageType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ImageType_descriptor() {
    return HWCGfx_ImageType_descriptor();
  }
  template<typename T>
  static inline const std::string& ImageType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ImageType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ImageType_Name.");
    return HWCGfx_ImageType_Name(enum_t_value);
  }
  static inline bool ImageType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ImageType* value) {
    return HWCGfx_ImageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kImageDataFieldNumber = 16,
    kImageTypeFieldNumber = 1,
    kWFieldNumber = 2,
    kHFieldNumber = 3,
    kXYoffsetFieldNumber = 4,
    kXFieldNumber = 5,
    kYFieldNumber = 6,
  };
  // bytes ImageData = 16;
  void clear_imagedata();
  const std::string& imagedata() const;
  void set_imagedata(const std::string& value);
  void set_imagedata(std::string&& value);
  void set_imagedata(const char* value);
  void set_imagedata(const void* value, size_t size);
  std::string* mutable_imagedata();
  std::string* release_imagedata();
  void set_allocated_imagedata(std::string* imagedata);
  private:
  const std::string& _internal_imagedata() const;
  void _internal_set_imagedata(const std::string& value);
  std::string* _internal_mutable_imagedata();
  public:

  // .ibeam_rawpanel.HWCGfx.ImageType imageType = 1;
  void clear_imagetype();
  ::ibeam_rawpanel::HWCGfx_ImageType imagetype() const;
  void set_imagetype(::ibeam_rawpanel::HWCGfx_ImageType value);
  private:
  ::ibeam_rawpanel::HWCGfx_ImageType _internal_imagetype() const;
  void _internal_set_imagetype(::ibeam_rawpanel::HWCGfx_ImageType value);
  public:

  // uint32 W = 2;
  void clear_w();
  ::PROTOBUF_NAMESPACE_ID::uint32 w() const;
  void set_w(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_w() const;
  void _internal_set_w(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 H = 3;
  void clear_h();
  ::PROTOBUF_NAMESPACE_ID::uint32 h() const;
  void set_h(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_h() const;
  void _internal_set_h(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool XYoffset = 4;
  void clear_xyoffset();
  bool xyoffset() const;
  void set_xyoffset(bool value);
  private:
  bool _internal_xyoffset() const;
  void _internal_set_xyoffset(bool value);
  public:

  // uint32 X = 5;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::uint32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 Y = 6;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::uint32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCGfx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imagedata_;
  int imagetype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 w_;
  ::PROTOBUF_NAMESPACE_ID::uint32 h_;
  bool xyoffset_;
  ::PROTOBUF_NAMESPACE_ID::uint32 x_;
  ::PROTOBUF_NAMESPACE_ID::uint32 y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class ImgConvert PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.ImgConvert) */ {
 public:
  inline ImgConvert() : ImgConvert(nullptr) {}
  virtual ~ImgConvert();

  ImgConvert(const ImgConvert& from);
  ImgConvert(ImgConvert&& from) noexcept
    : ImgConvert() {
    *this = ::std::move(from);
  }

  inline ImgConvert& operator=(const ImgConvert& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImgConvert& operator=(ImgConvert&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImgConvert& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImgConvert* internal_default_instance() {
    return reinterpret_cast<const ImgConvert*>(
               &_ImgConvert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ImgConvert& a, ImgConvert& b) {
    a.Swap(&b);
  }
  inline void Swap(ImgConvert* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImgConvert* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImgConvert* New() const final {
    return CreateMaybeMessage<ImgConvert>(nullptr);
  }

  ImgConvert* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImgConvert>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImgConvert& from);
  void MergeFrom(const ImgConvert& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImgConvert* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.ImgConvert";
  }
  protected:
  explicit ImgConvert(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ImgConvert_FileType FileType;
  static constexpr FileType PNG =
    ImgConvert_FileType_PNG;
  static constexpr FileType JPEG =
    ImgConvert_FileType_JPEG;
  static inline bool FileType_IsValid(int value) {
    return ImgConvert_FileType_IsValid(value);
  }
  static constexpr FileType FileType_MIN =
    ImgConvert_FileType_FileType_MIN;
  static constexpr FileType FileType_MAX =
    ImgConvert_FileType_FileType_MAX;
  static constexpr int FileType_ARRAYSIZE =
    ImgConvert_FileType_FileType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FileType_descriptor() {
    return ImgConvert_FileType_descriptor();
  }
  template<typename T>
  static inline const std::string& FileType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FileType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FileType_Name.");
    return ImgConvert_FileType_Name(enum_t_value);
  }
  static inline bool FileType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FileType* value) {
    return ImgConvert_FileType_Parse(name, value);
  }

  typedef ImgConvert_Scaling Scaling;
  static constexpr Scaling FILL =
    ImgConvert_Scaling_FILL;
  static constexpr Scaling FIT =
    ImgConvert_Scaling_FIT;
  static constexpr Scaling CROP =
    ImgConvert_Scaling_CROP;
  static inline bool Scaling_IsValid(int value) {
    return ImgConvert_Scaling_IsValid(value);
  }
  static constexpr Scaling Scaling_MIN =
    ImgConvert_Scaling_Scaling_MIN;
  static constexpr Scaling Scaling_MAX =
    ImgConvert_Scaling_Scaling_MAX;
  static constexpr int Scaling_ARRAYSIZE =
    ImgConvert_Scaling_Scaling_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Scaling_descriptor() {
    return ImgConvert_Scaling_descriptor();
  }
  template<typename T>
  static inline const std::string& Scaling_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Scaling>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Scaling_Name.");
    return ImgConvert_Scaling_Name(enum_t_value);
  }
  static inline bool Scaling_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Scaling* value) {
    return ImgConvert_Scaling_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFileTypeFieldNumber = 1,
    kScalingFieldNumber = 2,
    kGrayscaleFieldNumber = 3,
  };
  // .ibeam_rawpanel.ImgConvert.FileType fileType = 1;
  void clear_filetype();
  ::ibeam_rawpanel::ImgConvert_FileType filetype() const;
  void set_filetype(::ibeam_rawpanel::ImgConvert_FileType value);
  private:
  ::ibeam_rawpanel::ImgConvert_FileType _internal_filetype() const;
  void _internal_set_filetype(::ibeam_rawpanel::ImgConvert_FileType value);
  public:

  // .ibeam_rawpanel.ImgConvert.Scaling scaling = 2;
  void clear_scaling();
  ::ibeam_rawpanel::ImgConvert_Scaling scaling() const;
  void set_scaling(::ibeam_rawpanel::ImgConvert_Scaling value);
  private:
  ::ibeam_rawpanel::ImgConvert_Scaling _internal_scaling() const;
  void _internal_set_scaling(::ibeam_rawpanel::ImgConvert_Scaling value);
  public:

  // bool Grayscale = 3;
  void clear_grayscale();
  bool grayscale() const;
  void set_grayscale(bool value);
  private:
  bool _internal_grayscale() const;
  void _internal_set_grayscale(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.ImgConvert)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int filetype_;
  int scaling_;
  bool grayscale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class OutboundMessage_HWCavailabilityEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OutboundMessage_HWCavailabilityEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::ibeam_rawpanel::OutboundMessage_HWCavail,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OutboundMessage_HWCavailabilityEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::ibeam_rawpanel::OutboundMessage_HWCavail,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM,
    0 > SuperType;
  OutboundMessage_HWCavailabilityEntry_DoNotUse();
  explicit OutboundMessage_HWCavailabilityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const OutboundMessage_HWCavailabilityEntry_DoNotUse& other);
  static const OutboundMessage_HWCavailabilityEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OutboundMessage_HWCavailabilityEntry_DoNotUse*>(&_OutboundMessage_HWCavailabilityEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[18];
  }

  public:
};

// -------------------------------------------------------------------

class OutboundMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.OutboundMessage) */ {
 public:
  inline OutboundMessage() : OutboundMessage(nullptr) {}
  virtual ~OutboundMessage();

  OutboundMessage(const OutboundMessage& from);
  OutboundMessage(OutboundMessage&& from) noexcept
    : OutboundMessage() {
    *this = ::std::move(from);
  }

  inline OutboundMessage& operator=(const OutboundMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutboundMessage& operator=(OutboundMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OutboundMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OutboundMessage* internal_default_instance() {
    return reinterpret_cast<const OutboundMessage*>(
               &_OutboundMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(OutboundMessage& a, OutboundMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OutboundMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutboundMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OutboundMessage* New() const final {
    return CreateMaybeMessage<OutboundMessage>(nullptr);
  }

  OutboundMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OutboundMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OutboundMessage& from);
  void MergeFrom(const OutboundMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutboundMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.OutboundMessage";
  }
  protected:
  explicit OutboundMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  typedef OutboundMessage_FlowMsg FlowMsg;
  static constexpr FlowMsg NONE =
    OutboundMessage_FlowMsg_NONE;
  static constexpr FlowMsg PING =
    OutboundMessage_FlowMsg_PING;
  static constexpr FlowMsg ACK =
    OutboundMessage_FlowMsg_ACK;
  static constexpr FlowMsg NACK =
    OutboundMessage_FlowMsg_NACK;
  static constexpr FlowMsg HELLO =
    OutboundMessage_FlowMsg_HELLO;
  static inline bool FlowMsg_IsValid(int value) {
    return OutboundMessage_FlowMsg_IsValid(value);
  }
  static constexpr FlowMsg FlowMsg_MIN =
    OutboundMessage_FlowMsg_FlowMsg_MIN;
  static constexpr FlowMsg FlowMsg_MAX =
    OutboundMessage_FlowMsg_FlowMsg_MAX;
  static constexpr int FlowMsg_ARRAYSIZE =
    OutboundMessage_FlowMsg_FlowMsg_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FlowMsg_descriptor() {
    return OutboundMessage_FlowMsg_descriptor();
  }
  template<typename T>
  static inline const std::string& FlowMsg_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FlowMsg>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FlowMsg_Name.");
    return OutboundMessage_FlowMsg_Name(enum_t_value);
  }
  static inline bool FlowMsg_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FlowMsg* value) {
    return OutboundMessage_FlowMsg_Parse(name, value);
  }

  typedef OutboundMessage_HWCavail HWCavail;
  static constexpr HWCavail HIDDEN =
    OutboundMessage_HWCavail_HIDDEN;
  static constexpr HWCavail ON =
    OutboundMessage_HWCavail_ON;
  static constexpr HWCavail OFF =
    OutboundMessage_HWCavail_OFF;
  static inline bool HWCavail_IsValid(int value) {
    return OutboundMessage_HWCavail_IsValid(value);
  }
  static constexpr HWCavail HWCavail_MIN =
    OutboundMessage_HWCavail_HWCavail_MIN;
  static constexpr HWCavail HWCavail_MAX =
    OutboundMessage_HWCavail_HWCavail_MAX;
  static constexpr int HWCavail_ARRAYSIZE =
    OutboundMessage_HWCavail_HWCavail_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  HWCavail_descriptor() {
    return OutboundMessage_HWCavail_descriptor();
  }
  template<typename T>
  static inline const std::string& HWCavail_Name(T enum_t_value) {
    static_assert(::std::is_same<T, HWCavail>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function HWCavail_Name.");
    return OutboundMessage_HWCavail_Name(enum_t_value);
  }
  static inline bool HWCavail_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      HWCavail* value) {
    return OutboundMessage_HWCavail_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHWCavailabilityFieldNumber = 2,
    kEventsFieldNumber = 8,
    kPanelInfoFieldNumber = 4,
    kPanelTopologyFieldNumber = 5,
    kSleepTimeoutFieldNumber = 6,
    kSleepStateFieldNumber = 7,
    kFlowMessageFieldNumber = 1,
  };
  // map<uint32, .ibeam_rawpanel.OutboundMessage.HWCavail> HWCavailability = 2;
  int hwcavailability_size() const;
  private:
  int _internal_hwcavailability_size() const;
  public:
  void clear_hwcavailability();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::ibeam_rawpanel::OutboundMessage_HWCavail >&
      _internal_hwcavailability() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::ibeam_rawpanel::OutboundMessage_HWCavail >*
      _internal_mutable_hwcavailability();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::ibeam_rawpanel::OutboundMessage_HWCavail >&
      hwcavailability() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::ibeam_rawpanel::OutboundMessage_HWCavail >*
      mutable_hwcavailability();

  // repeated .ibeam_rawpanel.HWCEvent Events = 8;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::ibeam_rawpanel::HWCEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCEvent >*
      mutable_events();
  private:
  const ::ibeam_rawpanel::HWCEvent& _internal_events(int index) const;
  ::ibeam_rawpanel::HWCEvent* _internal_add_events();
  public:
  const ::ibeam_rawpanel::HWCEvent& events(int index) const;
  ::ibeam_rawpanel::HWCEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCEvent >&
      events() const;

  // .ibeam_rawpanel.PanelInfo PanelInfo = 4;
  bool has_panelinfo() const;
  private:
  bool _internal_has_panelinfo() const;
  public:
  void clear_panelinfo();
  const ::ibeam_rawpanel::PanelInfo& panelinfo() const;
  ::ibeam_rawpanel::PanelInfo* release_panelinfo();
  ::ibeam_rawpanel::PanelInfo* mutable_panelinfo();
  void set_allocated_panelinfo(::ibeam_rawpanel::PanelInfo* panelinfo);
  private:
  const ::ibeam_rawpanel::PanelInfo& _internal_panelinfo() const;
  ::ibeam_rawpanel::PanelInfo* _internal_mutable_panelinfo();
  public:
  void unsafe_arena_set_allocated_panelinfo(
      ::ibeam_rawpanel::PanelInfo* panelinfo);
  ::ibeam_rawpanel::PanelInfo* unsafe_arena_release_panelinfo();

  // .ibeam_rawpanel.PanelTopology PanelTopology = 5;
  bool has_paneltopology() const;
  private:
  bool _internal_has_paneltopology() const;
  public:
  void clear_paneltopology();
  const ::ibeam_rawpanel::PanelTopology& paneltopology() const;
  ::ibeam_rawpanel::PanelTopology* release_paneltopology();
  ::ibeam_rawpanel::PanelTopology* mutable_paneltopology();
  void set_allocated_paneltopology(::ibeam_rawpanel::PanelTopology* paneltopology);
  private:
  const ::ibeam_rawpanel::PanelTopology& _internal_paneltopology() const;
  ::ibeam_rawpanel::PanelTopology* _internal_mutable_paneltopology();
  public:
  void unsafe_arena_set_allocated_paneltopology(
      ::ibeam_rawpanel::PanelTopology* paneltopology);
  ::ibeam_rawpanel::PanelTopology* unsafe_arena_release_paneltopology();

  // .ibeam_rawpanel.SleepTimeout sleepTimeout = 6;
  bool has_sleeptimeout() const;
  private:
  bool _internal_has_sleeptimeout() const;
  public:
  void clear_sleeptimeout();
  const ::ibeam_rawpanel::SleepTimeout& sleeptimeout() const;
  ::ibeam_rawpanel::SleepTimeout* release_sleeptimeout();
  ::ibeam_rawpanel::SleepTimeout* mutable_sleeptimeout();
  void set_allocated_sleeptimeout(::ibeam_rawpanel::SleepTimeout* sleeptimeout);
  private:
  const ::ibeam_rawpanel::SleepTimeout& _internal_sleeptimeout() const;
  ::ibeam_rawpanel::SleepTimeout* _internal_mutable_sleeptimeout();
  public:
  void unsafe_arena_set_allocated_sleeptimeout(
      ::ibeam_rawpanel::SleepTimeout* sleeptimeout);
  ::ibeam_rawpanel::SleepTimeout* unsafe_arena_release_sleeptimeout();

  // .ibeam_rawpanel.SleepState sleepState = 7;
  bool has_sleepstate() const;
  private:
  bool _internal_has_sleepstate() const;
  public:
  void clear_sleepstate();
  const ::ibeam_rawpanel::SleepState& sleepstate() const;
  ::ibeam_rawpanel::SleepState* release_sleepstate();
  ::ibeam_rawpanel::SleepState* mutable_sleepstate();
  void set_allocated_sleepstate(::ibeam_rawpanel::SleepState* sleepstate);
  private:
  const ::ibeam_rawpanel::SleepState& _internal_sleepstate() const;
  ::ibeam_rawpanel::SleepState* _internal_mutable_sleepstate();
  public:
  void unsafe_arena_set_allocated_sleepstate(
      ::ibeam_rawpanel::SleepState* sleepstate);
  ::ibeam_rawpanel::SleepState* unsafe_arena_release_sleepstate();

  // .ibeam_rawpanel.OutboundMessage.FlowMsg FlowMessage = 1;
  void clear_flowmessage();
  ::ibeam_rawpanel::OutboundMessage_FlowMsg flowmessage() const;
  void set_flowmessage(::ibeam_rawpanel::OutboundMessage_FlowMsg value);
  private:
  ::ibeam_rawpanel::OutboundMessage_FlowMsg _internal_flowmessage() const;
  void _internal_set_flowmessage(::ibeam_rawpanel::OutboundMessage_FlowMsg value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.OutboundMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      OutboundMessage_HWCavailabilityEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint32, ::ibeam_rawpanel::OutboundMessage_HWCavail,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM,
      0 > hwcavailability_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCEvent > events_;
  ::ibeam_rawpanel::PanelInfo* panelinfo_;
  ::ibeam_rawpanel::PanelTopology* paneltopology_;
  ::ibeam_rawpanel::SleepTimeout* sleeptimeout_;
  ::ibeam_rawpanel::SleepState* sleepstate_;
  int flowmessage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class SleepState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.SleepState) */ {
 public:
  inline SleepState() : SleepState(nullptr) {}
  virtual ~SleepState();

  SleepState(const SleepState& from);
  SleepState(SleepState&& from) noexcept
    : SleepState() {
    *this = ::std::move(from);
  }

  inline SleepState& operator=(const SleepState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SleepState& operator=(SleepState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SleepState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SleepState* internal_default_instance() {
    return reinterpret_cast<const SleepState*>(
               &_SleepState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(SleepState& a, SleepState& b) {
    a.Swap(&b);
  }
  inline void Swap(SleepState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SleepState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SleepState* New() const final {
    return CreateMaybeMessage<SleepState>(nullptr);
  }

  SleepState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SleepState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SleepState& from);
  void MergeFrom(const SleepState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SleepState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.SleepState";
  }
  protected:
  explicit SleepState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSleepingFieldNumber = 1,
  };
  // bool IsSleeping = 1;
  void clear_issleeping();
  bool issleeping() const;
  void set_issleeping(bool value);
  private:
  bool _internal_issleeping() const;
  void _internal_set_issleeping(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.SleepState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool issleeping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCEvent) */ {
 public:
  inline HWCEvent() : HWCEvent(nullptr) {}
  virtual ~HWCEvent();

  HWCEvent(const HWCEvent& from);
  HWCEvent(HWCEvent&& from) noexcept
    : HWCEvent() {
    *this = ::std::move(from);
  }

  inline HWCEvent& operator=(const HWCEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCEvent& operator=(HWCEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HWCEvent* internal_default_instance() {
    return reinterpret_cast<const HWCEvent*>(
               &_HWCEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(HWCEvent& a, HWCEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCEvent* New() const final {
    return CreateMaybeMessage<HWCEvent>(nullptr);
  }

  HWCEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCEvent& from);
  void MergeFrom(const HWCEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCEvent";
  }
  protected:
  explicit HWCEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinaryFieldNumber = 2,
    kPulsedFieldNumber = 3,
    kAbsoluteFieldNumber = 4,
    kSpeedFieldNumber = 5,
    kHWCIDFieldNumber = 1,
    kTimestampFieldNumber = 6,
  };
  // .ibeam_rawpanel.BinaryEvent Binary = 2;
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;
  public:
  void clear_binary();
  const ::ibeam_rawpanel::BinaryEvent& binary() const;
  ::ibeam_rawpanel::BinaryEvent* release_binary();
  ::ibeam_rawpanel::BinaryEvent* mutable_binary();
  void set_allocated_binary(::ibeam_rawpanel::BinaryEvent* binary);
  private:
  const ::ibeam_rawpanel::BinaryEvent& _internal_binary() const;
  ::ibeam_rawpanel::BinaryEvent* _internal_mutable_binary();
  public:
  void unsafe_arena_set_allocated_binary(
      ::ibeam_rawpanel::BinaryEvent* binary);
  ::ibeam_rawpanel::BinaryEvent* unsafe_arena_release_binary();

  // .ibeam_rawpanel.PulsedEvent Pulsed = 3;
  bool has_pulsed() const;
  private:
  bool _internal_has_pulsed() const;
  public:
  void clear_pulsed();
  const ::ibeam_rawpanel::PulsedEvent& pulsed() const;
  ::ibeam_rawpanel::PulsedEvent* release_pulsed();
  ::ibeam_rawpanel::PulsedEvent* mutable_pulsed();
  void set_allocated_pulsed(::ibeam_rawpanel::PulsedEvent* pulsed);
  private:
  const ::ibeam_rawpanel::PulsedEvent& _internal_pulsed() const;
  ::ibeam_rawpanel::PulsedEvent* _internal_mutable_pulsed();
  public:
  void unsafe_arena_set_allocated_pulsed(
      ::ibeam_rawpanel::PulsedEvent* pulsed);
  ::ibeam_rawpanel::PulsedEvent* unsafe_arena_release_pulsed();

  // .ibeam_rawpanel.AbsoluteEvent Absolute = 4;
  bool has_absolute() const;
  private:
  bool _internal_has_absolute() const;
  public:
  void clear_absolute();
  const ::ibeam_rawpanel::AbsoluteEvent& absolute() const;
  ::ibeam_rawpanel::AbsoluteEvent* release_absolute();
  ::ibeam_rawpanel::AbsoluteEvent* mutable_absolute();
  void set_allocated_absolute(::ibeam_rawpanel::AbsoluteEvent* absolute);
  private:
  const ::ibeam_rawpanel::AbsoluteEvent& _internal_absolute() const;
  ::ibeam_rawpanel::AbsoluteEvent* _internal_mutable_absolute();
  public:
  void unsafe_arena_set_allocated_absolute(
      ::ibeam_rawpanel::AbsoluteEvent* absolute);
  ::ibeam_rawpanel::AbsoluteEvent* unsafe_arena_release_absolute();

  // .ibeam_rawpanel.SpeedEvent Speed = 5;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  const ::ibeam_rawpanel::SpeedEvent& speed() const;
  ::ibeam_rawpanel::SpeedEvent* release_speed();
  ::ibeam_rawpanel::SpeedEvent* mutable_speed();
  void set_allocated_speed(::ibeam_rawpanel::SpeedEvent* speed);
  private:
  const ::ibeam_rawpanel::SpeedEvent& _internal_speed() const;
  ::ibeam_rawpanel::SpeedEvent* _internal_mutable_speed();
  public:
  void unsafe_arena_set_allocated_speed(
      ::ibeam_rawpanel::SpeedEvent* speed);
  ::ibeam_rawpanel::SpeedEvent* unsafe_arena_release_speed();

  // uint32 HWCID = 1;
  void clear_hwcid();
  ::PROTOBUF_NAMESPACE_ID::uint32 hwcid() const;
  void set_hwcid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hwcid() const;
  void _internal_set_hwcid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 Timestamp = 6;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ibeam_rawpanel::BinaryEvent* binary_;
  ::ibeam_rawpanel::PulsedEvent* pulsed_;
  ::ibeam_rawpanel::AbsoluteEvent* absolute_;
  ::ibeam_rawpanel::SpeedEvent* speed_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hwcid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class BinaryEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.BinaryEvent) */ {
 public:
  inline BinaryEvent() : BinaryEvent(nullptr) {}
  virtual ~BinaryEvent();

  BinaryEvent(const BinaryEvent& from);
  BinaryEvent(BinaryEvent&& from) noexcept
    : BinaryEvent() {
    *this = ::std::move(from);
  }

  inline BinaryEvent& operator=(const BinaryEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryEvent& operator=(BinaryEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BinaryEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryEvent* internal_default_instance() {
    return reinterpret_cast<const BinaryEvent*>(
               &_BinaryEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(BinaryEvent& a, BinaryEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinaryEvent* New() const final {
    return CreateMaybeMessage<BinaryEvent>(nullptr);
  }

  BinaryEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinaryEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BinaryEvent& from);
  void MergeFrom(const BinaryEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.BinaryEvent";
  }
  protected:
  explicit BinaryEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BinaryEvent_EdgeID EdgeID;
  static constexpr EdgeID UNKNOWN =
    BinaryEvent_EdgeID_UNKNOWN;
  static constexpr EdgeID TOP =
    BinaryEvent_EdgeID_TOP;
  static constexpr EdgeID LEFT =
    BinaryEvent_EdgeID_LEFT;
  static constexpr EdgeID BOTTOM =
    BinaryEvent_EdgeID_BOTTOM;
  static constexpr EdgeID RIGHT =
    BinaryEvent_EdgeID_RIGHT;
  static inline bool EdgeID_IsValid(int value) {
    return BinaryEvent_EdgeID_IsValid(value);
  }
  static constexpr EdgeID EdgeID_MIN =
    BinaryEvent_EdgeID_EdgeID_MIN;
  static constexpr EdgeID EdgeID_MAX =
    BinaryEvent_EdgeID_EdgeID_MAX;
  static constexpr int EdgeID_ARRAYSIZE =
    BinaryEvent_EdgeID_EdgeID_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EdgeID_descriptor() {
    return BinaryEvent_EdgeID_descriptor();
  }
  template<typename T>
  static inline const std::string& EdgeID_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EdgeID>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EdgeID_Name.");
    return BinaryEvent_EdgeID_Name(enum_t_value);
  }
  static inline bool EdgeID_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EdgeID* value) {
    return BinaryEvent_EdgeID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPressedFieldNumber = 1,
    kEdgeFieldNumber = 2,
  };
  // bool Pressed = 1;
  void clear_pressed();
  bool pressed() const;
  void set_pressed(bool value);
  private:
  bool _internal_pressed() const;
  void _internal_set_pressed(bool value);
  public:

  // .ibeam_rawpanel.BinaryEvent.EdgeID Edge = 2;
  void clear_edge();
  ::ibeam_rawpanel::BinaryEvent_EdgeID edge() const;
  void set_edge(::ibeam_rawpanel::BinaryEvent_EdgeID value);
  private:
  ::ibeam_rawpanel::BinaryEvent_EdgeID _internal_edge() const;
  void _internal_set_edge(::ibeam_rawpanel::BinaryEvent_EdgeID value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.BinaryEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool pressed_;
  int edge_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class PulsedEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.PulsedEvent) */ {
 public:
  inline PulsedEvent() : PulsedEvent(nullptr) {}
  virtual ~PulsedEvent();

  PulsedEvent(const PulsedEvent& from);
  PulsedEvent(PulsedEvent&& from) noexcept
    : PulsedEvent() {
    *this = ::std::move(from);
  }

  inline PulsedEvent& operator=(const PulsedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PulsedEvent& operator=(PulsedEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PulsedEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PulsedEvent* internal_default_instance() {
    return reinterpret_cast<const PulsedEvent*>(
               &_PulsedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(PulsedEvent& a, PulsedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(PulsedEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PulsedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PulsedEvent* New() const final {
    return CreateMaybeMessage<PulsedEvent>(nullptr);
  }

  PulsedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PulsedEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PulsedEvent& from);
  void MergeFrom(const PulsedEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PulsedEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.PulsedEvent";
  }
  protected:
  explicit PulsedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // sint32 Value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.PulsedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class AbsoluteEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.AbsoluteEvent) */ {
 public:
  inline AbsoluteEvent() : AbsoluteEvent(nullptr) {}
  virtual ~AbsoluteEvent();

  AbsoluteEvent(const AbsoluteEvent& from);
  AbsoluteEvent(AbsoluteEvent&& from) noexcept
    : AbsoluteEvent() {
    *this = ::std::move(from);
  }

  inline AbsoluteEvent& operator=(const AbsoluteEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbsoluteEvent& operator=(AbsoluteEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AbsoluteEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AbsoluteEvent* internal_default_instance() {
    return reinterpret_cast<const AbsoluteEvent*>(
               &_AbsoluteEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(AbsoluteEvent& a, AbsoluteEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AbsoluteEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbsoluteEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AbsoluteEvent* New() const final {
    return CreateMaybeMessage<AbsoluteEvent>(nullptr);
  }

  AbsoluteEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AbsoluteEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AbsoluteEvent& from);
  void MergeFrom(const AbsoluteEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbsoluteEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.AbsoluteEvent";
  }
  protected:
  explicit AbsoluteEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 Value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.AbsoluteEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class SpeedEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.SpeedEvent) */ {
 public:
  inline SpeedEvent() : SpeedEvent(nullptr) {}
  virtual ~SpeedEvent();

  SpeedEvent(const SpeedEvent& from);
  SpeedEvent(SpeedEvent&& from) noexcept
    : SpeedEvent() {
    *this = ::std::move(from);
  }

  inline SpeedEvent& operator=(const SpeedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedEvent& operator=(SpeedEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpeedEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedEvent* internal_default_instance() {
    return reinterpret_cast<const SpeedEvent*>(
               &_SpeedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SpeedEvent& a, SpeedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeedEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpeedEvent* New() const final {
    return CreateMaybeMessage<SpeedEvent>(nullptr);
  }

  SpeedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeedEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpeedEvent& from);
  void MergeFrom(const SpeedEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.SpeedEvent";
  }
  protected:
  explicit SpeedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // sint32 Value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.SpeedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class PanelInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.PanelInfo) */ {
 public:
  inline PanelInfo() : PanelInfo(nullptr) {}
  virtual ~PanelInfo();

  PanelInfo(const PanelInfo& from);
  PanelInfo(PanelInfo&& from) noexcept
    : PanelInfo() {
    *this = ::std::move(from);
  }

  inline PanelInfo& operator=(const PanelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PanelInfo& operator=(PanelInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PanelInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PanelInfo* internal_default_instance() {
    return reinterpret_cast<const PanelInfo*>(
               &_PanelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(PanelInfo& a, PanelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PanelInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PanelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PanelInfo* New() const final {
    return CreateMaybeMessage<PanelInfo>(nullptr);
  }

  PanelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PanelInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PanelInfo& from);
  void MergeFrom(const PanelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PanelInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.PanelInfo";
  }
  protected:
  explicit PanelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 1,
    kSerialFieldNumber = 2,
    kSoftwareVersionFieldNumber = 4,
  };
  // string Model = 1;
  void clear_model();
  const std::string& model() const;
  void set_model(const std::string& value);
  void set_model(std::string&& value);
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  std::string* mutable_model();
  std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string Serial = 2;
  void clear_serial();
  const std::string& serial() const;
  void set_serial(const std::string& value);
  void set_serial(std::string&& value);
  void set_serial(const char* value);
  void set_serial(const char* value, size_t size);
  std::string* mutable_serial();
  std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // string SoftwareVersion = 4;
  void clear_softwareversion();
  const std::string& softwareversion() const;
  void set_softwareversion(const std::string& value);
  void set_softwareversion(std::string&& value);
  void set_softwareversion(const char* value);
  void set_softwareversion(const char* value, size_t size);
  std::string* mutable_softwareversion();
  std::string* release_softwareversion();
  void set_allocated_softwareversion(std::string* softwareversion);
  private:
  const std::string& _internal_softwareversion() const;
  void _internal_set_softwareversion(const std::string& value);
  std::string* _internal_mutable_softwareversion();
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.PanelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr softwareversion_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class PanelTopology PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.PanelTopology) */ {
 public:
  inline PanelTopology() : PanelTopology(nullptr) {}
  virtual ~PanelTopology();

  PanelTopology(const PanelTopology& from);
  PanelTopology(PanelTopology&& from) noexcept
    : PanelTopology() {
    *this = ::std::move(from);
  }

  inline PanelTopology& operator=(const PanelTopology& from) {
    CopyFrom(from);
    return *this;
  }
  inline PanelTopology& operator=(PanelTopology&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PanelTopology& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PanelTopology* internal_default_instance() {
    return reinterpret_cast<const PanelTopology*>(
               &_PanelTopology_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(PanelTopology& a, PanelTopology& b) {
    a.Swap(&b);
  }
  inline void Swap(PanelTopology* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PanelTopology* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PanelTopology* New() const final {
    return CreateMaybeMessage<PanelTopology>(nullptr);
  }

  PanelTopology* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PanelTopology>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PanelTopology& from);
  void MergeFrom(const PanelTopology& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PanelTopology* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.PanelTopology";
  }
  protected:
  explicit PanelTopology(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSvgbaseFieldNumber = 1,
    kJsonFieldNumber = 2,
  };
  // string Svgbase = 1;
  void clear_svgbase();
  const std::string& svgbase() const;
  void set_svgbase(const std::string& value);
  void set_svgbase(std::string&& value);
  void set_svgbase(const char* value);
  void set_svgbase(const char* value, size_t size);
  std::string* mutable_svgbase();
  std::string* release_svgbase();
  void set_allocated_svgbase(std::string* svgbase);
  private:
  const std::string& _internal_svgbase() const;
  void _internal_set_svgbase(const std::string& value);
  std::string* _internal_mutable_svgbase();
  public:

  // string Json = 2;
  void clear_json();
  const std::string& json() const;
  void set_json(const std::string& value);
  void set_json(std::string&& value);
  void set_json(const char* value);
  void set_json(const char* value, size_t size);
  std::string* mutable_json();
  std::string* release_json();
  void set_allocated_json(std::string* json);
  private:
  const std::string& _internal_json() const;
  void _internal_set_json(const std::string& value);
  std::string* _internal_mutable_json();
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.PanelTopology)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr svgbase_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InboundMessage

// .ibeam_rawpanel.InboundMessage.FlowMsg flowMessage = 1;
inline void InboundMessage::clear_flowmessage() {
  flowmessage_ = 0;
}
inline ::ibeam_rawpanel::InboundMessage_FlowMsg InboundMessage::_internal_flowmessage() const {
  return static_cast< ::ibeam_rawpanel::InboundMessage_FlowMsg >(flowmessage_);
}
inline ::ibeam_rawpanel::InboundMessage_FlowMsg InboundMessage::flowmessage() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.InboundMessage.flowMessage)
  return _internal_flowmessage();
}
inline void InboundMessage::_internal_set_flowmessage(::ibeam_rawpanel::InboundMessage_FlowMsg value) {
  
  flowmessage_ = value;
}
inline void InboundMessage::set_flowmessage(::ibeam_rawpanel::InboundMessage_FlowMsg value) {
  _internal_set_flowmessage(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.InboundMessage.flowMessage)
}

// .ibeam_rawpanel.Command Command = 2;
inline bool InboundMessage::_internal_has_command() const {
  return this != internal_default_instance() && command_ != nullptr;
}
inline bool InboundMessage::has_command() const {
  return _internal_has_command();
}
inline void InboundMessage::clear_command() {
  if (GetArena() == nullptr && command_ != nullptr) {
    delete command_;
  }
  command_ = nullptr;
}
inline const ::ibeam_rawpanel::Command& InboundMessage::_internal_command() const {
  const ::ibeam_rawpanel::Command* p = command_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::Command*>(
      &::ibeam_rawpanel::_Command_default_instance_);
}
inline const ::ibeam_rawpanel::Command& InboundMessage::command() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.InboundMessage.Command)
  return _internal_command();
}
inline void InboundMessage::unsafe_arena_set_allocated_command(
    ::ibeam_rawpanel::Command* command) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_);
  }
  command_ = command;
  if (command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.InboundMessage.Command)
}
inline ::ibeam_rawpanel::Command* InboundMessage::release_command() {
  
  ::ibeam_rawpanel::Command* temp = command_;
  command_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::Command* InboundMessage::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.InboundMessage.Command)
  
  ::ibeam_rawpanel::Command* temp = command_;
  command_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::Command* InboundMessage::_internal_mutable_command() {
  
  if (command_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::Command>(GetArena());
    command_ = p;
  }
  return command_;
}
inline ::ibeam_rawpanel::Command* InboundMessage::mutable_command() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.InboundMessage.Command)
  return _internal_mutable_command();
}
inline void InboundMessage::set_allocated_command(::ibeam_rawpanel::Command* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete command_;
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(command);
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    
  } else {
    
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.InboundMessage.Command)
}

// repeated .ibeam_rawpanel.HWCState States = 8;
inline int InboundMessage::_internal_states_size() const {
  return states_.size();
}
inline int InboundMessage::states_size() const {
  return _internal_states_size();
}
inline void InboundMessage::clear_states() {
  states_.Clear();
}
inline ::ibeam_rawpanel::HWCState* InboundMessage::mutable_states(int index) {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.InboundMessage.States)
  return states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCState >*
InboundMessage::mutable_states() {
  // @@protoc_insertion_point(field_mutable_list:ibeam_rawpanel.InboundMessage.States)
  return &states_;
}
inline const ::ibeam_rawpanel::HWCState& InboundMessage::_internal_states(int index) const {
  return states_.Get(index);
}
inline const ::ibeam_rawpanel::HWCState& InboundMessage::states(int index) const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.InboundMessage.States)
  return _internal_states(index);
}
inline ::ibeam_rawpanel::HWCState* InboundMessage::_internal_add_states() {
  return states_.Add();
}
inline ::ibeam_rawpanel::HWCState* InboundMessage::add_states() {
  // @@protoc_insertion_point(field_add:ibeam_rawpanel.InboundMessage.States)
  return _internal_add_states();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCState >&
InboundMessage::states() const {
  // @@protoc_insertion_point(field_list:ibeam_rawpanel.InboundMessage.States)
  return states_;
}

// -------------------------------------------------------------------

// Command

// bool ActivatePanel = 1;
inline void Command::clear_activatepanel() {
  activatepanel_ = false;
}
inline bool Command::_internal_activatepanel() const {
  return activatepanel_;
}
inline bool Command::activatepanel() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.ActivatePanel)
  return _internal_activatepanel();
}
inline void Command::_internal_set_activatepanel(bool value) {
  
  activatepanel_ = value;
}
inline void Command::set_activatepanel(bool value) {
  _internal_set_activatepanel(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.ActivatePanel)
}

// bool SendPanelInfo = 2;
inline void Command::clear_sendpanelinfo() {
  sendpanelinfo_ = false;
}
inline bool Command::_internal_sendpanelinfo() const {
  return sendpanelinfo_;
}
inline bool Command::sendpanelinfo() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.SendPanelInfo)
  return _internal_sendpanelinfo();
}
inline void Command::_internal_set_sendpanelinfo(bool value) {
  
  sendpanelinfo_ = value;
}
inline void Command::set_sendpanelinfo(bool value) {
  _internal_set_sendpanelinfo(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.SendPanelInfo)
}

// bool SendPanelTopology = 3;
inline void Command::clear_sendpaneltopology() {
  sendpaneltopology_ = false;
}
inline bool Command::_internal_sendpaneltopology() const {
  return sendpaneltopology_;
}
inline bool Command::sendpaneltopology() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.SendPanelTopology)
  return _internal_sendpaneltopology();
}
inline void Command::_internal_set_sendpaneltopology(bool value) {
  
  sendpaneltopology_ = value;
}
inline void Command::set_sendpaneltopology(bool value) {
  _internal_set_sendpaneltopology(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.SendPanelTopology)
}

// bool ReportHWCavailability = 4;
inline void Command::clear_reporthwcavailability() {
  reporthwcavailability_ = false;
}
inline bool Command::_internal_reporthwcavailability() const {
  return reporthwcavailability_;
}
inline bool Command::reporthwcavailability() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.ReportHWCavailability)
  return _internal_reporthwcavailability();
}
inline void Command::_internal_set_reporthwcavailability(bool value) {
  
  reporthwcavailability_ = value;
}
inline void Command::set_reporthwcavailability(bool value) {
  _internal_set_reporthwcavailability(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.ReportHWCavailability)
}

// bool ClearAll = 10;
inline void Command::clear_clearall() {
  clearall_ = false;
}
inline bool Command::_internal_clearall() const {
  return clearall_;
}
inline bool Command::clearall() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.ClearAll)
  return _internal_clearall();
}
inline void Command::_internal_set_clearall(bool value) {
  
  clearall_ = value;
}
inline void Command::set_clearall(bool value) {
  _internal_set_clearall(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.ClearAll)
}

// bool ClearLEDs = 11;
inline void Command::clear_clearleds() {
  clearleds_ = false;
}
inline bool Command::_internal_clearleds() const {
  return clearleds_;
}
inline bool Command::clearleds() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.ClearLEDs)
  return _internal_clearleds();
}
inline void Command::_internal_set_clearleds(bool value) {
  
  clearleds_ = value;
}
inline void Command::set_clearleds(bool value) {
  _internal_set_clearleds(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.ClearLEDs)
}

// bool ClearDisplays = 12;
inline void Command::clear_cleardisplays() {
  cleardisplays_ = false;
}
inline bool Command::_internal_cleardisplays() const {
  return cleardisplays_;
}
inline bool Command::cleardisplays() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.ClearDisplays)
  return _internal_cleardisplays();
}
inline void Command::_internal_set_cleardisplays(bool value) {
  
  cleardisplays_ = value;
}
inline void Command::set_cleardisplays(bool value) {
  _internal_set_cleardisplays(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.ClearDisplays)
}

// bool WakeUp = 5;
inline void Command::clear_wakeup() {
  wakeup_ = false;
}
inline bool Command::_internal_wakeup() const {
  return wakeup_;
}
inline bool Command::wakeup() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.WakeUp)
  return _internal_wakeup();
}
inline void Command::_internal_set_wakeup(bool value) {
  
  wakeup_ = value;
}
inline void Command::set_wakeup(bool value) {
  _internal_set_wakeup(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.WakeUp)
}

// bool GetSleepTimeout = 20;
inline void Command::clear_getsleeptimeout() {
  getsleeptimeout_ = false;
}
inline bool Command::_internal_getsleeptimeout() const {
  return getsleeptimeout_;
}
inline bool Command::getsleeptimeout() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.GetSleepTimeout)
  return _internal_getsleeptimeout();
}
inline void Command::_internal_set_getsleeptimeout(bool value) {
  
  getsleeptimeout_ = value;
}
inline void Command::set_getsleeptimeout(bool value) {
  _internal_set_getsleeptimeout(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.GetSleepTimeout)
}

// .ibeam_rawpanel.SleepTimeout SetSleepTimeout = 21;
inline bool Command::_internal_has_setsleeptimeout() const {
  return this != internal_default_instance() && setsleeptimeout_ != nullptr;
}
inline bool Command::has_setsleeptimeout() const {
  return _internal_has_setsleeptimeout();
}
inline void Command::clear_setsleeptimeout() {
  if (GetArena() == nullptr && setsleeptimeout_ != nullptr) {
    delete setsleeptimeout_;
  }
  setsleeptimeout_ = nullptr;
}
inline const ::ibeam_rawpanel::SleepTimeout& Command::_internal_setsleeptimeout() const {
  const ::ibeam_rawpanel::SleepTimeout* p = setsleeptimeout_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::SleepTimeout*>(
      &::ibeam_rawpanel::_SleepTimeout_default_instance_);
}
inline const ::ibeam_rawpanel::SleepTimeout& Command::setsleeptimeout() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.SetSleepTimeout)
  return _internal_setsleeptimeout();
}
inline void Command::unsafe_arena_set_allocated_setsleeptimeout(
    ::ibeam_rawpanel::SleepTimeout* setsleeptimeout) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setsleeptimeout_);
  }
  setsleeptimeout_ = setsleeptimeout;
  if (setsleeptimeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.Command.SetSleepTimeout)
}
inline ::ibeam_rawpanel::SleepTimeout* Command::release_setsleeptimeout() {
  
  ::ibeam_rawpanel::SleepTimeout* temp = setsleeptimeout_;
  setsleeptimeout_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::SleepTimeout* Command::unsafe_arena_release_setsleeptimeout() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.Command.SetSleepTimeout)
  
  ::ibeam_rawpanel::SleepTimeout* temp = setsleeptimeout_;
  setsleeptimeout_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::SleepTimeout* Command::_internal_mutable_setsleeptimeout() {
  
  if (setsleeptimeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::SleepTimeout>(GetArena());
    setsleeptimeout_ = p;
  }
  return setsleeptimeout_;
}
inline ::ibeam_rawpanel::SleepTimeout* Command::mutable_setsleeptimeout() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.Command.SetSleepTimeout)
  return _internal_mutable_setsleeptimeout();
}
inline void Command::set_allocated_setsleeptimeout(::ibeam_rawpanel::SleepTimeout* setsleeptimeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete setsleeptimeout_;
  }
  if (setsleeptimeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(setsleeptimeout);
    if (message_arena != submessage_arena) {
      setsleeptimeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setsleeptimeout, submessage_arena);
    }
    
  } else {
    
  }
  setsleeptimeout_ = setsleeptimeout;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.Command.SetSleepTimeout)
}

// .ibeam_rawpanel.WebserverState SetWebserverEnabled = 22;
inline bool Command::_internal_has_setwebserverenabled() const {
  return this != internal_default_instance() && setwebserverenabled_ != nullptr;
}
inline bool Command::has_setwebserverenabled() const {
  return _internal_has_setwebserverenabled();
}
inline void Command::clear_setwebserverenabled() {
  if (GetArena() == nullptr && setwebserverenabled_ != nullptr) {
    delete setwebserverenabled_;
  }
  setwebserverenabled_ = nullptr;
}
inline const ::ibeam_rawpanel::WebserverState& Command::_internal_setwebserverenabled() const {
  const ::ibeam_rawpanel::WebserverState* p = setwebserverenabled_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::WebserverState*>(
      &::ibeam_rawpanel::_WebserverState_default_instance_);
}
inline const ::ibeam_rawpanel::WebserverState& Command::setwebserverenabled() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.SetWebserverEnabled)
  return _internal_setwebserverenabled();
}
inline void Command::unsafe_arena_set_allocated_setwebserverenabled(
    ::ibeam_rawpanel::WebserverState* setwebserverenabled) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setwebserverenabled_);
  }
  setwebserverenabled_ = setwebserverenabled;
  if (setwebserverenabled) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.Command.SetWebserverEnabled)
}
inline ::ibeam_rawpanel::WebserverState* Command::release_setwebserverenabled() {
  
  ::ibeam_rawpanel::WebserverState* temp = setwebserverenabled_;
  setwebserverenabled_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::WebserverState* Command::unsafe_arena_release_setwebserverenabled() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.Command.SetWebserverEnabled)
  
  ::ibeam_rawpanel::WebserverState* temp = setwebserverenabled_;
  setwebserverenabled_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::WebserverState* Command::_internal_mutable_setwebserverenabled() {
  
  if (setwebserverenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::WebserverState>(GetArena());
    setwebserverenabled_ = p;
  }
  return setwebserverenabled_;
}
inline ::ibeam_rawpanel::WebserverState* Command::mutable_setwebserverenabled() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.Command.SetWebserverEnabled)
  return _internal_mutable_setwebserverenabled();
}
inline void Command::set_allocated_setwebserverenabled(::ibeam_rawpanel::WebserverState* setwebserverenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete setwebserverenabled_;
  }
  if (setwebserverenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(setwebserverenabled);
    if (message_arena != submessage_arena) {
      setwebserverenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setwebserverenabled, submessage_arena);
    }
    
  } else {
    
  }
  setwebserverenabled_ = setwebserverenabled;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.Command.SetWebserverEnabled)
}

// .ibeam_rawpanel.Brightness PanelBrightness = 23;
inline bool Command::_internal_has_panelbrightness() const {
  return this != internal_default_instance() && panelbrightness_ != nullptr;
}
inline bool Command::has_panelbrightness() const {
  return _internal_has_panelbrightness();
}
inline void Command::clear_panelbrightness() {
  if (GetArena() == nullptr && panelbrightness_ != nullptr) {
    delete panelbrightness_;
  }
  panelbrightness_ = nullptr;
}
inline const ::ibeam_rawpanel::Brightness& Command::_internal_panelbrightness() const {
  const ::ibeam_rawpanel::Brightness* p = panelbrightness_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::Brightness*>(
      &::ibeam_rawpanel::_Brightness_default_instance_);
}
inline const ::ibeam_rawpanel::Brightness& Command::panelbrightness() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.PanelBrightness)
  return _internal_panelbrightness();
}
inline void Command::unsafe_arena_set_allocated_panelbrightness(
    ::ibeam_rawpanel::Brightness* panelbrightness) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(panelbrightness_);
  }
  panelbrightness_ = panelbrightness;
  if (panelbrightness) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.Command.PanelBrightness)
}
inline ::ibeam_rawpanel::Brightness* Command::release_panelbrightness() {
  
  ::ibeam_rawpanel::Brightness* temp = panelbrightness_;
  panelbrightness_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::Brightness* Command::unsafe_arena_release_panelbrightness() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.Command.PanelBrightness)
  
  ::ibeam_rawpanel::Brightness* temp = panelbrightness_;
  panelbrightness_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::Brightness* Command::_internal_mutable_panelbrightness() {
  
  if (panelbrightness_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::Brightness>(GetArena());
    panelbrightness_ = p;
  }
  return panelbrightness_;
}
inline ::ibeam_rawpanel::Brightness* Command::mutable_panelbrightness() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.Command.PanelBrightness)
  return _internal_mutable_panelbrightness();
}
inline void Command::set_allocated_panelbrightness(::ibeam_rawpanel::Brightness* panelbrightness) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete panelbrightness_;
  }
  if (panelbrightness) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(panelbrightness);
    if (message_arena != submessage_arena) {
      panelbrightness = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, panelbrightness, submessage_arena);
    }
    
  } else {
    
  }
  panelbrightness_ = panelbrightness;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.Command.PanelBrightness)
}

// -------------------------------------------------------------------

// SleepTimeout

// uint32 Value = 1;
inline void SleepTimeout::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SleepTimeout::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SleepTimeout::value() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.SleepTimeout.Value)
  return _internal_value();
}
inline void SleepTimeout::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void SleepTimeout::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.SleepTimeout.Value)
}

// -------------------------------------------------------------------

// WebserverState

// bool Enabled = 1;
inline void WebserverState::clear_enabled() {
  enabled_ = false;
}
inline bool WebserverState::_internal_enabled() const {
  return enabled_;
}
inline bool WebserverState::enabled() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.WebserverState.Enabled)
  return _internal_enabled();
}
inline void WebserverState::_internal_set_enabled(bool value) {
  
  enabled_ = value;
}
inline void WebserverState::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.WebserverState.Enabled)
}

// -------------------------------------------------------------------

// Brightness

// uint32 OLEDs = 1;
inline void Brightness::clear_oleds() {
  oleds_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Brightness::_internal_oleds() const {
  return oleds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Brightness::oleds() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Brightness.OLEDs)
  return _internal_oleds();
}
inline void Brightness::_internal_set_oleds(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  oleds_ = value;
}
inline void Brightness::set_oleds(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_oleds(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Brightness.OLEDs)
}

// uint32 LEDs = 2;
inline void Brightness::clear_leds() {
  leds_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Brightness::_internal_leds() const {
  return leds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Brightness::leds() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Brightness.LEDs)
  return _internal_leds();
}
inline void Brightness::_internal_set_leds(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  leds_ = value;
}
inline void Brightness::set_leds(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_leds(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Brightness.LEDs)
}

// -------------------------------------------------------------------

// HWCState

// repeated uint32 HWCIDs = 1;
inline int HWCState::_internal_hwcids_size() const {
  return hwcids_.size();
}
inline int HWCState::hwcids_size() const {
  return _internal_hwcids_size();
}
inline void HWCState::clear_hwcids() {
  hwcids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCState::_internal_hwcids(int index) const {
  return hwcids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCState::hwcids(int index) const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.HWCIDs)
  return _internal_hwcids(index);
}
inline void HWCState::set_hwcids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  hwcids_.Set(index, value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCState.HWCIDs)
}
inline void HWCState::_internal_add_hwcids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  hwcids_.Add(value);
}
inline void HWCState::add_hwcids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_hwcids(value);
  // @@protoc_insertion_point(field_add:ibeam_rawpanel.HWCState.HWCIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
HWCState::_internal_hwcids() const {
  return hwcids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
HWCState::hwcids() const {
  // @@protoc_insertion_point(field_list:ibeam_rawpanel.HWCState.HWCIDs)
  return _internal_hwcids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
HWCState::_internal_mutable_hwcids() {
  return &hwcids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
HWCState::mutable_hwcids() {
  // @@protoc_insertion_point(field_mutable_list:ibeam_rawpanel.HWCState.HWCIDs)
  return _internal_mutable_hwcids();
}

// .ibeam_rawpanel.HWCMode HWCMode = 2;
inline bool HWCState::_internal_has_hwcmode() const {
  return this != internal_default_instance() && hwcmode_ != nullptr;
}
inline bool HWCState::has_hwcmode() const {
  return _internal_has_hwcmode();
}
inline void HWCState::clear_hwcmode() {
  if (GetArena() == nullptr && hwcmode_ != nullptr) {
    delete hwcmode_;
  }
  hwcmode_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCMode& HWCState::_internal_hwcmode() const {
  const ::ibeam_rawpanel::HWCMode* p = hwcmode_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::HWCMode*>(
      &::ibeam_rawpanel::_HWCMode_default_instance_);
}
inline const ::ibeam_rawpanel::HWCMode& HWCState::hwcmode() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.HWCMode)
  return _internal_hwcmode();
}
inline void HWCState::unsafe_arena_set_allocated_hwcmode(
    ::ibeam_rawpanel::HWCMode* hwcmode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hwcmode_);
  }
  hwcmode_ = hwcmode;
  if (hwcmode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCState.HWCMode)
}
inline ::ibeam_rawpanel::HWCMode* HWCState::release_hwcmode() {
  
  ::ibeam_rawpanel::HWCMode* temp = hwcmode_;
  hwcmode_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCMode* HWCState::unsafe_arena_release_hwcmode() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCState.HWCMode)
  
  ::ibeam_rawpanel::HWCMode* temp = hwcmode_;
  hwcmode_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCMode* HWCState::_internal_mutable_hwcmode() {
  
  if (hwcmode_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCMode>(GetArena());
    hwcmode_ = p;
  }
  return hwcmode_;
}
inline ::ibeam_rawpanel::HWCMode* HWCState::mutable_hwcmode() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCState.HWCMode)
  return _internal_mutable_hwcmode();
}
inline void HWCState::set_allocated_hwcmode(::ibeam_rawpanel::HWCMode* hwcmode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hwcmode_;
  }
  if (hwcmode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hwcmode);
    if (message_arena != submessage_arena) {
      hwcmode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hwcmode, submessage_arena);
    }
    
  } else {
    
  }
  hwcmode_ = hwcmode;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCState.HWCMode)
}

// .ibeam_rawpanel.HWCColor HWCColor = 3;
inline bool HWCState::_internal_has_hwccolor() const {
  return this != internal_default_instance() && hwccolor_ != nullptr;
}
inline bool HWCState::has_hwccolor() const {
  return _internal_has_hwccolor();
}
inline void HWCState::clear_hwccolor() {
  if (GetArena() == nullptr && hwccolor_ != nullptr) {
    delete hwccolor_;
  }
  hwccolor_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCColor& HWCState::_internal_hwccolor() const {
  const ::ibeam_rawpanel::HWCColor* p = hwccolor_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::HWCColor*>(
      &::ibeam_rawpanel::_HWCColor_default_instance_);
}
inline const ::ibeam_rawpanel::HWCColor& HWCState::hwccolor() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.HWCColor)
  return _internal_hwccolor();
}
inline void HWCState::unsafe_arena_set_allocated_hwccolor(
    ::ibeam_rawpanel::HWCColor* hwccolor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hwccolor_);
  }
  hwccolor_ = hwccolor;
  if (hwccolor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCState.HWCColor)
}
inline ::ibeam_rawpanel::HWCColor* HWCState::release_hwccolor() {
  
  ::ibeam_rawpanel::HWCColor* temp = hwccolor_;
  hwccolor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCColor* HWCState::unsafe_arena_release_hwccolor() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCState.HWCColor)
  
  ::ibeam_rawpanel::HWCColor* temp = hwccolor_;
  hwccolor_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCColor* HWCState::_internal_mutable_hwccolor() {
  
  if (hwccolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCColor>(GetArena());
    hwccolor_ = p;
  }
  return hwccolor_;
}
inline ::ibeam_rawpanel::HWCColor* HWCState::mutable_hwccolor() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCState.HWCColor)
  return _internal_mutable_hwccolor();
}
inline void HWCState::set_allocated_hwccolor(::ibeam_rawpanel::HWCColor* hwccolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hwccolor_;
  }
  if (hwccolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hwccolor);
    if (message_arena != submessage_arena) {
      hwccolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hwccolor, submessage_arena);
    }
    
  } else {
    
  }
  hwccolor_ = hwccolor;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCState.HWCColor)
}

// .ibeam_rawpanel.HWCExtended HWCExtended = 4;
inline bool HWCState::_internal_has_hwcextended() const {
  return this != internal_default_instance() && hwcextended_ != nullptr;
}
inline bool HWCState::has_hwcextended() const {
  return _internal_has_hwcextended();
}
inline void HWCState::clear_hwcextended() {
  if (GetArena() == nullptr && hwcextended_ != nullptr) {
    delete hwcextended_;
  }
  hwcextended_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCExtended& HWCState::_internal_hwcextended() const {
  const ::ibeam_rawpanel::HWCExtended* p = hwcextended_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::HWCExtended*>(
      &::ibeam_rawpanel::_HWCExtended_default_instance_);
}
inline const ::ibeam_rawpanel::HWCExtended& HWCState::hwcextended() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.HWCExtended)
  return _internal_hwcextended();
}
inline void HWCState::unsafe_arena_set_allocated_hwcextended(
    ::ibeam_rawpanel::HWCExtended* hwcextended) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hwcextended_);
  }
  hwcextended_ = hwcextended;
  if (hwcextended) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCState.HWCExtended)
}
inline ::ibeam_rawpanel::HWCExtended* HWCState::release_hwcextended() {
  
  ::ibeam_rawpanel::HWCExtended* temp = hwcextended_;
  hwcextended_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCExtended* HWCState::unsafe_arena_release_hwcextended() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCState.HWCExtended)
  
  ::ibeam_rawpanel::HWCExtended* temp = hwcextended_;
  hwcextended_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCExtended* HWCState::_internal_mutable_hwcextended() {
  
  if (hwcextended_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCExtended>(GetArena());
    hwcextended_ = p;
  }
  return hwcextended_;
}
inline ::ibeam_rawpanel::HWCExtended* HWCState::mutable_hwcextended() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCState.HWCExtended)
  return _internal_mutable_hwcextended();
}
inline void HWCState::set_allocated_hwcextended(::ibeam_rawpanel::HWCExtended* hwcextended) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hwcextended_;
  }
  if (hwcextended) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hwcextended);
    if (message_arena != submessage_arena) {
      hwcextended = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hwcextended, submessage_arena);
    }
    
  } else {
    
  }
  hwcextended_ = hwcextended;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCState.HWCExtended)
}

// .ibeam_rawpanel.HWCText HWCText = 5;
inline bool HWCState::_internal_has_hwctext() const {
  return this != internal_default_instance() && hwctext_ != nullptr;
}
inline bool HWCState::has_hwctext() const {
  return _internal_has_hwctext();
}
inline void HWCState::clear_hwctext() {
  if (GetArena() == nullptr && hwctext_ != nullptr) {
    delete hwctext_;
  }
  hwctext_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCText& HWCState::_internal_hwctext() const {
  const ::ibeam_rawpanel::HWCText* p = hwctext_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::HWCText*>(
      &::ibeam_rawpanel::_HWCText_default_instance_);
}
inline const ::ibeam_rawpanel::HWCText& HWCState::hwctext() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.HWCText)
  return _internal_hwctext();
}
inline void HWCState::unsafe_arena_set_allocated_hwctext(
    ::ibeam_rawpanel::HWCText* hwctext) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hwctext_);
  }
  hwctext_ = hwctext;
  if (hwctext) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCState.HWCText)
}
inline ::ibeam_rawpanel::HWCText* HWCState::release_hwctext() {
  
  ::ibeam_rawpanel::HWCText* temp = hwctext_;
  hwctext_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCText* HWCState::unsafe_arena_release_hwctext() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCState.HWCText)
  
  ::ibeam_rawpanel::HWCText* temp = hwctext_;
  hwctext_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCText* HWCState::_internal_mutable_hwctext() {
  
  if (hwctext_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCText>(GetArena());
    hwctext_ = p;
  }
  return hwctext_;
}
inline ::ibeam_rawpanel::HWCText* HWCState::mutable_hwctext() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCState.HWCText)
  return _internal_mutable_hwctext();
}
inline void HWCState::set_allocated_hwctext(::ibeam_rawpanel::HWCText* hwctext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hwctext_;
  }
  if (hwctext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hwctext);
    if (message_arena != submessage_arena) {
      hwctext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hwctext, submessage_arena);
    }
    
  } else {
    
  }
  hwctext_ = hwctext;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCState.HWCText)
}

// .ibeam_rawpanel.HWCGfx HWCGfx = 6;
inline bool HWCState::_internal_has_hwcgfx() const {
  return this != internal_default_instance() && hwcgfx_ != nullptr;
}
inline bool HWCState::has_hwcgfx() const {
  return _internal_has_hwcgfx();
}
inline void HWCState::clear_hwcgfx() {
  if (GetArena() == nullptr && hwcgfx_ != nullptr) {
    delete hwcgfx_;
  }
  hwcgfx_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCGfx& HWCState::_internal_hwcgfx() const {
  const ::ibeam_rawpanel::HWCGfx* p = hwcgfx_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::HWCGfx*>(
      &::ibeam_rawpanel::_HWCGfx_default_instance_);
}
inline const ::ibeam_rawpanel::HWCGfx& HWCState::hwcgfx() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.HWCGfx)
  return _internal_hwcgfx();
}
inline void HWCState::unsafe_arena_set_allocated_hwcgfx(
    ::ibeam_rawpanel::HWCGfx* hwcgfx) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hwcgfx_);
  }
  hwcgfx_ = hwcgfx;
  if (hwcgfx) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCState.HWCGfx)
}
inline ::ibeam_rawpanel::HWCGfx* HWCState::release_hwcgfx() {
  
  ::ibeam_rawpanel::HWCGfx* temp = hwcgfx_;
  hwcgfx_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCGfx* HWCState::unsafe_arena_release_hwcgfx() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCState.HWCGfx)
  
  ::ibeam_rawpanel::HWCGfx* temp = hwcgfx_;
  hwcgfx_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCGfx* HWCState::_internal_mutable_hwcgfx() {
  
  if (hwcgfx_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCGfx>(GetArena());
    hwcgfx_ = p;
  }
  return hwcgfx_;
}
inline ::ibeam_rawpanel::HWCGfx* HWCState::mutable_hwcgfx() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCState.HWCGfx)
  return _internal_mutable_hwcgfx();
}
inline void HWCState::set_allocated_hwcgfx(::ibeam_rawpanel::HWCGfx* hwcgfx) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hwcgfx_;
  }
  if (hwcgfx) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hwcgfx);
    if (message_arena != submessage_arena) {
      hwcgfx = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hwcgfx, submessage_arena);
    }
    
  } else {
    
  }
  hwcgfx_ = hwcgfx;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCState.HWCGfx)
}

// -------------------------------------------------------------------

// HWCMode

// .ibeam_rawpanel.HWCMode.State state = 2;
inline void HWCMode::clear_state() {
  state_ = 0;
}
inline ::ibeam_rawpanel::HWCMode_State HWCMode::_internal_state() const {
  return static_cast< ::ibeam_rawpanel::HWCMode_State >(state_);
}
inline ::ibeam_rawpanel::HWCMode_State HWCMode::state() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCMode.state)
  return _internal_state();
}
inline void HWCMode::_internal_set_state(::ibeam_rawpanel::HWCMode_State value) {
  
  state_ = value;
}
inline void HWCMode::set_state(::ibeam_rawpanel::HWCMode_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCMode.state)
}

// uint32 BlinkPattern = 3;
inline void HWCMode::clear_blinkpattern() {
  blinkpattern_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCMode::_internal_blinkpattern() const {
  return blinkpattern_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCMode::blinkpattern() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCMode.BlinkPattern)
  return _internal_blinkpattern();
}
inline void HWCMode::_internal_set_blinkpattern(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  blinkpattern_ = value;
}
inline void HWCMode::set_blinkpattern(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_blinkpattern(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCMode.BlinkPattern)
}

// -------------------------------------------------------------------

// HWCExtended

// .ibeam_rawpanel.HWCExtended.Interpretation interpretation = 2;
inline void HWCExtended::clear_interpretation() {
  interpretation_ = 0;
}
inline ::ibeam_rawpanel::HWCExtended_Interpretation HWCExtended::_internal_interpretation() const {
  return static_cast< ::ibeam_rawpanel::HWCExtended_Interpretation >(interpretation_);
}
inline ::ibeam_rawpanel::HWCExtended_Interpretation HWCExtended::interpretation() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCExtended.interpretation)
  return _internal_interpretation();
}
inline void HWCExtended::_internal_set_interpretation(::ibeam_rawpanel::HWCExtended_Interpretation value) {
  
  interpretation_ = value;
}
inline void HWCExtended::set_interpretation(::ibeam_rawpanel::HWCExtended_Interpretation value) {
  _internal_set_interpretation(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCExtended.interpretation)
}

// uint32 Value = 3;
inline void HWCExtended::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCExtended::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCExtended::value() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCExtended.Value)
  return _internal_value();
}
inline void HWCExtended::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void HWCExtended::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCExtended.Value)
}

// -------------------------------------------------------------------

// HWCColor

// .ibeam_rawpanel.ColorRGB colorRGB = 1;
inline bool HWCColor::_internal_has_colorrgb() const {
  return this != internal_default_instance() && colorrgb_ != nullptr;
}
inline bool HWCColor::has_colorrgb() const {
  return _internal_has_colorrgb();
}
inline void HWCColor::clear_colorrgb() {
  if (GetArena() == nullptr && colorrgb_ != nullptr) {
    delete colorrgb_;
  }
  colorrgb_ = nullptr;
}
inline const ::ibeam_rawpanel::ColorRGB& HWCColor::_internal_colorrgb() const {
  const ::ibeam_rawpanel::ColorRGB* p = colorrgb_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::ColorRGB*>(
      &::ibeam_rawpanel::_ColorRGB_default_instance_);
}
inline const ::ibeam_rawpanel::ColorRGB& HWCColor::colorrgb() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCColor.colorRGB)
  return _internal_colorrgb();
}
inline void HWCColor::unsafe_arena_set_allocated_colorrgb(
    ::ibeam_rawpanel::ColorRGB* colorrgb) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(colorrgb_);
  }
  colorrgb_ = colorrgb;
  if (colorrgb) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCColor.colorRGB)
}
inline ::ibeam_rawpanel::ColorRGB* HWCColor::release_colorrgb() {
  
  ::ibeam_rawpanel::ColorRGB* temp = colorrgb_;
  colorrgb_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::ColorRGB* HWCColor::unsafe_arena_release_colorrgb() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCColor.colorRGB)
  
  ::ibeam_rawpanel::ColorRGB* temp = colorrgb_;
  colorrgb_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::ColorRGB* HWCColor::_internal_mutable_colorrgb() {
  
  if (colorrgb_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::ColorRGB>(GetArena());
    colorrgb_ = p;
  }
  return colorrgb_;
}
inline ::ibeam_rawpanel::ColorRGB* HWCColor::mutable_colorrgb() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCColor.colorRGB)
  return _internal_mutable_colorrgb();
}
inline void HWCColor::set_allocated_colorrgb(::ibeam_rawpanel::ColorRGB* colorrgb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete colorrgb_;
  }
  if (colorrgb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(colorrgb);
    if (message_arena != submessage_arena) {
      colorrgb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, colorrgb, submessage_arena);
    }
    
  } else {
    
  }
  colorrgb_ = colorrgb;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCColor.colorRGB)
}

// .ibeam_rawpanel.ColorIndex colorIndex = 2;
inline bool HWCColor::_internal_has_colorindex() const {
  return this != internal_default_instance() && colorindex_ != nullptr;
}
inline bool HWCColor::has_colorindex() const {
  return _internal_has_colorindex();
}
inline void HWCColor::clear_colorindex() {
  if (GetArena() == nullptr && colorindex_ != nullptr) {
    delete colorindex_;
  }
  colorindex_ = nullptr;
}
inline const ::ibeam_rawpanel::ColorIndex& HWCColor::_internal_colorindex() const {
  const ::ibeam_rawpanel::ColorIndex* p = colorindex_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::ColorIndex*>(
      &::ibeam_rawpanel::_ColorIndex_default_instance_);
}
inline const ::ibeam_rawpanel::ColorIndex& HWCColor::colorindex() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCColor.colorIndex)
  return _internal_colorindex();
}
inline void HWCColor::unsafe_arena_set_allocated_colorindex(
    ::ibeam_rawpanel::ColorIndex* colorindex) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(colorindex_);
  }
  colorindex_ = colorindex;
  if (colorindex) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCColor.colorIndex)
}
inline ::ibeam_rawpanel::ColorIndex* HWCColor::release_colorindex() {
  
  ::ibeam_rawpanel::ColorIndex* temp = colorindex_;
  colorindex_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::ColorIndex* HWCColor::unsafe_arena_release_colorindex() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCColor.colorIndex)
  
  ::ibeam_rawpanel::ColorIndex* temp = colorindex_;
  colorindex_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::ColorIndex* HWCColor::_internal_mutable_colorindex() {
  
  if (colorindex_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::ColorIndex>(GetArena());
    colorindex_ = p;
  }
  return colorindex_;
}
inline ::ibeam_rawpanel::ColorIndex* HWCColor::mutable_colorindex() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCColor.colorIndex)
  return _internal_mutable_colorindex();
}
inline void HWCColor::set_allocated_colorindex(::ibeam_rawpanel::ColorIndex* colorindex) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete colorindex_;
  }
  if (colorindex) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(colorindex);
    if (message_arena != submessage_arena) {
      colorindex = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, colorindex, submessage_arena);
    }
    
  } else {
    
  }
  colorindex_ = colorindex;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCColor.colorIndex)
}

// -------------------------------------------------------------------

// Color

// .ibeam_rawpanel.ColorRGB colorRGB = 1;
inline bool Color::_internal_has_colorrgb() const {
  return this != internal_default_instance() && colorrgb_ != nullptr;
}
inline bool Color::has_colorrgb() const {
  return _internal_has_colorrgb();
}
inline void Color::clear_colorrgb() {
  if (GetArena() == nullptr && colorrgb_ != nullptr) {
    delete colorrgb_;
  }
  colorrgb_ = nullptr;
}
inline const ::ibeam_rawpanel::ColorRGB& Color::_internal_colorrgb() const {
  const ::ibeam_rawpanel::ColorRGB* p = colorrgb_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::ColorRGB*>(
      &::ibeam_rawpanel::_ColorRGB_default_instance_);
}
inline const ::ibeam_rawpanel::ColorRGB& Color::colorrgb() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Color.colorRGB)
  return _internal_colorrgb();
}
inline void Color::unsafe_arena_set_allocated_colorrgb(
    ::ibeam_rawpanel::ColorRGB* colorrgb) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(colorrgb_);
  }
  colorrgb_ = colorrgb;
  if (colorrgb) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.Color.colorRGB)
}
inline ::ibeam_rawpanel::ColorRGB* Color::release_colorrgb() {
  
  ::ibeam_rawpanel::ColorRGB* temp = colorrgb_;
  colorrgb_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::ColorRGB* Color::unsafe_arena_release_colorrgb() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.Color.colorRGB)
  
  ::ibeam_rawpanel::ColorRGB* temp = colorrgb_;
  colorrgb_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::ColorRGB* Color::_internal_mutable_colorrgb() {
  
  if (colorrgb_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::ColorRGB>(GetArena());
    colorrgb_ = p;
  }
  return colorrgb_;
}
inline ::ibeam_rawpanel::ColorRGB* Color::mutable_colorrgb() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.Color.colorRGB)
  return _internal_mutable_colorrgb();
}
inline void Color::set_allocated_colorrgb(::ibeam_rawpanel::ColorRGB* colorrgb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete colorrgb_;
  }
  if (colorrgb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(colorrgb);
    if (message_arena != submessage_arena) {
      colorrgb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, colorrgb, submessage_arena);
    }
    
  } else {
    
  }
  colorrgb_ = colorrgb;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.Color.colorRGB)
}

// .ibeam_rawpanel.ColorIndex colorIndex = 2;
inline bool Color::_internal_has_colorindex() const {
  return this != internal_default_instance() && colorindex_ != nullptr;
}
inline bool Color::has_colorindex() const {
  return _internal_has_colorindex();
}
inline void Color::clear_colorindex() {
  if (GetArena() == nullptr && colorindex_ != nullptr) {
    delete colorindex_;
  }
  colorindex_ = nullptr;
}
inline const ::ibeam_rawpanel::ColorIndex& Color::_internal_colorindex() const {
  const ::ibeam_rawpanel::ColorIndex* p = colorindex_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::ColorIndex*>(
      &::ibeam_rawpanel::_ColorIndex_default_instance_);
}
inline const ::ibeam_rawpanel::ColorIndex& Color::colorindex() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Color.colorIndex)
  return _internal_colorindex();
}
inline void Color::unsafe_arena_set_allocated_colorindex(
    ::ibeam_rawpanel::ColorIndex* colorindex) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(colorindex_);
  }
  colorindex_ = colorindex;
  if (colorindex) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.Color.colorIndex)
}
inline ::ibeam_rawpanel::ColorIndex* Color::release_colorindex() {
  
  ::ibeam_rawpanel::ColorIndex* temp = colorindex_;
  colorindex_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::ColorIndex* Color::unsafe_arena_release_colorindex() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.Color.colorIndex)
  
  ::ibeam_rawpanel::ColorIndex* temp = colorindex_;
  colorindex_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::ColorIndex* Color::_internal_mutable_colorindex() {
  
  if (colorindex_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::ColorIndex>(GetArena());
    colorindex_ = p;
  }
  return colorindex_;
}
inline ::ibeam_rawpanel::ColorIndex* Color::mutable_colorindex() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.Color.colorIndex)
  return _internal_mutable_colorindex();
}
inline void Color::set_allocated_colorindex(::ibeam_rawpanel::ColorIndex* colorindex) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete colorindex_;
  }
  if (colorindex) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(colorindex);
    if (message_arena != submessage_arena) {
      colorindex = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, colorindex, submessage_arena);
    }
    
  } else {
    
  }
  colorindex_ = colorindex;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.Color.colorIndex)
}

// -------------------------------------------------------------------

// ColorRGB

// uint32 Red = 1;
inline void ColorRGB::clear_red() {
  red_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColorRGB::_internal_red() const {
  return red_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColorRGB::red() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ColorRGB.Red)
  return _internal_red();
}
inline void ColorRGB::_internal_set_red(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  red_ = value;
}
inline void ColorRGB::set_red(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_red(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ColorRGB.Red)
}

// uint32 Green = 2;
inline void ColorRGB::clear_green() {
  green_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColorRGB::_internal_green() const {
  return green_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColorRGB::green() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ColorRGB.Green)
  return _internal_green();
}
inline void ColorRGB::_internal_set_green(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  green_ = value;
}
inline void ColorRGB::set_green(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_green(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ColorRGB.Green)
}

// uint32 Blue = 3;
inline void ColorRGB::clear_blue() {
  blue_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColorRGB::_internal_blue() const {
  return blue_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColorRGB::blue() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ColorRGB.Blue)
  return _internal_blue();
}
inline void ColorRGB::_internal_set_blue(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  blue_ = value;
}
inline void ColorRGB::set_blue(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_blue(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ColorRGB.Blue)
}

// -------------------------------------------------------------------

// ColorIndex

// .ibeam_rawpanel.ColorIndex.Colors Index = 1;
inline void ColorIndex::clear_index() {
  index_ = 0;
}
inline ::ibeam_rawpanel::ColorIndex_Colors ColorIndex::_internal_index() const {
  return static_cast< ::ibeam_rawpanel::ColorIndex_Colors >(index_);
}
inline ::ibeam_rawpanel::ColorIndex_Colors ColorIndex::index() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ColorIndex.Index)
  return _internal_index();
}
inline void ColorIndex::_internal_set_index(::ibeam_rawpanel::ColorIndex_Colors value) {
  
  index_ = value;
}
inline void ColorIndex::set_index(::ibeam_rawpanel::ColorIndex_Colors value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ColorIndex.Index)
}

// -------------------------------------------------------------------

// HWCText_Scale

// .ibeam_rawpanel.HWCText.Scale.ScaleType scaleType = 1;
inline void HWCText_Scale::clear_scaletype() {
  scaletype_ = 0;
}
inline ::ibeam_rawpanel::HWCText_Scale_ScaleType HWCText_Scale::_internal_scaletype() const {
  return static_cast< ::ibeam_rawpanel::HWCText_Scale_ScaleType >(scaletype_);
}
inline ::ibeam_rawpanel::HWCText_Scale_ScaleType HWCText_Scale::scaletype() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Scale.scaleType)
  return _internal_scaletype();
}
inline void HWCText_Scale::_internal_set_scaletype(::ibeam_rawpanel::HWCText_Scale_ScaleType value) {
  
  scaletype_ = value;
}
inline void HWCText_Scale::set_scaletype(::ibeam_rawpanel::HWCText_Scale_ScaleType value) {
  _internal_set_scaletype(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Scale.scaleType)
}

// sint32 RangeLow = 2;
inline void HWCText_Scale::clear_rangelow() {
  rangelow_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_Scale::_internal_rangelow() const {
  return rangelow_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_Scale::rangelow() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Scale.RangeLow)
  return _internal_rangelow();
}
inline void HWCText_Scale::_internal_set_rangelow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rangelow_ = value;
}
inline void HWCText_Scale::set_rangelow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rangelow(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Scale.RangeLow)
}

// sint32 RangeHigh = 3;
inline void HWCText_Scale::clear_rangehigh() {
  rangehigh_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_Scale::_internal_rangehigh() const {
  return rangehigh_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_Scale::rangehigh() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Scale.RangeHigh)
  return _internal_rangehigh();
}
inline void HWCText_Scale::_internal_set_rangehigh(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rangehigh_ = value;
}
inline void HWCText_Scale::set_rangehigh(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rangehigh(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Scale.RangeHigh)
}

// sint32 LimitLow = 4;
inline void HWCText_Scale::clear_limitlow() {
  limitlow_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_Scale::_internal_limitlow() const {
  return limitlow_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_Scale::limitlow() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Scale.LimitLow)
  return _internal_limitlow();
}
inline void HWCText_Scale::_internal_set_limitlow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  limitlow_ = value;
}
inline void HWCText_Scale::set_limitlow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_limitlow(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Scale.LimitLow)
}

// sint32 LimitHigh = 5;
inline void HWCText_Scale::clear_limithigh() {
  limithigh_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_Scale::_internal_limithigh() const {
  return limithigh_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_Scale::limithigh() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Scale.LimitHigh)
  return _internal_limithigh();
}
inline void HWCText_Scale::_internal_set_limithigh(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  limithigh_ = value;
}
inline void HWCText_Scale::set_limithigh(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_limithigh(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Scale.LimitHigh)
}

// -------------------------------------------------------------------

// HWCText_TextStyle_Font

// .ibeam_rawpanel.HWCText.TextStyle.Font.FontFace fontFace = 1;
inline void HWCText_TextStyle_Font::clear_fontface() {
  fontface_ = 0;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFace HWCText_TextStyle_Font::_internal_fontface() const {
  return static_cast< ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFace >(fontface_);
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFace HWCText_TextStyle_Font::fontface() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.Font.fontFace)
  return _internal_fontface();
}
inline void HWCText_TextStyle_Font::_internal_set_fontface(::ibeam_rawpanel::HWCText_TextStyle_Font_FontFace value) {
  
  fontface_ = value;
}
inline void HWCText_TextStyle_Font::set_fontface(::ibeam_rawpanel::HWCText_TextStyle_Font_FontFace value) {
  _internal_set_fontface(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.Font.fontFace)
}

// uint32 TextHeight = 2;
inline void HWCText_TextStyle_Font::clear_textheight() {
  textheight_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle_Font::_internal_textheight() const {
  return textheight_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle_Font::textheight() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.Font.TextHeight)
  return _internal_textheight();
}
inline void HWCText_TextStyle_Font::_internal_set_textheight(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  textheight_ = value;
}
inline void HWCText_TextStyle_Font::set_textheight(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_textheight(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.Font.TextHeight)
}

// uint32 TextWidth = 3;
inline void HWCText_TextStyle_Font::clear_textwidth() {
  textwidth_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle_Font::_internal_textwidth() const {
  return textwidth_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle_Font::textwidth() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.Font.TextWidth)
  return _internal_textwidth();
}
inline void HWCText_TextStyle_Font::_internal_set_textwidth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  textwidth_ = value;
}
inline void HWCText_TextStyle_Font::set_textwidth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_textwidth(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.Font.TextWidth)
}

// -------------------------------------------------------------------

// HWCText_TextStyle

// .ibeam_rawpanel.HWCText.TextStyle.Font TitleFont = 1;
inline bool HWCText_TextStyle::_internal_has_titlefont() const {
  return this != internal_default_instance() && titlefont_ != nullptr;
}
inline bool HWCText_TextStyle::has_titlefont() const {
  return _internal_has_titlefont();
}
inline void HWCText_TextStyle::clear_titlefont() {
  if (GetArena() == nullptr && titlefont_ != nullptr) {
    delete titlefont_;
  }
  titlefont_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCText_TextStyle_Font& HWCText_TextStyle::_internal_titlefont() const {
  const ::ibeam_rawpanel::HWCText_TextStyle_Font* p = titlefont_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::HWCText_TextStyle_Font*>(
      &::ibeam_rawpanel::_HWCText_TextStyle_Font_default_instance_);
}
inline const ::ibeam_rawpanel::HWCText_TextStyle_Font& HWCText_TextStyle::titlefont() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.TitleFont)
  return _internal_titlefont();
}
inline void HWCText_TextStyle::unsafe_arena_set_allocated_titlefont(
    ::ibeam_rawpanel::HWCText_TextStyle_Font* titlefont) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(titlefont_);
  }
  titlefont_ = titlefont;
  if (titlefont) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCText.TextStyle.TitleFont)
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::release_titlefont() {
  
  ::ibeam_rawpanel::HWCText_TextStyle_Font* temp = titlefont_;
  titlefont_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::unsafe_arena_release_titlefont() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.TextStyle.TitleFont)
  
  ::ibeam_rawpanel::HWCText_TextStyle_Font* temp = titlefont_;
  titlefont_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::_internal_mutable_titlefont() {
  
  if (titlefont_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCText_TextStyle_Font>(GetArena());
    titlefont_ = p;
  }
  return titlefont_;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::mutable_titlefont() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.TextStyle.TitleFont)
  return _internal_mutable_titlefont();
}
inline void HWCText_TextStyle::set_allocated_titlefont(::ibeam_rawpanel::HWCText_TextStyle_Font* titlefont) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete titlefont_;
  }
  if (titlefont) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(titlefont);
    if (message_arena != submessage_arena) {
      titlefont = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, titlefont, submessage_arena);
    }
    
  } else {
    
  }
  titlefont_ = titlefont;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.TextStyle.TitleFont)
}

// .ibeam_rawpanel.HWCText.TextStyle.Font TextFont = 2;
inline bool HWCText_TextStyle::_internal_has_textfont() const {
  return this != internal_default_instance() && textfont_ != nullptr;
}
inline bool HWCText_TextStyle::has_textfont() const {
  return _internal_has_textfont();
}
inline void HWCText_TextStyle::clear_textfont() {
  if (GetArena() == nullptr && textfont_ != nullptr) {
    delete textfont_;
  }
  textfont_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCText_TextStyle_Font& HWCText_TextStyle::_internal_textfont() const {
  const ::ibeam_rawpanel::HWCText_TextStyle_Font* p = textfont_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::HWCText_TextStyle_Font*>(
      &::ibeam_rawpanel::_HWCText_TextStyle_Font_default_instance_);
}
inline const ::ibeam_rawpanel::HWCText_TextStyle_Font& HWCText_TextStyle::textfont() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.TextFont)
  return _internal_textfont();
}
inline void HWCText_TextStyle::unsafe_arena_set_allocated_textfont(
    ::ibeam_rawpanel::HWCText_TextStyle_Font* textfont) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(textfont_);
  }
  textfont_ = textfont;
  if (textfont) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCText.TextStyle.TextFont)
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::release_textfont() {
  
  ::ibeam_rawpanel::HWCText_TextStyle_Font* temp = textfont_;
  textfont_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::unsafe_arena_release_textfont() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.TextStyle.TextFont)
  
  ::ibeam_rawpanel::HWCText_TextStyle_Font* temp = textfont_;
  textfont_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::_internal_mutable_textfont() {
  
  if (textfont_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCText_TextStyle_Font>(GetArena());
    textfont_ = p;
  }
  return textfont_;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::mutable_textfont() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.TextStyle.TextFont)
  return _internal_mutable_textfont();
}
inline void HWCText_TextStyle::set_allocated_textfont(::ibeam_rawpanel::HWCText_TextStyle_Font* textfont) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete textfont_;
  }
  if (textfont) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(textfont);
    if (message_arena != submessage_arena) {
      textfont = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, textfont, submessage_arena);
    }
    
  } else {
    
  }
  textfont_ = textfont;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.TextStyle.TextFont)
}

// bool FixedWidth = 3;
inline void HWCText_TextStyle::clear_fixedwidth() {
  fixedwidth_ = false;
}
inline bool HWCText_TextStyle::_internal_fixedwidth() const {
  return fixedwidth_;
}
inline bool HWCText_TextStyle::fixedwidth() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.FixedWidth)
  return _internal_fixedwidth();
}
inline void HWCText_TextStyle::_internal_set_fixedwidth(bool value) {
  
  fixedwidth_ = value;
}
inline void HWCText_TextStyle::set_fixedwidth(bool value) {
  _internal_set_fixedwidth(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.FixedWidth)
}

// uint32 TitleBarPadding = 4;
inline void HWCText_TextStyle::clear_titlebarpadding() {
  titlebarpadding_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle::_internal_titlebarpadding() const {
  return titlebarpadding_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle::titlebarpadding() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.TitleBarPadding)
  return _internal_titlebarpadding();
}
inline void HWCText_TextStyle::_internal_set_titlebarpadding(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  titlebarpadding_ = value;
}
inline void HWCText_TextStyle::set_titlebarpadding(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_titlebarpadding(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.TitleBarPadding)
}

// uint32 ExtraCharacterSpacing = 5;
inline void HWCText_TextStyle::clear_extracharacterspacing() {
  extracharacterspacing_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle::_internal_extracharacterspacing() const {
  return extracharacterspacing_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle::extracharacterspacing() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.ExtraCharacterSpacing)
  return _internal_extracharacterspacing();
}
inline void HWCText_TextStyle::_internal_set_extracharacterspacing(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  extracharacterspacing_ = value;
}
inline void HWCText_TextStyle::set_extracharacterspacing(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_extracharacterspacing(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.ExtraCharacterSpacing)
}

// uint32 UnformattedFontSize = 6;
inline void HWCText_TextStyle::clear_unformattedfontsize() {
  unformattedfontsize_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle::_internal_unformattedfontsize() const {
  return unformattedfontsize_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle::unformattedfontsize() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.UnformattedFontSize)
  return _internal_unformattedfontsize();
}
inline void HWCText_TextStyle::_internal_set_unformattedfontsize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  unformattedfontsize_ = value;
}
inline void HWCText_TextStyle::set_unformattedfontsize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_unformattedfontsize(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.UnformattedFontSize)
}

// -------------------------------------------------------------------

// HWCText

// sint32 IntegerValue = 2;
inline void HWCText::clear_integervalue() {
  integervalue_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText::_internal_integervalue() const {
  return integervalue_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText::integervalue() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.IntegerValue)
  return _internal_integervalue();
}
inline void HWCText::_internal_set_integervalue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  integervalue_ = value;
}
inline void HWCText::set_integervalue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_integervalue(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.IntegerValue)
}

// .ibeam_rawpanel.HWCText.Formatting formatting = 3;
inline void HWCText::clear_formatting() {
  formatting_ = 0;
}
inline ::ibeam_rawpanel::HWCText_Formatting HWCText::_internal_formatting() const {
  return static_cast< ::ibeam_rawpanel::HWCText_Formatting >(formatting_);
}
inline ::ibeam_rawpanel::HWCText_Formatting HWCText::formatting() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.formatting)
  return _internal_formatting();
}
inline void HWCText::_internal_set_formatting(::ibeam_rawpanel::HWCText_Formatting value) {
  
  formatting_ = value;
}
inline void HWCText::set_formatting(::ibeam_rawpanel::HWCText_Formatting value) {
  _internal_set_formatting(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.formatting)
}

// .ibeam_rawpanel.HWCText.StateIcon stateIcon = 5;
inline void HWCText::clear_stateicon() {
  stateicon_ = 0;
}
inline ::ibeam_rawpanel::HWCText_StateIcon HWCText::_internal_stateicon() const {
  return static_cast< ::ibeam_rawpanel::HWCText_StateIcon >(stateicon_);
}
inline ::ibeam_rawpanel::HWCText_StateIcon HWCText::stateicon() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.stateIcon)
  return _internal_stateicon();
}
inline void HWCText::_internal_set_stateicon(::ibeam_rawpanel::HWCText_StateIcon value) {
  
  stateicon_ = value;
}
inline void HWCText::set_stateicon(::ibeam_rawpanel::HWCText_StateIcon value) {
  _internal_set_stateicon(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.stateIcon)
}

// .ibeam_rawpanel.HWCText.ModifierIcon modifierIcon = 6;
inline void HWCText::clear_modifiericon() {
  modifiericon_ = 0;
}
inline ::ibeam_rawpanel::HWCText_ModifierIcon HWCText::_internal_modifiericon() const {
  return static_cast< ::ibeam_rawpanel::HWCText_ModifierIcon >(modifiericon_);
}
inline ::ibeam_rawpanel::HWCText_ModifierIcon HWCText::modifiericon() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.modifierIcon)
  return _internal_modifiericon();
}
inline void HWCText::_internal_set_modifiericon(::ibeam_rawpanel::HWCText_ModifierIcon value) {
  
  modifiericon_ = value;
}
inline void HWCText::set_modifiericon(::ibeam_rawpanel::HWCText_ModifierIcon value) {
  _internal_set_modifiericon(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.modifierIcon)
}

// string Title = 7;
inline void HWCText::clear_title() {
  title_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& HWCText::title() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Title)
  return _internal_title();
}
inline void HWCText::set_title(const std::string& value) {
  _internal_set_title(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Title)
}
inline std::string* HWCText::mutable_title() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.Title)
  return _internal_mutable_title();
}
inline const std::string& HWCText::_internal_title() const {
  return title_.Get();
}
inline void HWCText::_internal_set_title(const std::string& value) {
  
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HWCText::set_title(std::string&& value) {
  
  title_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.HWCText.Title)
}
inline void HWCText::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.HWCText.Title)
}
inline void HWCText::set_title(const char* value,
    size_t size) {
  
  title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.HWCText.Title)
}
inline std::string* HWCText::_internal_mutable_title() {
  
  return title_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HWCText::release_title() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.Title)
  return title_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HWCText::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.Title)
}

// bool SolidHeaderBar = 8;
inline void HWCText::clear_solidheaderbar() {
  solidheaderbar_ = false;
}
inline bool HWCText::_internal_solidheaderbar() const {
  return solidheaderbar_;
}
inline bool HWCText::solidheaderbar() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.SolidHeaderBar)
  return _internal_solidheaderbar();
}
inline void HWCText::_internal_set_solidheaderbar(bool value) {
  
  solidheaderbar_ = value;
}
inline void HWCText::set_solidheaderbar(bool value) {
  _internal_set_solidheaderbar(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.SolidHeaderBar)
}

// string Textline1 = 9;
inline void HWCText::clear_textline1() {
  textline1_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& HWCText::textline1() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Textline1)
  return _internal_textline1();
}
inline void HWCText::set_textline1(const std::string& value) {
  _internal_set_textline1(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Textline1)
}
inline std::string* HWCText::mutable_textline1() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.Textline1)
  return _internal_mutable_textline1();
}
inline const std::string& HWCText::_internal_textline1() const {
  return textline1_.Get();
}
inline void HWCText::_internal_set_textline1(const std::string& value) {
  
  textline1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HWCText::set_textline1(std::string&& value) {
  
  textline1_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.HWCText.Textline1)
}
inline void HWCText::set_textline1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  textline1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.HWCText.Textline1)
}
inline void HWCText::set_textline1(const char* value,
    size_t size) {
  
  textline1_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.HWCText.Textline1)
}
inline std::string* HWCText::_internal_mutable_textline1() {
  
  return textline1_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HWCText::release_textline1() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.Textline1)
  return textline1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HWCText::set_allocated_textline1(std::string* textline1) {
  if (textline1 != nullptr) {
    
  } else {
    
  }
  textline1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), textline1,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.Textline1)
}

// string Textline2 = 10;
inline void HWCText::clear_textline2() {
  textline2_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& HWCText::textline2() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Textline2)
  return _internal_textline2();
}
inline void HWCText::set_textline2(const std::string& value) {
  _internal_set_textline2(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Textline2)
}
inline std::string* HWCText::mutable_textline2() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.Textline2)
  return _internal_mutable_textline2();
}
inline const std::string& HWCText::_internal_textline2() const {
  return textline2_.Get();
}
inline void HWCText::_internal_set_textline2(const std::string& value) {
  
  textline2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HWCText::set_textline2(std::string&& value) {
  
  textline2_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.HWCText.Textline2)
}
inline void HWCText::set_textline2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  textline2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.HWCText.Textline2)
}
inline void HWCText::set_textline2(const char* value,
    size_t size) {
  
  textline2_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.HWCText.Textline2)
}
inline std::string* HWCText::_internal_mutable_textline2() {
  
  return textline2_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HWCText::release_textline2() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.Textline2)
  return textline2_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HWCText::set_allocated_textline2(std::string* textline2) {
  if (textline2 != nullptr) {
    
  } else {
    
  }
  textline2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), textline2,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.Textline2)
}

// sint32 IntegerValue2 = 11;
inline void HWCText::clear_integervalue2() {
  integervalue2_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText::_internal_integervalue2() const {
  return integervalue2_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText::integervalue2() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.IntegerValue2)
  return _internal_integervalue2();
}
inline void HWCText::_internal_set_integervalue2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  integervalue2_ = value;
}
inline void HWCText::set_integervalue2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_integervalue2(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.IntegerValue2)
}

// .ibeam_rawpanel.HWCText.PairMode pairMode = 12;
inline void HWCText::clear_pairmode() {
  pairmode_ = 0;
}
inline ::ibeam_rawpanel::HWCText_PairMode HWCText::_internal_pairmode() const {
  return static_cast< ::ibeam_rawpanel::HWCText_PairMode >(pairmode_);
}
inline ::ibeam_rawpanel::HWCText_PairMode HWCText::pairmode() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.pairMode)
  return _internal_pairmode();
}
inline void HWCText::_internal_set_pairmode(::ibeam_rawpanel::HWCText_PairMode value) {
  
  pairmode_ = value;
}
inline void HWCText::set_pairmode(::ibeam_rawpanel::HWCText_PairMode value) {
  _internal_set_pairmode(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.pairMode)
}

// .ibeam_rawpanel.HWCText.Scale scale = 13;
inline bool HWCText::_internal_has_scale() const {
  return this != internal_default_instance() && scale_ != nullptr;
}
inline bool HWCText::has_scale() const {
  return _internal_has_scale();
}
inline void HWCText::clear_scale() {
  if (GetArena() == nullptr && scale_ != nullptr) {
    delete scale_;
  }
  scale_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCText_Scale& HWCText::_internal_scale() const {
  const ::ibeam_rawpanel::HWCText_Scale* p = scale_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::HWCText_Scale*>(
      &::ibeam_rawpanel::_HWCText_Scale_default_instance_);
}
inline const ::ibeam_rawpanel::HWCText_Scale& HWCText::scale() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.scale)
  return _internal_scale();
}
inline void HWCText::unsafe_arena_set_allocated_scale(
    ::ibeam_rawpanel::HWCText_Scale* scale) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scale_);
  }
  scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCText.scale)
}
inline ::ibeam_rawpanel::HWCText_Scale* HWCText::release_scale() {
  
  ::ibeam_rawpanel::HWCText_Scale* temp = scale_;
  scale_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCText_Scale* HWCText::unsafe_arena_release_scale() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.scale)
  
  ::ibeam_rawpanel::HWCText_Scale* temp = scale_;
  scale_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCText_Scale* HWCText::_internal_mutable_scale() {
  
  if (scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCText_Scale>(GetArena());
    scale_ = p;
  }
  return scale_;
}
inline ::ibeam_rawpanel::HWCText_Scale* HWCText::mutable_scale() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.scale)
  return _internal_mutable_scale();
}
inline void HWCText::set_allocated_scale(::ibeam_rawpanel::HWCText_Scale* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete scale_;
  }
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(scale);
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    
  } else {
    
  }
  scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.scale)
}

// .ibeam_rawpanel.HWCText.TextStyle TextStyling = 14;
inline bool HWCText::_internal_has_textstyling() const {
  return this != internal_default_instance() && textstyling_ != nullptr;
}
inline bool HWCText::has_textstyling() const {
  return _internal_has_textstyling();
}
inline void HWCText::clear_textstyling() {
  if (GetArena() == nullptr && textstyling_ != nullptr) {
    delete textstyling_;
  }
  textstyling_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCText_TextStyle& HWCText::_internal_textstyling() const {
  const ::ibeam_rawpanel::HWCText_TextStyle* p = textstyling_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::HWCText_TextStyle*>(
      &::ibeam_rawpanel::_HWCText_TextStyle_default_instance_);
}
inline const ::ibeam_rawpanel::HWCText_TextStyle& HWCText::textstyling() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyling)
  return _internal_textstyling();
}
inline void HWCText::unsafe_arena_set_allocated_textstyling(
    ::ibeam_rawpanel::HWCText_TextStyle* textstyling) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(textstyling_);
  }
  textstyling_ = textstyling;
  if (textstyling) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCText.TextStyling)
}
inline ::ibeam_rawpanel::HWCText_TextStyle* HWCText::release_textstyling() {
  
  ::ibeam_rawpanel::HWCText_TextStyle* temp = textstyling_;
  textstyling_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCText_TextStyle* HWCText::unsafe_arena_release_textstyling() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.TextStyling)
  
  ::ibeam_rawpanel::HWCText_TextStyle* temp = textstyling_;
  textstyling_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCText_TextStyle* HWCText::_internal_mutable_textstyling() {
  
  if (textstyling_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCText_TextStyle>(GetArena());
    textstyling_ = p;
  }
  return textstyling_;
}
inline ::ibeam_rawpanel::HWCText_TextStyle* HWCText::mutable_textstyling() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.TextStyling)
  return _internal_mutable_textstyling();
}
inline void HWCText::set_allocated_textstyling(::ibeam_rawpanel::HWCText_TextStyle* textstyling) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete textstyling_;
  }
  if (textstyling) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(textstyling);
    if (message_arena != submessage_arena) {
      textstyling = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, textstyling, submessage_arena);
    }
    
  } else {
    
  }
  textstyling_ = textstyling;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.TextStyling)
}

// bool Inverted = 15;
inline void HWCText::clear_inverted() {
  inverted_ = false;
}
inline bool HWCText::_internal_inverted() const {
  return inverted_;
}
inline bool HWCText::inverted() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Inverted)
  return _internal_inverted();
}
inline void HWCText::_internal_set_inverted(bool value) {
  
  inverted_ = value;
}
inline void HWCText::set_inverted(bool value) {
  _internal_set_inverted(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Inverted)
}

// .ibeam_rawpanel.Color PixelColor = 16;
inline bool HWCText::_internal_has_pixelcolor() const {
  return this != internal_default_instance() && pixelcolor_ != nullptr;
}
inline bool HWCText::has_pixelcolor() const {
  return _internal_has_pixelcolor();
}
inline void HWCText::clear_pixelcolor() {
  if (GetArena() == nullptr && pixelcolor_ != nullptr) {
    delete pixelcolor_;
  }
  pixelcolor_ = nullptr;
}
inline const ::ibeam_rawpanel::Color& HWCText::_internal_pixelcolor() const {
  const ::ibeam_rawpanel::Color* p = pixelcolor_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::Color*>(
      &::ibeam_rawpanel::_Color_default_instance_);
}
inline const ::ibeam_rawpanel::Color& HWCText::pixelcolor() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.PixelColor)
  return _internal_pixelcolor();
}
inline void HWCText::unsafe_arena_set_allocated_pixelcolor(
    ::ibeam_rawpanel::Color* pixelcolor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixelcolor_);
  }
  pixelcolor_ = pixelcolor;
  if (pixelcolor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCText.PixelColor)
}
inline ::ibeam_rawpanel::Color* HWCText::release_pixelcolor() {
  
  ::ibeam_rawpanel::Color* temp = pixelcolor_;
  pixelcolor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::Color* HWCText::unsafe_arena_release_pixelcolor() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.PixelColor)
  
  ::ibeam_rawpanel::Color* temp = pixelcolor_;
  pixelcolor_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::Color* HWCText::_internal_mutable_pixelcolor() {
  
  if (pixelcolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::Color>(GetArena());
    pixelcolor_ = p;
  }
  return pixelcolor_;
}
inline ::ibeam_rawpanel::Color* HWCText::mutable_pixelcolor() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.PixelColor)
  return _internal_mutable_pixelcolor();
}
inline void HWCText::set_allocated_pixelcolor(::ibeam_rawpanel::Color* pixelcolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pixelcolor_;
  }
  if (pixelcolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pixelcolor);
    if (message_arena != submessage_arena) {
      pixelcolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pixelcolor, submessage_arena);
    }
    
  } else {
    
  }
  pixelcolor_ = pixelcolor;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.PixelColor)
}

// .ibeam_rawpanel.Color BackgroundColor = 17;
inline bool HWCText::_internal_has_backgroundcolor() const {
  return this != internal_default_instance() && backgroundcolor_ != nullptr;
}
inline bool HWCText::has_backgroundcolor() const {
  return _internal_has_backgroundcolor();
}
inline void HWCText::clear_backgroundcolor() {
  if (GetArena() == nullptr && backgroundcolor_ != nullptr) {
    delete backgroundcolor_;
  }
  backgroundcolor_ = nullptr;
}
inline const ::ibeam_rawpanel::Color& HWCText::_internal_backgroundcolor() const {
  const ::ibeam_rawpanel::Color* p = backgroundcolor_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::Color*>(
      &::ibeam_rawpanel::_Color_default_instance_);
}
inline const ::ibeam_rawpanel::Color& HWCText::backgroundcolor() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.BackgroundColor)
  return _internal_backgroundcolor();
}
inline void HWCText::unsafe_arena_set_allocated_backgroundcolor(
    ::ibeam_rawpanel::Color* backgroundcolor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(backgroundcolor_);
  }
  backgroundcolor_ = backgroundcolor;
  if (backgroundcolor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCText.BackgroundColor)
}
inline ::ibeam_rawpanel::Color* HWCText::release_backgroundcolor() {
  
  ::ibeam_rawpanel::Color* temp = backgroundcolor_;
  backgroundcolor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::Color* HWCText::unsafe_arena_release_backgroundcolor() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.BackgroundColor)
  
  ::ibeam_rawpanel::Color* temp = backgroundcolor_;
  backgroundcolor_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::Color* HWCText::_internal_mutable_backgroundcolor() {
  
  if (backgroundcolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::Color>(GetArena());
    backgroundcolor_ = p;
  }
  return backgroundcolor_;
}
inline ::ibeam_rawpanel::Color* HWCText::mutable_backgroundcolor() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.BackgroundColor)
  return _internal_mutable_backgroundcolor();
}
inline void HWCText::set_allocated_backgroundcolor(::ibeam_rawpanel::Color* backgroundcolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete backgroundcolor_;
  }
  if (backgroundcolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(backgroundcolor);
    if (message_arena != submessage_arena) {
      backgroundcolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backgroundcolor, submessage_arena);
    }
    
  } else {
    
  }
  backgroundcolor_ = backgroundcolor;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.BackgroundColor)
}

// -------------------------------------------------------------------

// HWCGfx

// .ibeam_rawpanel.HWCGfx.ImageType imageType = 1;
inline void HWCGfx::clear_imagetype() {
  imagetype_ = 0;
}
inline ::ibeam_rawpanel::HWCGfx_ImageType HWCGfx::_internal_imagetype() const {
  return static_cast< ::ibeam_rawpanel::HWCGfx_ImageType >(imagetype_);
}
inline ::ibeam_rawpanel::HWCGfx_ImageType HWCGfx::imagetype() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.imageType)
  return _internal_imagetype();
}
inline void HWCGfx::_internal_set_imagetype(::ibeam_rawpanel::HWCGfx_ImageType value) {
  
  imagetype_ = value;
}
inline void HWCGfx::set_imagetype(::ibeam_rawpanel::HWCGfx_ImageType value) {
  _internal_set_imagetype(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.imageType)
}

// uint32 W = 2;
inline void HWCGfx::clear_w() {
  w_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::_internal_w() const {
  return w_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::w() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.W)
  return _internal_w();
}
inline void HWCGfx::_internal_set_w(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  w_ = value;
}
inline void HWCGfx::set_w(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.W)
}

// uint32 H = 3;
inline void HWCGfx::clear_h() {
  h_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::_internal_h() const {
  return h_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::h() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.H)
  return _internal_h();
}
inline void HWCGfx::_internal_set_h(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  h_ = value;
}
inline void HWCGfx::set_h(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_h(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.H)
}

// bool XYoffset = 4;
inline void HWCGfx::clear_xyoffset() {
  xyoffset_ = false;
}
inline bool HWCGfx::_internal_xyoffset() const {
  return xyoffset_;
}
inline bool HWCGfx::xyoffset() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.XYoffset)
  return _internal_xyoffset();
}
inline void HWCGfx::_internal_set_xyoffset(bool value) {
  
  xyoffset_ = value;
}
inline void HWCGfx::set_xyoffset(bool value) {
  _internal_set_xyoffset(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.XYoffset)
}

// uint32 X = 5;
inline void HWCGfx::clear_x() {
  x_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::x() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.X)
  return _internal_x();
}
inline void HWCGfx::_internal_set_x(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  x_ = value;
}
inline void HWCGfx::set_x(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.X)
}

// uint32 Y = 6;
inline void HWCGfx::clear_y() {
  y_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::y() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.Y)
  return _internal_y();
}
inline void HWCGfx::_internal_set_y(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  y_ = value;
}
inline void HWCGfx::set_y(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.Y)
}

// bytes ImageData = 16;
inline void HWCGfx::clear_imagedata() {
  imagedata_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& HWCGfx::imagedata() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.ImageData)
  return _internal_imagedata();
}
inline void HWCGfx::set_imagedata(const std::string& value) {
  _internal_set_imagedata(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.ImageData)
}
inline std::string* HWCGfx::mutable_imagedata() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCGfx.ImageData)
  return _internal_mutable_imagedata();
}
inline const std::string& HWCGfx::_internal_imagedata() const {
  return imagedata_.Get();
}
inline void HWCGfx::_internal_set_imagedata(const std::string& value) {
  
  imagedata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void HWCGfx::set_imagedata(std::string&& value) {
  
  imagedata_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.HWCGfx.ImageData)
}
inline void HWCGfx::set_imagedata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  imagedata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.HWCGfx.ImageData)
}
inline void HWCGfx::set_imagedata(const void* value,
    size_t size) {
  
  imagedata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.HWCGfx.ImageData)
}
inline std::string* HWCGfx::_internal_mutable_imagedata() {
  
  return imagedata_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* HWCGfx::release_imagedata() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCGfx.ImageData)
  return imagedata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HWCGfx::set_allocated_imagedata(std::string* imagedata) {
  if (imagedata != nullptr) {
    
  } else {
    
  }
  imagedata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), imagedata,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCGfx.ImageData)
}

// -------------------------------------------------------------------

// ImgConvert

// .ibeam_rawpanel.ImgConvert.FileType fileType = 1;
inline void ImgConvert::clear_filetype() {
  filetype_ = 0;
}
inline ::ibeam_rawpanel::ImgConvert_FileType ImgConvert::_internal_filetype() const {
  return static_cast< ::ibeam_rawpanel::ImgConvert_FileType >(filetype_);
}
inline ::ibeam_rawpanel::ImgConvert_FileType ImgConvert::filetype() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ImgConvert.fileType)
  return _internal_filetype();
}
inline void ImgConvert::_internal_set_filetype(::ibeam_rawpanel::ImgConvert_FileType value) {
  
  filetype_ = value;
}
inline void ImgConvert::set_filetype(::ibeam_rawpanel::ImgConvert_FileType value) {
  _internal_set_filetype(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ImgConvert.fileType)
}

// .ibeam_rawpanel.ImgConvert.Scaling scaling = 2;
inline void ImgConvert::clear_scaling() {
  scaling_ = 0;
}
inline ::ibeam_rawpanel::ImgConvert_Scaling ImgConvert::_internal_scaling() const {
  return static_cast< ::ibeam_rawpanel::ImgConvert_Scaling >(scaling_);
}
inline ::ibeam_rawpanel::ImgConvert_Scaling ImgConvert::scaling() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ImgConvert.scaling)
  return _internal_scaling();
}
inline void ImgConvert::_internal_set_scaling(::ibeam_rawpanel::ImgConvert_Scaling value) {
  
  scaling_ = value;
}
inline void ImgConvert::set_scaling(::ibeam_rawpanel::ImgConvert_Scaling value) {
  _internal_set_scaling(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ImgConvert.scaling)
}

// bool Grayscale = 3;
inline void ImgConvert::clear_grayscale() {
  grayscale_ = false;
}
inline bool ImgConvert::_internal_grayscale() const {
  return grayscale_;
}
inline bool ImgConvert::grayscale() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ImgConvert.Grayscale)
  return _internal_grayscale();
}
inline void ImgConvert::_internal_set_grayscale(bool value) {
  
  grayscale_ = value;
}
inline void ImgConvert::set_grayscale(bool value) {
  _internal_set_grayscale(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ImgConvert.Grayscale)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OutboundMessage

// .ibeam_rawpanel.OutboundMessage.FlowMsg FlowMessage = 1;
inline void OutboundMessage::clear_flowmessage() {
  flowmessage_ = 0;
}
inline ::ibeam_rawpanel::OutboundMessage_FlowMsg OutboundMessage::_internal_flowmessage() const {
  return static_cast< ::ibeam_rawpanel::OutboundMessage_FlowMsg >(flowmessage_);
}
inline ::ibeam_rawpanel::OutboundMessage_FlowMsg OutboundMessage::flowmessage() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.FlowMessage)
  return _internal_flowmessage();
}
inline void OutboundMessage::_internal_set_flowmessage(::ibeam_rawpanel::OutboundMessage_FlowMsg value) {
  
  flowmessage_ = value;
}
inline void OutboundMessage::set_flowmessage(::ibeam_rawpanel::OutboundMessage_FlowMsg value) {
  _internal_set_flowmessage(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.OutboundMessage.FlowMessage)
}

// map<uint32, .ibeam_rawpanel.OutboundMessage.HWCavail> HWCavailability = 2;
inline int OutboundMessage::_internal_hwcavailability_size() const {
  return hwcavailability_.size();
}
inline int OutboundMessage::hwcavailability_size() const {
  return _internal_hwcavailability_size();
}
inline void OutboundMessage::clear_hwcavailability() {
  hwcavailability_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::ibeam_rawpanel::OutboundMessage_HWCavail >&
OutboundMessage::_internal_hwcavailability() const {
  return hwcavailability_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::ibeam_rawpanel::OutboundMessage_HWCavail >&
OutboundMessage::hwcavailability() const {
  // @@protoc_insertion_point(field_map:ibeam_rawpanel.OutboundMessage.HWCavailability)
  return _internal_hwcavailability();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::ibeam_rawpanel::OutboundMessage_HWCavail >*
OutboundMessage::_internal_mutable_hwcavailability() {
  return hwcavailability_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::ibeam_rawpanel::OutboundMessage_HWCavail >*
OutboundMessage::mutable_hwcavailability() {
  // @@protoc_insertion_point(field_mutable_map:ibeam_rawpanel.OutboundMessage.HWCavailability)
  return _internal_mutable_hwcavailability();
}

// .ibeam_rawpanel.PanelInfo PanelInfo = 4;
inline bool OutboundMessage::_internal_has_panelinfo() const {
  return this != internal_default_instance() && panelinfo_ != nullptr;
}
inline bool OutboundMessage::has_panelinfo() const {
  return _internal_has_panelinfo();
}
inline void OutboundMessage::clear_panelinfo() {
  if (GetArena() == nullptr && panelinfo_ != nullptr) {
    delete panelinfo_;
  }
  panelinfo_ = nullptr;
}
inline const ::ibeam_rawpanel::PanelInfo& OutboundMessage::_internal_panelinfo() const {
  const ::ibeam_rawpanel::PanelInfo* p = panelinfo_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::PanelInfo*>(
      &::ibeam_rawpanel::_PanelInfo_default_instance_);
}
inline const ::ibeam_rawpanel::PanelInfo& OutboundMessage::panelinfo() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.PanelInfo)
  return _internal_panelinfo();
}
inline void OutboundMessage::unsafe_arena_set_allocated_panelinfo(
    ::ibeam_rawpanel::PanelInfo* panelinfo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(panelinfo_);
  }
  panelinfo_ = panelinfo;
  if (panelinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.OutboundMessage.PanelInfo)
}
inline ::ibeam_rawpanel::PanelInfo* OutboundMessage::release_panelinfo() {
  
  ::ibeam_rawpanel::PanelInfo* temp = panelinfo_;
  panelinfo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::PanelInfo* OutboundMessage::unsafe_arena_release_panelinfo() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.OutboundMessage.PanelInfo)
  
  ::ibeam_rawpanel::PanelInfo* temp = panelinfo_;
  panelinfo_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::PanelInfo* OutboundMessage::_internal_mutable_panelinfo() {
  
  if (panelinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::PanelInfo>(GetArena());
    panelinfo_ = p;
  }
  return panelinfo_;
}
inline ::ibeam_rawpanel::PanelInfo* OutboundMessage::mutable_panelinfo() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.OutboundMessage.PanelInfo)
  return _internal_mutable_panelinfo();
}
inline void OutboundMessage::set_allocated_panelinfo(::ibeam_rawpanel::PanelInfo* panelinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete panelinfo_;
  }
  if (panelinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(panelinfo);
    if (message_arena != submessage_arena) {
      panelinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, panelinfo, submessage_arena);
    }
    
  } else {
    
  }
  panelinfo_ = panelinfo;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.OutboundMessage.PanelInfo)
}

// .ibeam_rawpanel.PanelTopology PanelTopology = 5;
inline bool OutboundMessage::_internal_has_paneltopology() const {
  return this != internal_default_instance() && paneltopology_ != nullptr;
}
inline bool OutboundMessage::has_paneltopology() const {
  return _internal_has_paneltopology();
}
inline void OutboundMessage::clear_paneltopology() {
  if (GetArena() == nullptr && paneltopology_ != nullptr) {
    delete paneltopology_;
  }
  paneltopology_ = nullptr;
}
inline const ::ibeam_rawpanel::PanelTopology& OutboundMessage::_internal_paneltopology() const {
  const ::ibeam_rawpanel::PanelTopology* p = paneltopology_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::PanelTopology*>(
      &::ibeam_rawpanel::_PanelTopology_default_instance_);
}
inline const ::ibeam_rawpanel::PanelTopology& OutboundMessage::paneltopology() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.PanelTopology)
  return _internal_paneltopology();
}
inline void OutboundMessage::unsafe_arena_set_allocated_paneltopology(
    ::ibeam_rawpanel::PanelTopology* paneltopology) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(paneltopology_);
  }
  paneltopology_ = paneltopology;
  if (paneltopology) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.OutboundMessage.PanelTopology)
}
inline ::ibeam_rawpanel::PanelTopology* OutboundMessage::release_paneltopology() {
  
  ::ibeam_rawpanel::PanelTopology* temp = paneltopology_;
  paneltopology_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::PanelTopology* OutboundMessage::unsafe_arena_release_paneltopology() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.OutboundMessage.PanelTopology)
  
  ::ibeam_rawpanel::PanelTopology* temp = paneltopology_;
  paneltopology_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::PanelTopology* OutboundMessage::_internal_mutable_paneltopology() {
  
  if (paneltopology_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::PanelTopology>(GetArena());
    paneltopology_ = p;
  }
  return paneltopology_;
}
inline ::ibeam_rawpanel::PanelTopology* OutboundMessage::mutable_paneltopology() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.OutboundMessage.PanelTopology)
  return _internal_mutable_paneltopology();
}
inline void OutboundMessage::set_allocated_paneltopology(::ibeam_rawpanel::PanelTopology* paneltopology) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete paneltopology_;
  }
  if (paneltopology) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(paneltopology);
    if (message_arena != submessage_arena) {
      paneltopology = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paneltopology, submessage_arena);
    }
    
  } else {
    
  }
  paneltopology_ = paneltopology;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.OutboundMessage.PanelTopology)
}

// .ibeam_rawpanel.SleepTimeout sleepTimeout = 6;
inline bool OutboundMessage::_internal_has_sleeptimeout() const {
  return this != internal_default_instance() && sleeptimeout_ != nullptr;
}
inline bool OutboundMessage::has_sleeptimeout() const {
  return _internal_has_sleeptimeout();
}
inline void OutboundMessage::clear_sleeptimeout() {
  if (GetArena() == nullptr && sleeptimeout_ != nullptr) {
    delete sleeptimeout_;
  }
  sleeptimeout_ = nullptr;
}
inline const ::ibeam_rawpanel::SleepTimeout& OutboundMessage::_internal_sleeptimeout() const {
  const ::ibeam_rawpanel::SleepTimeout* p = sleeptimeout_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::SleepTimeout*>(
      &::ibeam_rawpanel::_SleepTimeout_default_instance_);
}
inline const ::ibeam_rawpanel::SleepTimeout& OutboundMessage::sleeptimeout() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.sleepTimeout)
  return _internal_sleeptimeout();
}
inline void OutboundMessage::unsafe_arena_set_allocated_sleeptimeout(
    ::ibeam_rawpanel::SleepTimeout* sleeptimeout) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sleeptimeout_);
  }
  sleeptimeout_ = sleeptimeout;
  if (sleeptimeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.OutboundMessage.sleepTimeout)
}
inline ::ibeam_rawpanel::SleepTimeout* OutboundMessage::release_sleeptimeout() {
  
  ::ibeam_rawpanel::SleepTimeout* temp = sleeptimeout_;
  sleeptimeout_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::SleepTimeout* OutboundMessage::unsafe_arena_release_sleeptimeout() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.OutboundMessage.sleepTimeout)
  
  ::ibeam_rawpanel::SleepTimeout* temp = sleeptimeout_;
  sleeptimeout_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::SleepTimeout* OutboundMessage::_internal_mutable_sleeptimeout() {
  
  if (sleeptimeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::SleepTimeout>(GetArena());
    sleeptimeout_ = p;
  }
  return sleeptimeout_;
}
inline ::ibeam_rawpanel::SleepTimeout* OutboundMessage::mutable_sleeptimeout() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.OutboundMessage.sleepTimeout)
  return _internal_mutable_sleeptimeout();
}
inline void OutboundMessage::set_allocated_sleeptimeout(::ibeam_rawpanel::SleepTimeout* sleeptimeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sleeptimeout_;
  }
  if (sleeptimeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sleeptimeout);
    if (message_arena != submessage_arena) {
      sleeptimeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sleeptimeout, submessage_arena);
    }
    
  } else {
    
  }
  sleeptimeout_ = sleeptimeout;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.OutboundMessage.sleepTimeout)
}

// .ibeam_rawpanel.SleepState sleepState = 7;
inline bool OutboundMessage::_internal_has_sleepstate() const {
  return this != internal_default_instance() && sleepstate_ != nullptr;
}
inline bool OutboundMessage::has_sleepstate() const {
  return _internal_has_sleepstate();
}
inline void OutboundMessage::clear_sleepstate() {
  if (GetArena() == nullptr && sleepstate_ != nullptr) {
    delete sleepstate_;
  }
  sleepstate_ = nullptr;
}
inline const ::ibeam_rawpanel::SleepState& OutboundMessage::_internal_sleepstate() const {
  const ::ibeam_rawpanel::SleepState* p = sleepstate_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::SleepState*>(
      &::ibeam_rawpanel::_SleepState_default_instance_);
}
inline const ::ibeam_rawpanel::SleepState& OutboundMessage::sleepstate() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.sleepState)
  return _internal_sleepstate();
}
inline void OutboundMessage::unsafe_arena_set_allocated_sleepstate(
    ::ibeam_rawpanel::SleepState* sleepstate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sleepstate_);
  }
  sleepstate_ = sleepstate;
  if (sleepstate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.OutboundMessage.sleepState)
}
inline ::ibeam_rawpanel::SleepState* OutboundMessage::release_sleepstate() {
  
  ::ibeam_rawpanel::SleepState* temp = sleepstate_;
  sleepstate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::SleepState* OutboundMessage::unsafe_arena_release_sleepstate() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.OutboundMessage.sleepState)
  
  ::ibeam_rawpanel::SleepState* temp = sleepstate_;
  sleepstate_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::SleepState* OutboundMessage::_internal_mutable_sleepstate() {
  
  if (sleepstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::SleepState>(GetArena());
    sleepstate_ = p;
  }
  return sleepstate_;
}
inline ::ibeam_rawpanel::SleepState* OutboundMessage::mutable_sleepstate() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.OutboundMessage.sleepState)
  return _internal_mutable_sleepstate();
}
inline void OutboundMessage::set_allocated_sleepstate(::ibeam_rawpanel::SleepState* sleepstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sleepstate_;
  }
  if (sleepstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sleepstate);
    if (message_arena != submessage_arena) {
      sleepstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sleepstate, submessage_arena);
    }
    
  } else {
    
  }
  sleepstate_ = sleepstate;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.OutboundMessage.sleepState)
}

// repeated .ibeam_rawpanel.HWCEvent Events = 8;
inline int OutboundMessage::_internal_events_size() const {
  return events_.size();
}
inline int OutboundMessage::events_size() const {
  return _internal_events_size();
}
inline void OutboundMessage::clear_events() {
  events_.Clear();
}
inline ::ibeam_rawpanel::HWCEvent* OutboundMessage::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.OutboundMessage.Events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCEvent >*
OutboundMessage::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:ibeam_rawpanel.OutboundMessage.Events)
  return &events_;
}
inline const ::ibeam_rawpanel::HWCEvent& OutboundMessage::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::ibeam_rawpanel::HWCEvent& OutboundMessage::events(int index) const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.Events)
  return _internal_events(index);
}
inline ::ibeam_rawpanel::HWCEvent* OutboundMessage::_internal_add_events() {
  return events_.Add();
}
inline ::ibeam_rawpanel::HWCEvent* OutboundMessage::add_events() {
  // @@protoc_insertion_point(field_add:ibeam_rawpanel.OutboundMessage.Events)
  return _internal_add_events();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCEvent >&
OutboundMessage::events() const {
  // @@protoc_insertion_point(field_list:ibeam_rawpanel.OutboundMessage.Events)
  return events_;
}

// -------------------------------------------------------------------

// SleepState

// bool IsSleeping = 1;
inline void SleepState::clear_issleeping() {
  issleeping_ = false;
}
inline bool SleepState::_internal_issleeping() const {
  return issleeping_;
}
inline bool SleepState::issleeping() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.SleepState.IsSleeping)
  return _internal_issleeping();
}
inline void SleepState::_internal_set_issleeping(bool value) {
  
  issleeping_ = value;
}
inline void SleepState::set_issleeping(bool value) {
  _internal_set_issleeping(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.SleepState.IsSleeping)
}

// -------------------------------------------------------------------

// HWCEvent

// uint32 HWCID = 1;
inline void HWCEvent::clear_hwcid() {
  hwcid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCEvent::_internal_hwcid() const {
  return hwcid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCEvent::hwcid() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.HWCID)
  return _internal_hwcid();
}
inline void HWCEvent::_internal_set_hwcid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  hwcid_ = value;
}
inline void HWCEvent::set_hwcid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hwcid(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCEvent.HWCID)
}

// uint32 Timestamp = 6;
inline void HWCEvent::clear_timestamp() {
  timestamp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCEvent::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.Timestamp)
  return _internal_timestamp();
}
inline void HWCEvent::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  timestamp_ = value;
}
inline void HWCEvent::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCEvent.Timestamp)
}

// .ibeam_rawpanel.BinaryEvent Binary = 2;
inline bool HWCEvent::_internal_has_binary() const {
  return this != internal_default_instance() && binary_ != nullptr;
}
inline bool HWCEvent::has_binary() const {
  return _internal_has_binary();
}
inline void HWCEvent::clear_binary() {
  if (GetArena() == nullptr && binary_ != nullptr) {
    delete binary_;
  }
  binary_ = nullptr;
}
inline const ::ibeam_rawpanel::BinaryEvent& HWCEvent::_internal_binary() const {
  const ::ibeam_rawpanel::BinaryEvent* p = binary_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::BinaryEvent*>(
      &::ibeam_rawpanel::_BinaryEvent_default_instance_);
}
inline const ::ibeam_rawpanel::BinaryEvent& HWCEvent::binary() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.Binary)
  return _internal_binary();
}
inline void HWCEvent::unsafe_arena_set_allocated_binary(
    ::ibeam_rawpanel::BinaryEvent* binary) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(binary_);
  }
  binary_ = binary;
  if (binary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCEvent.Binary)
}
inline ::ibeam_rawpanel::BinaryEvent* HWCEvent::release_binary() {
  
  ::ibeam_rawpanel::BinaryEvent* temp = binary_;
  binary_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::BinaryEvent* HWCEvent::unsafe_arena_release_binary() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCEvent.Binary)
  
  ::ibeam_rawpanel::BinaryEvent* temp = binary_;
  binary_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::BinaryEvent* HWCEvent::_internal_mutable_binary() {
  
  if (binary_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::BinaryEvent>(GetArena());
    binary_ = p;
  }
  return binary_;
}
inline ::ibeam_rawpanel::BinaryEvent* HWCEvent::mutable_binary() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCEvent.Binary)
  return _internal_mutable_binary();
}
inline void HWCEvent::set_allocated_binary(::ibeam_rawpanel::BinaryEvent* binary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete binary_;
  }
  if (binary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(binary);
    if (message_arena != submessage_arena) {
      binary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binary, submessage_arena);
    }
    
  } else {
    
  }
  binary_ = binary;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCEvent.Binary)
}

// .ibeam_rawpanel.PulsedEvent Pulsed = 3;
inline bool HWCEvent::_internal_has_pulsed() const {
  return this != internal_default_instance() && pulsed_ != nullptr;
}
inline bool HWCEvent::has_pulsed() const {
  return _internal_has_pulsed();
}
inline void HWCEvent::clear_pulsed() {
  if (GetArena() == nullptr && pulsed_ != nullptr) {
    delete pulsed_;
  }
  pulsed_ = nullptr;
}
inline const ::ibeam_rawpanel::PulsedEvent& HWCEvent::_internal_pulsed() const {
  const ::ibeam_rawpanel::PulsedEvent* p = pulsed_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::PulsedEvent*>(
      &::ibeam_rawpanel::_PulsedEvent_default_instance_);
}
inline const ::ibeam_rawpanel::PulsedEvent& HWCEvent::pulsed() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.Pulsed)
  return _internal_pulsed();
}
inline void HWCEvent::unsafe_arena_set_allocated_pulsed(
    ::ibeam_rawpanel::PulsedEvent* pulsed) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pulsed_);
  }
  pulsed_ = pulsed;
  if (pulsed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCEvent.Pulsed)
}
inline ::ibeam_rawpanel::PulsedEvent* HWCEvent::release_pulsed() {
  
  ::ibeam_rawpanel::PulsedEvent* temp = pulsed_;
  pulsed_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::PulsedEvent* HWCEvent::unsafe_arena_release_pulsed() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCEvent.Pulsed)
  
  ::ibeam_rawpanel::PulsedEvent* temp = pulsed_;
  pulsed_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::PulsedEvent* HWCEvent::_internal_mutable_pulsed() {
  
  if (pulsed_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::PulsedEvent>(GetArena());
    pulsed_ = p;
  }
  return pulsed_;
}
inline ::ibeam_rawpanel::PulsedEvent* HWCEvent::mutable_pulsed() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCEvent.Pulsed)
  return _internal_mutable_pulsed();
}
inline void HWCEvent::set_allocated_pulsed(::ibeam_rawpanel::PulsedEvent* pulsed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pulsed_;
  }
  if (pulsed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pulsed);
    if (message_arena != submessage_arena) {
      pulsed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pulsed, submessage_arena);
    }
    
  } else {
    
  }
  pulsed_ = pulsed;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCEvent.Pulsed)
}

// .ibeam_rawpanel.AbsoluteEvent Absolute = 4;
inline bool HWCEvent::_internal_has_absolute() const {
  return this != internal_default_instance() && absolute_ != nullptr;
}
inline bool HWCEvent::has_absolute() const {
  return _internal_has_absolute();
}
inline void HWCEvent::clear_absolute() {
  if (GetArena() == nullptr && absolute_ != nullptr) {
    delete absolute_;
  }
  absolute_ = nullptr;
}
inline const ::ibeam_rawpanel::AbsoluteEvent& HWCEvent::_internal_absolute() const {
  const ::ibeam_rawpanel::AbsoluteEvent* p = absolute_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::AbsoluteEvent*>(
      &::ibeam_rawpanel::_AbsoluteEvent_default_instance_);
}
inline const ::ibeam_rawpanel::AbsoluteEvent& HWCEvent::absolute() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.Absolute)
  return _internal_absolute();
}
inline void HWCEvent::unsafe_arena_set_allocated_absolute(
    ::ibeam_rawpanel::AbsoluteEvent* absolute) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(absolute_);
  }
  absolute_ = absolute;
  if (absolute) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCEvent.Absolute)
}
inline ::ibeam_rawpanel::AbsoluteEvent* HWCEvent::release_absolute() {
  
  ::ibeam_rawpanel::AbsoluteEvent* temp = absolute_;
  absolute_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::AbsoluteEvent* HWCEvent::unsafe_arena_release_absolute() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCEvent.Absolute)
  
  ::ibeam_rawpanel::AbsoluteEvent* temp = absolute_;
  absolute_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::AbsoluteEvent* HWCEvent::_internal_mutable_absolute() {
  
  if (absolute_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::AbsoluteEvent>(GetArena());
    absolute_ = p;
  }
  return absolute_;
}
inline ::ibeam_rawpanel::AbsoluteEvent* HWCEvent::mutable_absolute() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCEvent.Absolute)
  return _internal_mutable_absolute();
}
inline void HWCEvent::set_allocated_absolute(::ibeam_rawpanel::AbsoluteEvent* absolute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete absolute_;
  }
  if (absolute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(absolute);
    if (message_arena != submessage_arena) {
      absolute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, absolute, submessage_arena);
    }
    
  } else {
    
  }
  absolute_ = absolute;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCEvent.Absolute)
}

// .ibeam_rawpanel.SpeedEvent Speed = 5;
inline bool HWCEvent::_internal_has_speed() const {
  return this != internal_default_instance() && speed_ != nullptr;
}
inline bool HWCEvent::has_speed() const {
  return _internal_has_speed();
}
inline void HWCEvent::clear_speed() {
  if (GetArena() == nullptr && speed_ != nullptr) {
    delete speed_;
  }
  speed_ = nullptr;
}
inline const ::ibeam_rawpanel::SpeedEvent& HWCEvent::_internal_speed() const {
  const ::ibeam_rawpanel::SpeedEvent* p = speed_;
  return p != nullptr ? *p : *reinterpret_cast<const ::ibeam_rawpanel::SpeedEvent*>(
      &::ibeam_rawpanel::_SpeedEvent_default_instance_);
}
inline const ::ibeam_rawpanel::SpeedEvent& HWCEvent::speed() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.Speed)
  return _internal_speed();
}
inline void HWCEvent::unsafe_arena_set_allocated_speed(
    ::ibeam_rawpanel::SpeedEvent* speed) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(speed_);
  }
  speed_ = speed;
  if (speed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCEvent.Speed)
}
inline ::ibeam_rawpanel::SpeedEvent* HWCEvent::release_speed() {
  
  ::ibeam_rawpanel::SpeedEvent* temp = speed_;
  speed_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::SpeedEvent* HWCEvent::unsafe_arena_release_speed() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCEvent.Speed)
  
  ::ibeam_rawpanel::SpeedEvent* temp = speed_;
  speed_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::SpeedEvent* HWCEvent::_internal_mutable_speed() {
  
  if (speed_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::SpeedEvent>(GetArena());
    speed_ = p;
  }
  return speed_;
}
inline ::ibeam_rawpanel::SpeedEvent* HWCEvent::mutable_speed() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCEvent.Speed)
  return _internal_mutable_speed();
}
inline void HWCEvent::set_allocated_speed(::ibeam_rawpanel::SpeedEvent* speed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete speed_;
  }
  if (speed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(speed);
    if (message_arena != submessage_arena) {
      speed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed, submessage_arena);
    }
    
  } else {
    
  }
  speed_ = speed;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCEvent.Speed)
}

// -------------------------------------------------------------------

// BinaryEvent

// bool Pressed = 1;
inline void BinaryEvent::clear_pressed() {
  pressed_ = false;
}
inline bool BinaryEvent::_internal_pressed() const {
  return pressed_;
}
inline bool BinaryEvent::pressed() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.BinaryEvent.Pressed)
  return _internal_pressed();
}
inline void BinaryEvent::_internal_set_pressed(bool value) {
  
  pressed_ = value;
}
inline void BinaryEvent::set_pressed(bool value) {
  _internal_set_pressed(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.BinaryEvent.Pressed)
}

// .ibeam_rawpanel.BinaryEvent.EdgeID Edge = 2;
inline void BinaryEvent::clear_edge() {
  edge_ = 0;
}
inline ::ibeam_rawpanel::BinaryEvent_EdgeID BinaryEvent::_internal_edge() const {
  return static_cast< ::ibeam_rawpanel::BinaryEvent_EdgeID >(edge_);
}
inline ::ibeam_rawpanel::BinaryEvent_EdgeID BinaryEvent::edge() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.BinaryEvent.Edge)
  return _internal_edge();
}
inline void BinaryEvent::_internal_set_edge(::ibeam_rawpanel::BinaryEvent_EdgeID value) {
  
  edge_ = value;
}
inline void BinaryEvent::set_edge(::ibeam_rawpanel::BinaryEvent_EdgeID value) {
  _internal_set_edge(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.BinaryEvent.Edge)
}

// -------------------------------------------------------------------

// PulsedEvent

// sint32 Value = 1;
inline void PulsedEvent::clear_value() {
  value_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PulsedEvent::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PulsedEvent::value() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PulsedEvent.Value)
  return _internal_value();
}
inline void PulsedEvent::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  value_ = value;
}
inline void PulsedEvent::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PulsedEvent.Value)
}

// -------------------------------------------------------------------

// AbsoluteEvent

// uint32 Value = 1;
inline void AbsoluteEvent::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AbsoluteEvent::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AbsoluteEvent::value() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.AbsoluteEvent.Value)
  return _internal_value();
}
inline void AbsoluteEvent::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void AbsoluteEvent::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.AbsoluteEvent.Value)
}

// -------------------------------------------------------------------

// SpeedEvent

// sint32 Value = 1;
inline void SpeedEvent::clear_value() {
  value_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpeedEvent::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpeedEvent::value() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.SpeedEvent.Value)
  return _internal_value();
}
inline void SpeedEvent::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  value_ = value;
}
inline void SpeedEvent::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.SpeedEvent.Value)
}

// -------------------------------------------------------------------

// PanelInfo

// string Model = 1;
inline void PanelInfo::clear_model() {
  model_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PanelInfo::model() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PanelInfo.Model)
  return _internal_model();
}
inline void PanelInfo::set_model(const std::string& value) {
  _internal_set_model(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PanelInfo.Model)
}
inline std::string* PanelInfo::mutable_model() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.PanelInfo.Model)
  return _internal_mutable_model();
}
inline const std::string& PanelInfo::_internal_model() const {
  return model_.Get();
}
inline void PanelInfo::_internal_set_model(const std::string& value) {
  
  model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PanelInfo::set_model(std::string&& value) {
  
  model_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.PanelInfo.Model)
}
inline void PanelInfo::set_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.PanelInfo.Model)
}
inline void PanelInfo::set_model(const char* value,
    size_t size) {
  
  model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.PanelInfo.Model)
}
inline std::string* PanelInfo::_internal_mutable_model() {
  
  return model_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PanelInfo::release_model() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.PanelInfo.Model)
  return model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PanelInfo::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.PanelInfo.Model)
}

// string Serial = 2;
inline void PanelInfo::clear_serial() {
  serial_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PanelInfo::serial() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PanelInfo.Serial)
  return _internal_serial();
}
inline void PanelInfo::set_serial(const std::string& value) {
  _internal_set_serial(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PanelInfo.Serial)
}
inline std::string* PanelInfo::mutable_serial() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.PanelInfo.Serial)
  return _internal_mutable_serial();
}
inline const std::string& PanelInfo::_internal_serial() const {
  return serial_.Get();
}
inline void PanelInfo::_internal_set_serial(const std::string& value) {
  
  serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PanelInfo::set_serial(std::string&& value) {
  
  serial_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.PanelInfo.Serial)
}
inline void PanelInfo::set_serial(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.PanelInfo.Serial)
}
inline void PanelInfo::set_serial(const char* value,
    size_t size) {
  
  serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.PanelInfo.Serial)
}
inline std::string* PanelInfo::_internal_mutable_serial() {
  
  return serial_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PanelInfo::release_serial() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.PanelInfo.Serial)
  return serial_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PanelInfo::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    
  } else {
    
  }
  serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.PanelInfo.Serial)
}

// string SoftwareVersion = 4;
inline void PanelInfo::clear_softwareversion() {
  softwareversion_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PanelInfo::softwareversion() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PanelInfo.SoftwareVersion)
  return _internal_softwareversion();
}
inline void PanelInfo::set_softwareversion(const std::string& value) {
  _internal_set_softwareversion(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PanelInfo.SoftwareVersion)
}
inline std::string* PanelInfo::mutable_softwareversion() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.PanelInfo.SoftwareVersion)
  return _internal_mutable_softwareversion();
}
inline const std::string& PanelInfo::_internal_softwareversion() const {
  return softwareversion_.Get();
}
inline void PanelInfo::_internal_set_softwareversion(const std::string& value) {
  
  softwareversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PanelInfo::set_softwareversion(std::string&& value) {
  
  softwareversion_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.PanelInfo.SoftwareVersion)
}
inline void PanelInfo::set_softwareversion(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  softwareversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.PanelInfo.SoftwareVersion)
}
inline void PanelInfo::set_softwareversion(const char* value,
    size_t size) {
  
  softwareversion_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.PanelInfo.SoftwareVersion)
}
inline std::string* PanelInfo::_internal_mutable_softwareversion() {
  
  return softwareversion_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PanelInfo::release_softwareversion() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.PanelInfo.SoftwareVersion)
  return softwareversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PanelInfo::set_allocated_softwareversion(std::string* softwareversion) {
  if (softwareversion != nullptr) {
    
  } else {
    
  }
  softwareversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), softwareversion,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.PanelInfo.SoftwareVersion)
}

// -------------------------------------------------------------------

// PanelTopology

// string Svgbase = 1;
inline void PanelTopology::clear_svgbase() {
  svgbase_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PanelTopology::svgbase() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PanelTopology.Svgbase)
  return _internal_svgbase();
}
inline void PanelTopology::set_svgbase(const std::string& value) {
  _internal_set_svgbase(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PanelTopology.Svgbase)
}
inline std::string* PanelTopology::mutable_svgbase() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.PanelTopology.Svgbase)
  return _internal_mutable_svgbase();
}
inline const std::string& PanelTopology::_internal_svgbase() const {
  return svgbase_.Get();
}
inline void PanelTopology::_internal_set_svgbase(const std::string& value) {
  
  svgbase_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PanelTopology::set_svgbase(std::string&& value) {
  
  svgbase_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.PanelTopology.Svgbase)
}
inline void PanelTopology::set_svgbase(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  svgbase_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.PanelTopology.Svgbase)
}
inline void PanelTopology::set_svgbase(const char* value,
    size_t size) {
  
  svgbase_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.PanelTopology.Svgbase)
}
inline std::string* PanelTopology::_internal_mutable_svgbase() {
  
  return svgbase_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PanelTopology::release_svgbase() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.PanelTopology.Svgbase)
  return svgbase_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PanelTopology::set_allocated_svgbase(std::string* svgbase) {
  if (svgbase != nullptr) {
    
  } else {
    
  }
  svgbase_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), svgbase,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.PanelTopology.Svgbase)
}

// string Json = 2;
inline void PanelTopology::clear_json() {
  json_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& PanelTopology::json() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PanelTopology.Json)
  return _internal_json();
}
inline void PanelTopology::set_json(const std::string& value) {
  _internal_set_json(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PanelTopology.Json)
}
inline std::string* PanelTopology::mutable_json() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.PanelTopology.Json)
  return _internal_mutable_json();
}
inline const std::string& PanelTopology::_internal_json() const {
  return json_.Get();
}
inline void PanelTopology::_internal_set_json(const std::string& value) {
  
  json_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void PanelTopology::set_json(std::string&& value) {
  
  json_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.PanelTopology.Json)
}
inline void PanelTopology::set_json(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  json_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.PanelTopology.Json)
}
inline void PanelTopology::set_json(const char* value,
    size_t size) {
  
  json_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.PanelTopology.Json)
}
inline std::string* PanelTopology::_internal_mutable_json() {
  
  return json_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* PanelTopology::release_json() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.PanelTopology.Json)
  return json_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PanelTopology::set_allocated_json(std::string* json) {
  if (json != nullptr) {
    
  } else {
    
  }
  json_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), json,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.PanelTopology.Json)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ibeam_rawpanel

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ibeam_rawpanel::InboundMessage_FlowMsg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::InboundMessage_FlowMsg>() {
  return ::ibeam_rawpanel::InboundMessage_FlowMsg_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCMode_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCMode_State>() {
  return ::ibeam_rawpanel::HWCMode_State_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCExtended_Interpretation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCExtended_Interpretation>() {
  return ::ibeam_rawpanel::HWCExtended_Interpretation_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::ColorIndex_Colors> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::ColorIndex_Colors>() {
  return ::ibeam_rawpanel::ColorIndex_Colors_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCText_Scale_ScaleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCText_Scale_ScaleType>() {
  return ::ibeam_rawpanel::HWCText_Scale_ScaleType_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFace> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFace>() {
  return ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFace_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCText_Formatting> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCText_Formatting>() {
  return ::ibeam_rawpanel::HWCText_Formatting_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCText_StateIcon> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCText_StateIcon>() {
  return ::ibeam_rawpanel::HWCText_StateIcon_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCText_ModifierIcon> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCText_ModifierIcon>() {
  return ::ibeam_rawpanel::HWCText_ModifierIcon_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCText_PairMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCText_PairMode>() {
  return ::ibeam_rawpanel::HWCText_PairMode_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCGfx_ImageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCGfx_ImageType>() {
  return ::ibeam_rawpanel::HWCGfx_ImageType_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::ImgConvert_FileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::ImgConvert_FileType>() {
  return ::ibeam_rawpanel::ImgConvert_FileType_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::ImgConvert_Scaling> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::ImgConvert_Scaling>() {
  return ::ibeam_rawpanel::ImgConvert_Scaling_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::OutboundMessage_FlowMsg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::OutboundMessage_FlowMsg>() {
  return ::ibeam_rawpanel::OutboundMessage_FlowMsg_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::OutboundMessage_HWCavail> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::OutboundMessage_HWCavail>() {
  return ::ibeam_rawpanel::OutboundMessage_HWCavail_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::BinaryEvent_EdgeID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::BinaryEvent_EdgeID>() {
  return ::ibeam_rawpanel::BinaryEvent_EdgeID_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ibeam_2dproto_2drawpanel_2fibeam_2drawpanel_2eproto
