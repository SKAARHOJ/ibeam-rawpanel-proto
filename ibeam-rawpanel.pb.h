// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ibeam-rawpanel.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ibeam_2drawpanel_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ibeam_2drawpanel_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ibeam_2drawpanel_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ibeam_2drawpanel_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[31]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ibeam_2drawpanel_2eproto;
namespace ibeam_rawpanel {
class AbsoluteEvent;
class AbsoluteEventDefaultTypeInternal;
extern AbsoluteEventDefaultTypeInternal _AbsoluteEvent_default_instance_;
class BinaryEvent;
class BinaryEventDefaultTypeInternal;
extern BinaryEventDefaultTypeInternal _BinaryEvent_default_instance_;
class Brightness;
class BrightnessDefaultTypeInternal;
extern BrightnessDefaultTypeInternal _Brightness_default_instance_;
class BurninProfile;
class BurninProfileDefaultTypeInternal;
extern BurninProfileDefaultTypeInternal _BurninProfile_default_instance_;
class Color;
class ColorDefaultTypeInternal;
extern ColorDefaultTypeInternal _Color_default_instance_;
class ColorIndex;
class ColorIndexDefaultTypeInternal;
extern ColorIndexDefaultTypeInternal _ColorIndex_default_instance_;
class ColorRGB;
class ColorRGBDefaultTypeInternal;
extern ColorRGBDefaultTypeInternal _ColorRGB_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class HWCColor;
class HWCColorDefaultTypeInternal;
extern HWCColorDefaultTypeInternal _HWCColor_default_instance_;
class HWCEvent;
class HWCEventDefaultTypeInternal;
extern HWCEventDefaultTypeInternal _HWCEvent_default_instance_;
class HWCExtended;
class HWCExtendedDefaultTypeInternal;
extern HWCExtendedDefaultTypeInternal _HWCExtended_default_instance_;
class HWCGfx;
class HWCGfxDefaultTypeInternal;
extern HWCGfxDefaultTypeInternal _HWCGfx_default_instance_;
class HWCMode;
class HWCModeDefaultTypeInternal;
extern HWCModeDefaultTypeInternal _HWCMode_default_instance_;
class HWCState;
class HWCStateDefaultTypeInternal;
extern HWCStateDefaultTypeInternal _HWCState_default_instance_;
class HWCText;
class HWCTextDefaultTypeInternal;
extern HWCTextDefaultTypeInternal _HWCText_default_instance_;
class HWCText_ScaleM;
class HWCText_ScaleMDefaultTypeInternal;
extern HWCText_ScaleMDefaultTypeInternal _HWCText_ScaleM_default_instance_;
class HWCText_TextStyle;
class HWCText_TextStyleDefaultTypeInternal;
extern HWCText_TextStyleDefaultTypeInternal _HWCText_TextStyle_default_instance_;
class HWCText_TextStyle_Font;
class HWCText_TextStyle_FontDefaultTypeInternal;
extern HWCText_TextStyle_FontDefaultTypeInternal _HWCText_TextStyle_Font_default_instance_;
class ImgConvert;
class ImgConvertDefaultTypeInternal;
extern ImgConvertDefaultTypeInternal _ImgConvert_default_instance_;
class InboundMessage;
class InboundMessageDefaultTypeInternal;
extern InboundMessageDefaultTypeInternal _InboundMessage_default_instance_;
class OutboundMessage;
class OutboundMessageDefaultTypeInternal;
extern OutboundMessageDefaultTypeInternal _OutboundMessage_default_instance_;
class OutboundMessage_HWCavailabilityEntry_DoNotUse;
class OutboundMessage_HWCavailabilityEntry_DoNotUseDefaultTypeInternal;
extern OutboundMessage_HWCavailabilityEntry_DoNotUseDefaultTypeInternal _OutboundMessage_HWCavailabilityEntry_DoNotUse_default_instance_;
class PanelInfo;
class PanelInfoDefaultTypeInternal;
extern PanelInfoDefaultTypeInternal _PanelInfo_default_instance_;
class PanelTopology;
class PanelTopologyDefaultTypeInternal;
extern PanelTopologyDefaultTypeInternal _PanelTopology_default_instance_;
class PublishRawADCValues;
class PublishRawADCValuesDefaultTypeInternal;
extern PublishRawADCValuesDefaultTypeInternal _PublishRawADCValues_default_instance_;
class PulsedEvent;
class PulsedEventDefaultTypeInternal;
extern PulsedEventDefaultTypeInternal _PulsedEvent_default_instance_;
class RawAnalogEvent;
class RawAnalogEventDefaultTypeInternal;
extern RawAnalogEventDefaultTypeInternal _RawAnalogEvent_default_instance_;
class SleepState;
class SleepStateDefaultTypeInternal;
extern SleepStateDefaultTypeInternal _SleepState_default_instance_;
class SleepTimeout;
class SleepTimeoutDefaultTypeInternal;
extern SleepTimeoutDefaultTypeInternal _SleepTimeout_default_instance_;
class SpeedEvent;
class SpeedEventDefaultTypeInternal;
extern SpeedEventDefaultTypeInternal _SpeedEvent_default_instance_;
class WebserverState;
class WebserverStateDefaultTypeInternal;
extern WebserverStateDefaultTypeInternal _WebserverState_default_instance_;
}  // namespace ibeam_rawpanel
PROTOBUF_NAMESPACE_OPEN
template<> ::ibeam_rawpanel::AbsoluteEvent* Arena::CreateMaybeMessage<::ibeam_rawpanel::AbsoluteEvent>(Arena*);
template<> ::ibeam_rawpanel::BinaryEvent* Arena::CreateMaybeMessage<::ibeam_rawpanel::BinaryEvent>(Arena*);
template<> ::ibeam_rawpanel::Brightness* Arena::CreateMaybeMessage<::ibeam_rawpanel::Brightness>(Arena*);
template<> ::ibeam_rawpanel::BurninProfile* Arena::CreateMaybeMessage<::ibeam_rawpanel::BurninProfile>(Arena*);
template<> ::ibeam_rawpanel::Color* Arena::CreateMaybeMessage<::ibeam_rawpanel::Color>(Arena*);
template<> ::ibeam_rawpanel::ColorIndex* Arena::CreateMaybeMessage<::ibeam_rawpanel::ColorIndex>(Arena*);
template<> ::ibeam_rawpanel::ColorRGB* Arena::CreateMaybeMessage<::ibeam_rawpanel::ColorRGB>(Arena*);
template<> ::ibeam_rawpanel::Command* Arena::CreateMaybeMessage<::ibeam_rawpanel::Command>(Arena*);
template<> ::ibeam_rawpanel::HWCColor* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCColor>(Arena*);
template<> ::ibeam_rawpanel::HWCEvent* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCEvent>(Arena*);
template<> ::ibeam_rawpanel::HWCExtended* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCExtended>(Arena*);
template<> ::ibeam_rawpanel::HWCGfx* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCGfx>(Arena*);
template<> ::ibeam_rawpanel::HWCMode* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCMode>(Arena*);
template<> ::ibeam_rawpanel::HWCState* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCState>(Arena*);
template<> ::ibeam_rawpanel::HWCText* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCText>(Arena*);
template<> ::ibeam_rawpanel::HWCText_ScaleM* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCText_ScaleM>(Arena*);
template<> ::ibeam_rawpanel::HWCText_TextStyle* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCText_TextStyle>(Arena*);
template<> ::ibeam_rawpanel::HWCText_TextStyle_Font* Arena::CreateMaybeMessage<::ibeam_rawpanel::HWCText_TextStyle_Font>(Arena*);
template<> ::ibeam_rawpanel::ImgConvert* Arena::CreateMaybeMessage<::ibeam_rawpanel::ImgConvert>(Arena*);
template<> ::ibeam_rawpanel::InboundMessage* Arena::CreateMaybeMessage<::ibeam_rawpanel::InboundMessage>(Arena*);
template<> ::ibeam_rawpanel::OutboundMessage* Arena::CreateMaybeMessage<::ibeam_rawpanel::OutboundMessage>(Arena*);
template<> ::ibeam_rawpanel::OutboundMessage_HWCavailabilityEntry_DoNotUse* Arena::CreateMaybeMessage<::ibeam_rawpanel::OutboundMessage_HWCavailabilityEntry_DoNotUse>(Arena*);
template<> ::ibeam_rawpanel::PanelInfo* Arena::CreateMaybeMessage<::ibeam_rawpanel::PanelInfo>(Arena*);
template<> ::ibeam_rawpanel::PanelTopology* Arena::CreateMaybeMessage<::ibeam_rawpanel::PanelTopology>(Arena*);
template<> ::ibeam_rawpanel::PublishRawADCValues* Arena::CreateMaybeMessage<::ibeam_rawpanel::PublishRawADCValues>(Arena*);
template<> ::ibeam_rawpanel::PulsedEvent* Arena::CreateMaybeMessage<::ibeam_rawpanel::PulsedEvent>(Arena*);
template<> ::ibeam_rawpanel::RawAnalogEvent* Arena::CreateMaybeMessage<::ibeam_rawpanel::RawAnalogEvent>(Arena*);
template<> ::ibeam_rawpanel::SleepState* Arena::CreateMaybeMessage<::ibeam_rawpanel::SleepState>(Arena*);
template<> ::ibeam_rawpanel::SleepTimeout* Arena::CreateMaybeMessage<::ibeam_rawpanel::SleepTimeout>(Arena*);
template<> ::ibeam_rawpanel::SpeedEvent* Arena::CreateMaybeMessage<::ibeam_rawpanel::SpeedEvent>(Arena*);
template<> ::ibeam_rawpanel::WebserverState* Arena::CreateMaybeMessage<::ibeam_rawpanel::WebserverState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ibeam_rawpanel {

enum InboundMessage_FlowMsg : int {
  InboundMessage_FlowMsg_NONE = 0,
  InboundMessage_FlowMsg_PING = 1,
  InboundMessage_FlowMsg_ACK = 2,
  InboundMessage_FlowMsg_NACK = 3,
  InboundMessage_FlowMsg_InboundMessage_FlowMsg_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  InboundMessage_FlowMsg_InboundMessage_FlowMsg_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool InboundMessage_FlowMsg_IsValid(int value);
constexpr InboundMessage_FlowMsg InboundMessage_FlowMsg_FlowMsg_MIN = InboundMessage_FlowMsg_NONE;
constexpr InboundMessage_FlowMsg InboundMessage_FlowMsg_FlowMsg_MAX = InboundMessage_FlowMsg_NACK;
constexpr int InboundMessage_FlowMsg_FlowMsg_ARRAYSIZE = InboundMessage_FlowMsg_FlowMsg_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* InboundMessage_FlowMsg_descriptor();
template<typename T>
inline const std::string& InboundMessage_FlowMsg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InboundMessage_FlowMsg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InboundMessage_FlowMsg_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    InboundMessage_FlowMsg_descriptor(), enum_t_value);
}
inline bool InboundMessage_FlowMsg_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InboundMessage_FlowMsg* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<InboundMessage_FlowMsg>(
    InboundMessage_FlowMsg_descriptor(), name, value);
}
enum HWCMode_StateE : int {
  HWCMode_StateE_OFF = 0,
  HWCMode_StateE_ON_YELLOW = 1,
  HWCMode_StateE_ON_RED = 2,
  HWCMode_StateE_ON_GREEN = 3,
  HWCMode_StateE_ON = 4,
  HWCMode_StateE_DIMMED = 5,
  HWCMode_StateE_HWCMode_StateE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCMode_StateE_HWCMode_StateE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCMode_StateE_IsValid(int value);
constexpr HWCMode_StateE HWCMode_StateE_StateE_MIN = HWCMode_StateE_OFF;
constexpr HWCMode_StateE HWCMode_StateE_StateE_MAX = HWCMode_StateE_DIMMED;
constexpr int HWCMode_StateE_StateE_ARRAYSIZE = HWCMode_StateE_StateE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCMode_StateE_descriptor();
template<typename T>
inline const std::string& HWCMode_StateE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCMode_StateE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCMode_StateE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCMode_StateE_descriptor(), enum_t_value);
}
inline bool HWCMode_StateE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCMode_StateE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCMode_StateE>(
    HWCMode_StateE_descriptor(), name, value);
}
enum HWCExtended_InterpretationE : int {
  HWCExtended_InterpretationE_NONE = 0,
  HWCExtended_InterpretationE_STRENGTH = 1,
  HWCExtended_InterpretationE_STEPS = 3,
  HWCExtended_InterpretationE_VU = 4,
  HWCExtended_InterpretationE_FADER = 5,
  HWCExtended_InterpretationE_HWCExtended_InterpretationE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCExtended_InterpretationE_HWCExtended_InterpretationE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCExtended_InterpretationE_IsValid(int value);
constexpr HWCExtended_InterpretationE HWCExtended_InterpretationE_InterpretationE_MIN = HWCExtended_InterpretationE_NONE;
constexpr HWCExtended_InterpretationE HWCExtended_InterpretationE_InterpretationE_MAX = HWCExtended_InterpretationE_FADER;
constexpr int HWCExtended_InterpretationE_InterpretationE_ARRAYSIZE = HWCExtended_InterpretationE_InterpretationE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCExtended_InterpretationE_descriptor();
template<typename T>
inline const std::string& HWCExtended_InterpretationE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCExtended_InterpretationE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCExtended_InterpretationE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCExtended_InterpretationE_descriptor(), enum_t_value);
}
inline bool HWCExtended_InterpretationE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCExtended_InterpretationE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCExtended_InterpretationE>(
    HWCExtended_InterpretationE_descriptor(), name, value);
}
enum ColorIndex_Colors : int {
  ColorIndex_Colors_DEFAULT = 0,
  ColorIndex_Colors_OFF = 1,
  ColorIndex_Colors_WHITE = 2,
  ColorIndex_Colors_WARM = 3,
  ColorIndex_Colors_RED = 4,
  ColorIndex_Colors_ROSE = 5,
  ColorIndex_Colors_PINK = 6,
  ColorIndex_Colors_PURPLE = 7,
  ColorIndex_Colors_AMBER = 8,
  ColorIndex_Colors_YELLOW = 9,
  ColorIndex_Colors_DARKBLUE = 10,
  ColorIndex_Colors_BLUE = 11,
  ColorIndex_Colors_ICE = 12,
  ColorIndex_Colors_CYAN = 13,
  ColorIndex_Colors_SPRING = 14,
  ColorIndex_Colors_GREEN = 15,
  ColorIndex_Colors_MINT = 16,
  ColorIndex_Colors_ColorIndex_Colors_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ColorIndex_Colors_ColorIndex_Colors_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ColorIndex_Colors_IsValid(int value);
constexpr ColorIndex_Colors ColorIndex_Colors_Colors_MIN = ColorIndex_Colors_DEFAULT;
constexpr ColorIndex_Colors ColorIndex_Colors_Colors_MAX = ColorIndex_Colors_MINT;
constexpr int ColorIndex_Colors_Colors_ARRAYSIZE = ColorIndex_Colors_Colors_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ColorIndex_Colors_descriptor();
template<typename T>
inline const std::string& ColorIndex_Colors_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ColorIndex_Colors>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ColorIndex_Colors_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ColorIndex_Colors_descriptor(), enum_t_value);
}
inline bool ColorIndex_Colors_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ColorIndex_Colors* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ColorIndex_Colors>(
    ColorIndex_Colors_descriptor(), name, value);
}
enum HWCText_ScaleM_ScaleTypeE : int {
  HWCText_ScaleM_ScaleTypeE_ST_OFF = 0,
  HWCText_ScaleM_ScaleTypeE_ST_STRENGTH = 1,
  HWCText_ScaleM_ScaleTypeE_ST_CENTER_MARKER = 2,
  HWCText_ScaleM_ScaleTypeE_ST_CENTER_BAR = 3,
  HWCText_ScaleM_ScaleTypeE_HWCText_ScaleM_ScaleTypeE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCText_ScaleM_ScaleTypeE_HWCText_ScaleM_ScaleTypeE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCText_ScaleM_ScaleTypeE_IsValid(int value);
constexpr HWCText_ScaleM_ScaleTypeE HWCText_ScaleM_ScaleTypeE_ScaleTypeE_MIN = HWCText_ScaleM_ScaleTypeE_ST_OFF;
constexpr HWCText_ScaleM_ScaleTypeE HWCText_ScaleM_ScaleTypeE_ScaleTypeE_MAX = HWCText_ScaleM_ScaleTypeE_ST_CENTER_BAR;
constexpr int HWCText_ScaleM_ScaleTypeE_ScaleTypeE_ARRAYSIZE = HWCText_ScaleM_ScaleTypeE_ScaleTypeE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCText_ScaleM_ScaleTypeE_descriptor();
template<typename T>
inline const std::string& HWCText_ScaleM_ScaleTypeE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCText_ScaleM_ScaleTypeE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCText_ScaleM_ScaleTypeE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCText_ScaleM_ScaleTypeE_descriptor(), enum_t_value);
}
inline bool HWCText_ScaleM_ScaleTypeE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCText_ScaleM_ScaleTypeE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCText_ScaleM_ScaleTypeE>(
    HWCText_ScaleM_ScaleTypeE_descriptor(), name, value);
}
enum HWCText_TextStyle_Font_FontFaceE : int {
  HWCText_TextStyle_Font_FontFaceE_ST_DEFAULT = 0,
  HWCText_TextStyle_Font_FontFaceE_ST_BOLD = 1,
  HWCText_TextStyle_Font_FontFaceE_ST_TINY = 2,
  HWCText_TextStyle_Font_FontFaceE_HWCText_TextStyle_Font_FontFaceE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCText_TextStyle_Font_FontFaceE_HWCText_TextStyle_Font_FontFaceE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCText_TextStyle_Font_FontFaceE_IsValid(int value);
constexpr HWCText_TextStyle_Font_FontFaceE HWCText_TextStyle_Font_FontFaceE_FontFaceE_MIN = HWCText_TextStyle_Font_FontFaceE_ST_DEFAULT;
constexpr HWCText_TextStyle_Font_FontFaceE HWCText_TextStyle_Font_FontFaceE_FontFaceE_MAX = HWCText_TextStyle_Font_FontFaceE_ST_TINY;
constexpr int HWCText_TextStyle_Font_FontFaceE_FontFaceE_ARRAYSIZE = HWCText_TextStyle_Font_FontFaceE_FontFaceE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCText_TextStyle_Font_FontFaceE_descriptor();
template<typename T>
inline const std::string& HWCText_TextStyle_Font_FontFaceE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCText_TextStyle_Font_FontFaceE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCText_TextStyle_Font_FontFaceE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCText_TextStyle_Font_FontFaceE_descriptor(), enum_t_value);
}
inline bool HWCText_TextStyle_Font_FontFaceE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCText_TextStyle_Font_FontFaceE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCText_TextStyle_Font_FontFaceE>(
    HWCText_TextStyle_Font_FontFaceE_descriptor(), name, value);
}
enum HWCText_FormattingE : int {
  HWCText_FormattingE_FMT_INTEGER = 0,
  HWCText_FormattingE_FMT_FLOAT_2DEZ = 1,
  HWCText_FormattingE_FMT_PERCENTAGE = 2,
  HWCText_FormattingE_FMT_DB = 3,
  HWCText_FormattingE_FMT_FRAMES = 4,
  HWCText_FormattingE_FMT_ONEOVERX = 5,
  HWCText_FormattingE_FMT_KELVIN = 6,
  HWCText_FormattingE_FMT_HIDE = 7,
  HWCText_FormattingE_FMT_FLOAT_X_XXX = 8,
  HWCText_FormattingE_FMT_FLOAT_XX_XX = 9,
  HWCText_FormattingE_FMT_ONELINE = 10,
  HWCText_FormattingE_FMT_TWOLINES = 11,
  HWCText_FormattingE_FMT_FLOAT_XXX_X = 12,
  HWCText_FormattingE_HWCText_FormattingE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCText_FormattingE_HWCText_FormattingE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCText_FormattingE_IsValid(int value);
constexpr HWCText_FormattingE HWCText_FormattingE_FormattingE_MIN = HWCText_FormattingE_FMT_INTEGER;
constexpr HWCText_FormattingE HWCText_FormattingE_FormattingE_MAX = HWCText_FormattingE_FMT_FLOAT_XXX_X;
constexpr int HWCText_FormattingE_FormattingE_ARRAYSIZE = HWCText_FormattingE_FormattingE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCText_FormattingE_descriptor();
template<typename T>
inline const std::string& HWCText_FormattingE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCText_FormattingE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCText_FormattingE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCText_FormattingE_descriptor(), enum_t_value);
}
inline bool HWCText_FormattingE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCText_FormattingE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCText_FormattingE>(
    HWCText_FormattingE_descriptor(), name, value);
}
enum HWCText_StateIconE : int {
  HWCText_StateIconE_SI_NONE = 0,
  HWCText_StateIconE_SI_FINE = 1,
  HWCText_StateIconE_SI_LOCK = 2,
  HWCText_StateIconE_SI_NOACCESS = 3,
  HWCText_StateIconE_HWCText_StateIconE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCText_StateIconE_HWCText_StateIconE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCText_StateIconE_IsValid(int value);
constexpr HWCText_StateIconE HWCText_StateIconE_StateIconE_MIN = HWCText_StateIconE_SI_NONE;
constexpr HWCText_StateIconE HWCText_StateIconE_StateIconE_MAX = HWCText_StateIconE_SI_NOACCESS;
constexpr int HWCText_StateIconE_StateIconE_ARRAYSIZE = HWCText_StateIconE_StateIconE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCText_StateIconE_descriptor();
template<typename T>
inline const std::string& HWCText_StateIconE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCText_StateIconE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCText_StateIconE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCText_StateIconE_descriptor(), enum_t_value);
}
inline bool HWCText_StateIconE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCText_StateIconE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCText_StateIconE>(
    HWCText_StateIconE_descriptor(), name, value);
}
enum HWCText_ModifierIconE : int {
  HWCText_ModifierIconE_MI_NONE = 0,
  HWCText_ModifierIconE_MI_CYCLE = 1,
  HWCText_ModifierIconE_MI_DOWN = 2,
  HWCText_ModifierIconE_MI_UP = 3,
  HWCText_ModifierIconE_MI_HOLD = 4,
  HWCText_ModifierIconE_MI_TOGGLE = 5,
  HWCText_ModifierIconE_MI_OK = 6,
  HWCText_ModifierIconE_MI_QUESTION = 7,
  HWCText_ModifierIconE_HWCText_ModifierIconE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCText_ModifierIconE_HWCText_ModifierIconE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCText_ModifierIconE_IsValid(int value);
constexpr HWCText_ModifierIconE HWCText_ModifierIconE_ModifierIconE_MIN = HWCText_ModifierIconE_MI_NONE;
constexpr HWCText_ModifierIconE HWCText_ModifierIconE_ModifierIconE_MAX = HWCText_ModifierIconE_MI_QUESTION;
constexpr int HWCText_ModifierIconE_ModifierIconE_ARRAYSIZE = HWCText_ModifierIconE_ModifierIconE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCText_ModifierIconE_descriptor();
template<typename T>
inline const std::string& HWCText_ModifierIconE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCText_ModifierIconE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCText_ModifierIconE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCText_ModifierIconE_descriptor(), enum_t_value);
}
inline bool HWCText_ModifierIconE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCText_ModifierIconE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCText_ModifierIconE>(
    HWCText_ModifierIconE_descriptor(), name, value);
}
enum HWCText_PairModeE : int {
  HWCText_PairModeE_PM_OFF = 0,
  HWCText_PairModeE_PM_UNMARKED = 1,
  HWCText_PairModeE_PM_UPPER_MARKED = 2,
  HWCText_PairModeE_PM_LOWER_MARKED = 3,
  HWCText_PairModeE_PM_BOTH_MARKED = 4,
  HWCText_PairModeE_HWCText_PairModeE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCText_PairModeE_HWCText_PairModeE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCText_PairModeE_IsValid(int value);
constexpr HWCText_PairModeE HWCText_PairModeE_PairModeE_MIN = HWCText_PairModeE_PM_OFF;
constexpr HWCText_PairModeE HWCText_PairModeE_PairModeE_MAX = HWCText_PairModeE_PM_BOTH_MARKED;
constexpr int HWCText_PairModeE_PairModeE_ARRAYSIZE = HWCText_PairModeE_PairModeE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCText_PairModeE_descriptor();
template<typename T>
inline const std::string& HWCText_PairModeE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCText_PairModeE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCText_PairModeE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCText_PairModeE_descriptor(), enum_t_value);
}
inline bool HWCText_PairModeE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCText_PairModeE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCText_PairModeE>(
    HWCText_PairModeE_descriptor(), name, value);
}
enum HWCGfx_ImageTypeE : int {
  HWCGfx_ImageTypeE_MONO = 0,
  HWCGfx_ImageTypeE_RGB16bit = 1,
  HWCGfx_ImageTypeE_HWCGfx_ImageTypeE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  HWCGfx_ImageTypeE_HWCGfx_ImageTypeE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool HWCGfx_ImageTypeE_IsValid(int value);
constexpr HWCGfx_ImageTypeE HWCGfx_ImageTypeE_ImageTypeE_MIN = HWCGfx_ImageTypeE_MONO;
constexpr HWCGfx_ImageTypeE HWCGfx_ImageTypeE_ImageTypeE_MAX = HWCGfx_ImageTypeE_RGB16bit;
constexpr int HWCGfx_ImageTypeE_ImageTypeE_ARRAYSIZE = HWCGfx_ImageTypeE_ImageTypeE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HWCGfx_ImageTypeE_descriptor();
template<typename T>
inline const std::string& HWCGfx_ImageTypeE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HWCGfx_ImageTypeE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HWCGfx_ImageTypeE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HWCGfx_ImageTypeE_descriptor(), enum_t_value);
}
inline bool HWCGfx_ImageTypeE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HWCGfx_ImageTypeE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HWCGfx_ImageTypeE>(
    HWCGfx_ImageTypeE_descriptor(), name, value);
}
enum ImgConvert_FileTypeE : int {
  ImgConvert_FileTypeE_PNG = 0,
  ImgConvert_FileTypeE_JPEG = 1,
  ImgConvert_FileTypeE_ImgConvert_FileTypeE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImgConvert_FileTypeE_ImgConvert_FileTypeE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImgConvert_FileTypeE_IsValid(int value);
constexpr ImgConvert_FileTypeE ImgConvert_FileTypeE_FileTypeE_MIN = ImgConvert_FileTypeE_PNG;
constexpr ImgConvert_FileTypeE ImgConvert_FileTypeE_FileTypeE_MAX = ImgConvert_FileTypeE_JPEG;
constexpr int ImgConvert_FileTypeE_FileTypeE_ARRAYSIZE = ImgConvert_FileTypeE_FileTypeE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImgConvert_FileTypeE_descriptor();
template<typename T>
inline const std::string& ImgConvert_FileTypeE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImgConvert_FileTypeE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImgConvert_FileTypeE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImgConvert_FileTypeE_descriptor(), enum_t_value);
}
inline bool ImgConvert_FileTypeE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImgConvert_FileTypeE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImgConvert_FileTypeE>(
    ImgConvert_FileTypeE_descriptor(), name, value);
}
enum ImgConvert_ScalingE : int {
  ImgConvert_ScalingE_FILL = 0,
  ImgConvert_ScalingE_FIT = 1,
  ImgConvert_ScalingE_CROP = 2,
  ImgConvert_ScalingE_ImgConvert_ScalingE_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ImgConvert_ScalingE_ImgConvert_ScalingE_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ImgConvert_ScalingE_IsValid(int value);
constexpr ImgConvert_ScalingE ImgConvert_ScalingE_ScalingE_MIN = ImgConvert_ScalingE_FILL;
constexpr ImgConvert_ScalingE ImgConvert_ScalingE_ScalingE_MAX = ImgConvert_ScalingE_CROP;
constexpr int ImgConvert_ScalingE_ScalingE_ARRAYSIZE = ImgConvert_ScalingE_ScalingE_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ImgConvert_ScalingE_descriptor();
template<typename T>
inline const std::string& ImgConvert_ScalingE_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ImgConvert_ScalingE>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ImgConvert_ScalingE_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ImgConvert_ScalingE_descriptor(), enum_t_value);
}
inline bool ImgConvert_ScalingE_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ImgConvert_ScalingE* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ImgConvert_ScalingE>(
    ImgConvert_ScalingE_descriptor(), name, value);
}
enum OutboundMessage_FlowMsg : int {
  OutboundMessage_FlowMsg_NONE = 0,
  OutboundMessage_FlowMsg_PING = 1,
  OutboundMessage_FlowMsg_ACK = 2,
  OutboundMessage_FlowMsg_NACK = 3,
  OutboundMessage_FlowMsg_BSY = 4,
  OutboundMessage_FlowMsg_RDY = 5,
  OutboundMessage_FlowMsg_HELLO = 100,
  OutboundMessage_FlowMsg_OutboundMessage_FlowMsg_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  OutboundMessage_FlowMsg_OutboundMessage_FlowMsg_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool OutboundMessage_FlowMsg_IsValid(int value);
constexpr OutboundMessage_FlowMsg OutboundMessage_FlowMsg_FlowMsg_MIN = OutboundMessage_FlowMsg_NONE;
constexpr OutboundMessage_FlowMsg OutboundMessage_FlowMsg_FlowMsg_MAX = OutboundMessage_FlowMsg_HELLO;
constexpr int OutboundMessage_FlowMsg_FlowMsg_ARRAYSIZE = OutboundMessage_FlowMsg_FlowMsg_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OutboundMessage_FlowMsg_descriptor();
template<typename T>
inline const std::string& OutboundMessage_FlowMsg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OutboundMessage_FlowMsg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OutboundMessage_FlowMsg_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OutboundMessage_FlowMsg_descriptor(), enum_t_value);
}
inline bool OutboundMessage_FlowMsg_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OutboundMessage_FlowMsg* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OutboundMessage_FlowMsg>(
    OutboundMessage_FlowMsg_descriptor(), name, value);
}
enum BinaryEvent_EdgeID : int {
  BinaryEvent_EdgeID_UNKNOWN = 0,
  BinaryEvent_EdgeID_TOP = 1,
  BinaryEvent_EdgeID_LEFT = 2,
  BinaryEvent_EdgeID_BOTTOM = 4,
  BinaryEvent_EdgeID_RIGHT = 8,
  BinaryEvent_EdgeID_BinaryEvent_EdgeID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  BinaryEvent_EdgeID_BinaryEvent_EdgeID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool BinaryEvent_EdgeID_IsValid(int value);
constexpr BinaryEvent_EdgeID BinaryEvent_EdgeID_EdgeID_MIN = BinaryEvent_EdgeID_UNKNOWN;
constexpr BinaryEvent_EdgeID BinaryEvent_EdgeID_EdgeID_MAX = BinaryEvent_EdgeID_RIGHT;
constexpr int BinaryEvent_EdgeID_EdgeID_ARRAYSIZE = BinaryEvent_EdgeID_EdgeID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BinaryEvent_EdgeID_descriptor();
template<typename T>
inline const std::string& BinaryEvent_EdgeID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BinaryEvent_EdgeID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BinaryEvent_EdgeID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BinaryEvent_EdgeID_descriptor(), enum_t_value);
}
inline bool BinaryEvent_EdgeID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BinaryEvent_EdgeID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BinaryEvent_EdgeID>(
    BinaryEvent_EdgeID_descriptor(), name, value);
}
// ===================================================================

class InboundMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.InboundMessage) */ {
 public:
  inline InboundMessage() : InboundMessage(nullptr) {}
  virtual ~InboundMessage();

  InboundMessage(const InboundMessage& from);
  InboundMessage(InboundMessage&& from) noexcept
    : InboundMessage() {
    *this = ::std::move(from);
  }

  inline InboundMessage& operator=(const InboundMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline InboundMessage& operator=(InboundMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InboundMessage& default_instance();

  static inline const InboundMessage* internal_default_instance() {
    return reinterpret_cast<const InboundMessage*>(
               &_InboundMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(InboundMessage& a, InboundMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(InboundMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InboundMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InboundMessage* New() const final {
    return CreateMaybeMessage<InboundMessage>(nullptr);
  }

  InboundMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InboundMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InboundMessage& from);
  void MergeFrom(const InboundMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InboundMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.InboundMessage";
  }
  protected:
  explicit InboundMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef InboundMessage_FlowMsg FlowMsg;
  static constexpr FlowMsg NONE =
    InboundMessage_FlowMsg_NONE;
  static constexpr FlowMsg PING =
    InboundMessage_FlowMsg_PING;
  static constexpr FlowMsg ACK =
    InboundMessage_FlowMsg_ACK;
  static constexpr FlowMsg NACK =
    InboundMessage_FlowMsg_NACK;
  static inline bool FlowMsg_IsValid(int value) {
    return InboundMessage_FlowMsg_IsValid(value);
  }
  static constexpr FlowMsg FlowMsg_MIN =
    InboundMessage_FlowMsg_FlowMsg_MIN;
  static constexpr FlowMsg FlowMsg_MAX =
    InboundMessage_FlowMsg_FlowMsg_MAX;
  static constexpr int FlowMsg_ARRAYSIZE =
    InboundMessage_FlowMsg_FlowMsg_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FlowMsg_descriptor() {
    return InboundMessage_FlowMsg_descriptor();
  }
  template<typename T>
  static inline const std::string& FlowMsg_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FlowMsg>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FlowMsg_Name.");
    return InboundMessage_FlowMsg_Name(enum_t_value);
  }
  static inline bool FlowMsg_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FlowMsg* value) {
    return InboundMessage_FlowMsg_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStatesFieldNumber = 8,
    kCommandFieldNumber = 2,
    kFlowMessageFieldNumber = 1,
  };
  // repeated .ibeam_rawpanel.HWCState States = 8;
  int states_size() const;
  private:
  int _internal_states_size() const;
  public:
  void clear_states();
  ::ibeam_rawpanel::HWCState* mutable_states(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCState >*
      mutable_states();
  private:
  const ::ibeam_rawpanel::HWCState& _internal_states(int index) const;
  ::ibeam_rawpanel::HWCState* _internal_add_states();
  public:
  const ::ibeam_rawpanel::HWCState& states(int index) const;
  ::ibeam_rawpanel::HWCState* add_states();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCState >&
      states() const;

  // .ibeam_rawpanel.Command Command = 2;
  bool has_command() const;
  private:
  bool _internal_has_command() const;
  public:
  void clear_command();
  const ::ibeam_rawpanel::Command& command() const;
  ::ibeam_rawpanel::Command* release_command();
  ::ibeam_rawpanel::Command* mutable_command();
  void set_allocated_command(::ibeam_rawpanel::Command* command);
  private:
  const ::ibeam_rawpanel::Command& _internal_command() const;
  ::ibeam_rawpanel::Command* _internal_mutable_command();
  public:
  void unsafe_arena_set_allocated_command(
      ::ibeam_rawpanel::Command* command);
  ::ibeam_rawpanel::Command* unsafe_arena_release_command();

  // .ibeam_rawpanel.InboundMessage.FlowMsg FlowMessage = 1;
  void clear_flowmessage();
  ::ibeam_rawpanel::InboundMessage_FlowMsg flowmessage() const;
  void set_flowmessage(::ibeam_rawpanel::InboundMessage_FlowMsg value);
  private:
  ::ibeam_rawpanel::InboundMessage_FlowMsg _internal_flowmessage() const;
  void _internal_set_flowmessage(::ibeam_rawpanel::InboundMessage_FlowMsg value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.InboundMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCState > states_;
  ::ibeam_rawpanel::Command* command_;
  int flowmessage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class Command PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.Command) */ {
 public:
  inline Command() : Command(nullptr) {}
  virtual ~Command();

  Command(const Command& from);
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  inline Command& operator=(Command&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Command& default_instance();

  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }
  inline void Swap(Command* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Command* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const final {
    return CreateMaybeMessage<Command>(nullptr);
  }

  Command* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Command>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Command* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.Command";
  }
  protected:
  explicit Command(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetSleepTimeoutFieldNumber = 21,
    kSetWebserverEnabledFieldNumber = 22,
    kPanelBrightnessFieldNumber = 23,
    kActivatePanelFieldNumber = 1,
    kSendPanelInfoFieldNumber = 2,
    kSendPanelTopologyFieldNumber = 3,
    kReportHWCavailabilityFieldNumber = 4,
    kSendBurninProfileFieldNumber = 6,
    kClearAllFieldNumber = 10,
    kClearLEDsFieldNumber = 11,
    kClearDisplaysFieldNumber = 12,
    kWakeUpFieldNumber = 5,
    kGetSleepTimeoutFieldNumber = 20,
  };
  // .ibeam_rawpanel.SleepTimeout SetSleepTimeout = 21;
  bool has_setsleeptimeout() const;
  private:
  bool _internal_has_setsleeptimeout() const;
  public:
  void clear_setsleeptimeout();
  const ::ibeam_rawpanel::SleepTimeout& setsleeptimeout() const;
  ::ibeam_rawpanel::SleepTimeout* release_setsleeptimeout();
  ::ibeam_rawpanel::SleepTimeout* mutable_setsleeptimeout();
  void set_allocated_setsleeptimeout(::ibeam_rawpanel::SleepTimeout* setsleeptimeout);
  private:
  const ::ibeam_rawpanel::SleepTimeout& _internal_setsleeptimeout() const;
  ::ibeam_rawpanel::SleepTimeout* _internal_mutable_setsleeptimeout();
  public:
  void unsafe_arena_set_allocated_setsleeptimeout(
      ::ibeam_rawpanel::SleepTimeout* setsleeptimeout);
  ::ibeam_rawpanel::SleepTimeout* unsafe_arena_release_setsleeptimeout();

  // .ibeam_rawpanel.WebserverState SetWebserverEnabled = 22;
  bool has_setwebserverenabled() const;
  private:
  bool _internal_has_setwebserverenabled() const;
  public:
  void clear_setwebserverenabled();
  const ::ibeam_rawpanel::WebserverState& setwebserverenabled() const;
  ::ibeam_rawpanel::WebserverState* release_setwebserverenabled();
  ::ibeam_rawpanel::WebserverState* mutable_setwebserverenabled();
  void set_allocated_setwebserverenabled(::ibeam_rawpanel::WebserverState* setwebserverenabled);
  private:
  const ::ibeam_rawpanel::WebserverState& _internal_setwebserverenabled() const;
  ::ibeam_rawpanel::WebserverState* _internal_mutable_setwebserverenabled();
  public:
  void unsafe_arena_set_allocated_setwebserverenabled(
      ::ibeam_rawpanel::WebserverState* setwebserverenabled);
  ::ibeam_rawpanel::WebserverState* unsafe_arena_release_setwebserverenabled();

  // .ibeam_rawpanel.Brightness PanelBrightness = 23;
  bool has_panelbrightness() const;
  private:
  bool _internal_has_panelbrightness() const;
  public:
  void clear_panelbrightness();
  const ::ibeam_rawpanel::Brightness& panelbrightness() const;
  ::ibeam_rawpanel::Brightness* release_panelbrightness();
  ::ibeam_rawpanel::Brightness* mutable_panelbrightness();
  void set_allocated_panelbrightness(::ibeam_rawpanel::Brightness* panelbrightness);
  private:
  const ::ibeam_rawpanel::Brightness& _internal_panelbrightness() const;
  ::ibeam_rawpanel::Brightness* _internal_mutable_panelbrightness();
  public:
  void unsafe_arena_set_allocated_panelbrightness(
      ::ibeam_rawpanel::Brightness* panelbrightness);
  ::ibeam_rawpanel::Brightness* unsafe_arena_release_panelbrightness();

  // bool ActivatePanel = 1;
  void clear_activatepanel();
  bool activatepanel() const;
  void set_activatepanel(bool value);
  private:
  bool _internal_activatepanel() const;
  void _internal_set_activatepanel(bool value);
  public:

  // bool SendPanelInfo = 2;
  void clear_sendpanelinfo();
  bool sendpanelinfo() const;
  void set_sendpanelinfo(bool value);
  private:
  bool _internal_sendpanelinfo() const;
  void _internal_set_sendpanelinfo(bool value);
  public:

  // bool SendPanelTopology = 3;
  void clear_sendpaneltopology();
  bool sendpaneltopology() const;
  void set_sendpaneltopology(bool value);
  private:
  bool _internal_sendpaneltopology() const;
  void _internal_set_sendpaneltopology(bool value);
  public:

  // bool ReportHWCavailability = 4;
  void clear_reporthwcavailability();
  bool reporthwcavailability() const;
  void set_reporthwcavailability(bool value);
  private:
  bool _internal_reporthwcavailability() const;
  void _internal_set_reporthwcavailability(bool value);
  public:

  // bool SendBurninProfile = 6;
  void clear_sendburninprofile();
  bool sendburninprofile() const;
  void set_sendburninprofile(bool value);
  private:
  bool _internal_sendburninprofile() const;
  void _internal_set_sendburninprofile(bool value);
  public:

  // bool ClearAll = 10;
  void clear_clearall();
  bool clearall() const;
  void set_clearall(bool value);
  private:
  bool _internal_clearall() const;
  void _internal_set_clearall(bool value);
  public:

  // bool ClearLEDs = 11;
  void clear_clearleds();
  bool clearleds() const;
  void set_clearleds(bool value);
  private:
  bool _internal_clearleds() const;
  void _internal_set_clearleds(bool value);
  public:

  // bool ClearDisplays = 12;
  void clear_cleardisplays();
  bool cleardisplays() const;
  void set_cleardisplays(bool value);
  private:
  bool _internal_cleardisplays() const;
  void _internal_set_cleardisplays(bool value);
  public:

  // bool WakeUp = 5;
  void clear_wakeup();
  bool wakeup() const;
  void set_wakeup(bool value);
  private:
  bool _internal_wakeup() const;
  void _internal_set_wakeup(bool value);
  public:

  // bool GetSleepTimeout = 20;
  void clear_getsleeptimeout();
  bool getsleeptimeout() const;
  void set_getsleeptimeout(bool value);
  private:
  bool _internal_getsleeptimeout() const;
  void _internal_set_getsleeptimeout(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.Command)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ibeam_rawpanel::SleepTimeout* setsleeptimeout_;
  ::ibeam_rawpanel::WebserverState* setwebserverenabled_;
  ::ibeam_rawpanel::Brightness* panelbrightness_;
  bool activatepanel_;
  bool sendpanelinfo_;
  bool sendpaneltopology_;
  bool reporthwcavailability_;
  bool sendburninprofile_;
  bool clearall_;
  bool clearleds_;
  bool cleardisplays_;
  bool wakeup_;
  bool getsleeptimeout_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class SleepTimeout PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.SleepTimeout) */ {
 public:
  inline SleepTimeout() : SleepTimeout(nullptr) {}
  virtual ~SleepTimeout();

  SleepTimeout(const SleepTimeout& from);
  SleepTimeout(SleepTimeout&& from) noexcept
    : SleepTimeout() {
    *this = ::std::move(from);
  }

  inline SleepTimeout& operator=(const SleepTimeout& from) {
    CopyFrom(from);
    return *this;
  }
  inline SleepTimeout& operator=(SleepTimeout&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SleepTimeout& default_instance();

  static inline const SleepTimeout* internal_default_instance() {
    return reinterpret_cast<const SleepTimeout*>(
               &_SleepTimeout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SleepTimeout& a, SleepTimeout& b) {
    a.Swap(&b);
  }
  inline void Swap(SleepTimeout* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SleepTimeout* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SleepTimeout* New() const final {
    return CreateMaybeMessage<SleepTimeout>(nullptr);
  }

  SleepTimeout* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SleepTimeout>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SleepTimeout& from);
  void MergeFrom(const SleepTimeout& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SleepTimeout* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.SleepTimeout";
  }
  protected:
  explicit SleepTimeout(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 Value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.SleepTimeout)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class WebserverState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.WebserverState) */ {
 public:
  inline WebserverState() : WebserverState(nullptr) {}
  virtual ~WebserverState();

  WebserverState(const WebserverState& from);
  WebserverState(WebserverState&& from) noexcept
    : WebserverState() {
    *this = ::std::move(from);
  }

  inline WebserverState& operator=(const WebserverState& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebserverState& operator=(WebserverState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WebserverState& default_instance();

  static inline const WebserverState* internal_default_instance() {
    return reinterpret_cast<const WebserverState*>(
               &_WebserverState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(WebserverState& a, WebserverState& b) {
    a.Swap(&b);
  }
  inline void Swap(WebserverState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebserverState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WebserverState* New() const final {
    return CreateMaybeMessage<WebserverState>(nullptr);
  }

  WebserverState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WebserverState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WebserverState& from);
  void MergeFrom(const WebserverState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WebserverState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.WebserverState";
  }
  protected:
  explicit WebserverState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // bool Enabled = 1;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.WebserverState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool enabled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class Brightness PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.Brightness) */ {
 public:
  inline Brightness() : Brightness(nullptr) {}
  virtual ~Brightness();

  Brightness(const Brightness& from);
  Brightness(Brightness&& from) noexcept
    : Brightness() {
    *this = ::std::move(from);
  }

  inline Brightness& operator=(const Brightness& from) {
    CopyFrom(from);
    return *this;
  }
  inline Brightness& operator=(Brightness&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Brightness& default_instance();

  static inline const Brightness* internal_default_instance() {
    return reinterpret_cast<const Brightness*>(
               &_Brightness_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Brightness& a, Brightness& b) {
    a.Swap(&b);
  }
  inline void Swap(Brightness* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Brightness* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Brightness* New() const final {
    return CreateMaybeMessage<Brightness>(nullptr);
  }

  Brightness* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Brightness>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Brightness& from);
  void MergeFrom(const Brightness& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Brightness* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.Brightness";
  }
  protected:
  explicit Brightness(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOLEDsFieldNumber = 1,
    kLEDsFieldNumber = 2,
  };
  // uint32 OLEDs = 1;
  void clear_oleds();
  ::PROTOBUF_NAMESPACE_ID::uint32 oleds() const;
  void set_oleds(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_oleds() const;
  void _internal_set_oleds(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 LEDs = 2;
  void clear_leds();
  ::PROTOBUF_NAMESPACE_ID::uint32 leds() const;
  void set_leds(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_leds() const;
  void _internal_set_leds(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.Brightness)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 oleds_;
  ::PROTOBUF_NAMESPACE_ID::uint32 leds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCState) */ {
 public:
  inline HWCState() : HWCState(nullptr) {}
  virtual ~HWCState();

  HWCState(const HWCState& from);
  HWCState(HWCState&& from) noexcept
    : HWCState() {
    *this = ::std::move(from);
  }

  inline HWCState& operator=(const HWCState& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCState& operator=(HWCState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCState& default_instance();

  static inline const HWCState* internal_default_instance() {
    return reinterpret_cast<const HWCState*>(
               &_HWCState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HWCState& a, HWCState& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCState* New() const final {
    return CreateMaybeMessage<HWCState>(nullptr);
  }

  HWCState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCState& from);
  void MergeFrom(const HWCState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCState";
  }
  protected:
  explicit HWCState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHWCIDsFieldNumber = 1,
    kHWCModeFieldNumber = 2,
    kHWCColorFieldNumber = 3,
    kHWCExtendedFieldNumber = 4,
    kHWCTextFieldNumber = 5,
    kHWCGfxFieldNumber = 6,
    kPublishRawADCValuesFieldNumber = 7,
  };
  // repeated uint32 HWCIDs = 1;
  int hwcids_size() const;
  private:
  int _internal_hwcids_size() const;
  public:
  void clear_hwcids();
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hwcids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_hwcids() const;
  void _internal_add_hwcids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_hwcids();
  public:
  ::PROTOBUF_NAMESPACE_ID::uint32 hwcids(int index) const;
  void set_hwcids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_hwcids(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      hwcids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_hwcids();

  // .ibeam_rawpanel.HWCMode HWCMode = 2;
  bool has_hwcmode() const;
  private:
  bool _internal_has_hwcmode() const;
  public:
  void clear_hwcmode();
  const ::ibeam_rawpanel::HWCMode& hwcmode() const;
  ::ibeam_rawpanel::HWCMode* release_hwcmode();
  ::ibeam_rawpanel::HWCMode* mutable_hwcmode();
  void set_allocated_hwcmode(::ibeam_rawpanel::HWCMode* hwcmode);
  private:
  const ::ibeam_rawpanel::HWCMode& _internal_hwcmode() const;
  ::ibeam_rawpanel::HWCMode* _internal_mutable_hwcmode();
  public:
  void unsafe_arena_set_allocated_hwcmode(
      ::ibeam_rawpanel::HWCMode* hwcmode);
  ::ibeam_rawpanel::HWCMode* unsafe_arena_release_hwcmode();

  // .ibeam_rawpanel.HWCColor HWCColor = 3;
  bool has_hwccolor() const;
  private:
  bool _internal_has_hwccolor() const;
  public:
  void clear_hwccolor();
  const ::ibeam_rawpanel::HWCColor& hwccolor() const;
  ::ibeam_rawpanel::HWCColor* release_hwccolor();
  ::ibeam_rawpanel::HWCColor* mutable_hwccolor();
  void set_allocated_hwccolor(::ibeam_rawpanel::HWCColor* hwccolor);
  private:
  const ::ibeam_rawpanel::HWCColor& _internal_hwccolor() const;
  ::ibeam_rawpanel::HWCColor* _internal_mutable_hwccolor();
  public:
  void unsafe_arena_set_allocated_hwccolor(
      ::ibeam_rawpanel::HWCColor* hwccolor);
  ::ibeam_rawpanel::HWCColor* unsafe_arena_release_hwccolor();

  // .ibeam_rawpanel.HWCExtended HWCExtended = 4;
  bool has_hwcextended() const;
  private:
  bool _internal_has_hwcextended() const;
  public:
  void clear_hwcextended();
  const ::ibeam_rawpanel::HWCExtended& hwcextended() const;
  ::ibeam_rawpanel::HWCExtended* release_hwcextended();
  ::ibeam_rawpanel::HWCExtended* mutable_hwcextended();
  void set_allocated_hwcextended(::ibeam_rawpanel::HWCExtended* hwcextended);
  private:
  const ::ibeam_rawpanel::HWCExtended& _internal_hwcextended() const;
  ::ibeam_rawpanel::HWCExtended* _internal_mutable_hwcextended();
  public:
  void unsafe_arena_set_allocated_hwcextended(
      ::ibeam_rawpanel::HWCExtended* hwcextended);
  ::ibeam_rawpanel::HWCExtended* unsafe_arena_release_hwcextended();

  // .ibeam_rawpanel.HWCText HWCText = 5;
  bool has_hwctext() const;
  private:
  bool _internal_has_hwctext() const;
  public:
  void clear_hwctext();
  const ::ibeam_rawpanel::HWCText& hwctext() const;
  ::ibeam_rawpanel::HWCText* release_hwctext();
  ::ibeam_rawpanel::HWCText* mutable_hwctext();
  void set_allocated_hwctext(::ibeam_rawpanel::HWCText* hwctext);
  private:
  const ::ibeam_rawpanel::HWCText& _internal_hwctext() const;
  ::ibeam_rawpanel::HWCText* _internal_mutable_hwctext();
  public:
  void unsafe_arena_set_allocated_hwctext(
      ::ibeam_rawpanel::HWCText* hwctext);
  ::ibeam_rawpanel::HWCText* unsafe_arena_release_hwctext();

  // .ibeam_rawpanel.HWCGfx HWCGfx = 6;
  bool has_hwcgfx() const;
  private:
  bool _internal_has_hwcgfx() const;
  public:
  void clear_hwcgfx();
  const ::ibeam_rawpanel::HWCGfx& hwcgfx() const;
  ::ibeam_rawpanel::HWCGfx* release_hwcgfx();
  ::ibeam_rawpanel::HWCGfx* mutable_hwcgfx();
  void set_allocated_hwcgfx(::ibeam_rawpanel::HWCGfx* hwcgfx);
  private:
  const ::ibeam_rawpanel::HWCGfx& _internal_hwcgfx() const;
  ::ibeam_rawpanel::HWCGfx* _internal_mutable_hwcgfx();
  public:
  void unsafe_arena_set_allocated_hwcgfx(
      ::ibeam_rawpanel::HWCGfx* hwcgfx);
  ::ibeam_rawpanel::HWCGfx* unsafe_arena_release_hwcgfx();

  // .ibeam_rawpanel.PublishRawADCValues PublishRawADCValues = 7;
  bool has_publishrawadcvalues() const;
  private:
  bool _internal_has_publishrawadcvalues() const;
  public:
  void clear_publishrawadcvalues();
  const ::ibeam_rawpanel::PublishRawADCValues& publishrawadcvalues() const;
  ::ibeam_rawpanel::PublishRawADCValues* release_publishrawadcvalues();
  ::ibeam_rawpanel::PublishRawADCValues* mutable_publishrawadcvalues();
  void set_allocated_publishrawadcvalues(::ibeam_rawpanel::PublishRawADCValues* publishrawadcvalues);
  private:
  const ::ibeam_rawpanel::PublishRawADCValues& _internal_publishrawadcvalues() const;
  ::ibeam_rawpanel::PublishRawADCValues* _internal_mutable_publishrawadcvalues();
  public:
  void unsafe_arena_set_allocated_publishrawadcvalues(
      ::ibeam_rawpanel::PublishRawADCValues* publishrawadcvalues);
  ::ibeam_rawpanel::PublishRawADCValues* unsafe_arena_release_publishrawadcvalues();

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > hwcids_;
  mutable std::atomic<int> _hwcids_cached_byte_size_;
  ::ibeam_rawpanel::HWCMode* hwcmode_;
  ::ibeam_rawpanel::HWCColor* hwccolor_;
  ::ibeam_rawpanel::HWCExtended* hwcextended_;
  ::ibeam_rawpanel::HWCText* hwctext_;
  ::ibeam_rawpanel::HWCGfx* hwcgfx_;
  ::ibeam_rawpanel::PublishRawADCValues* publishrawadcvalues_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class PublishRawADCValues PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.PublishRawADCValues) */ {
 public:
  inline PublishRawADCValues() : PublishRawADCValues(nullptr) {}
  virtual ~PublishRawADCValues();

  PublishRawADCValues(const PublishRawADCValues& from);
  PublishRawADCValues(PublishRawADCValues&& from) noexcept
    : PublishRawADCValues() {
    *this = ::std::move(from);
  }

  inline PublishRawADCValues& operator=(const PublishRawADCValues& from) {
    CopyFrom(from);
    return *this;
  }
  inline PublishRawADCValues& operator=(PublishRawADCValues&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PublishRawADCValues& default_instance();

  static inline const PublishRawADCValues* internal_default_instance() {
    return reinterpret_cast<const PublishRawADCValues*>(
               &_PublishRawADCValues_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PublishRawADCValues& a, PublishRawADCValues& b) {
    a.Swap(&b);
  }
  inline void Swap(PublishRawADCValues* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PublishRawADCValues* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PublishRawADCValues* New() const final {
    return CreateMaybeMessage<PublishRawADCValues>(nullptr);
  }

  PublishRawADCValues* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PublishRawADCValues>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PublishRawADCValues& from);
  void MergeFrom(const PublishRawADCValues& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PublishRawADCValues* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.PublishRawADCValues";
  }
  protected:
  explicit PublishRawADCValues(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
  };
  // bool enable = 1;
  void clear_enable();
  bool enable() const;
  void set_enable(bool value);
  private:
  bool _internal_enable() const;
  void _internal_set_enable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.PublishRawADCValues)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool enable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCMode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCMode) */ {
 public:
  inline HWCMode() : HWCMode(nullptr) {}
  virtual ~HWCMode();

  HWCMode(const HWCMode& from);
  HWCMode(HWCMode&& from) noexcept
    : HWCMode() {
    *this = ::std::move(from);
  }

  inline HWCMode& operator=(const HWCMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCMode& operator=(HWCMode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCMode& default_instance();

  static inline const HWCMode* internal_default_instance() {
    return reinterpret_cast<const HWCMode*>(
               &_HWCMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HWCMode& a, HWCMode& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCMode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCMode* New() const final {
    return CreateMaybeMessage<HWCMode>(nullptr);
  }

  HWCMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCMode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCMode& from);
  void MergeFrom(const HWCMode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCMode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCMode";
  }
  protected:
  explicit HWCMode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCMode_StateE StateE;
  static constexpr StateE OFF =
    HWCMode_StateE_OFF;
  static constexpr StateE ON_YELLOW =
    HWCMode_StateE_ON_YELLOW;
  static constexpr StateE ON_RED =
    HWCMode_StateE_ON_RED;
  static constexpr StateE ON_GREEN =
    HWCMode_StateE_ON_GREEN;
  static constexpr StateE ON =
    HWCMode_StateE_ON;
  static constexpr StateE DIMMED =
    HWCMode_StateE_DIMMED;
  static inline bool StateE_IsValid(int value) {
    return HWCMode_StateE_IsValid(value);
  }
  static constexpr StateE StateE_MIN =
    HWCMode_StateE_StateE_MIN;
  static constexpr StateE StateE_MAX =
    HWCMode_StateE_StateE_MAX;
  static constexpr int StateE_ARRAYSIZE =
    HWCMode_StateE_StateE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StateE_descriptor() {
    return HWCMode_StateE_descriptor();
  }
  template<typename T>
  static inline const std::string& StateE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StateE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StateE_Name.");
    return HWCMode_StateE_Name(enum_t_value);
  }
  static inline bool StateE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StateE* value) {
    return HWCMode_StateE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 2,
    kBlinkPatternFieldNumber = 3,
    kOutputFieldNumber = 4,
  };
  // .ibeam_rawpanel.HWCMode.StateE State = 2;
  void clear_state();
  ::ibeam_rawpanel::HWCMode_StateE state() const;
  void set_state(::ibeam_rawpanel::HWCMode_StateE value);
  private:
  ::ibeam_rawpanel::HWCMode_StateE _internal_state() const;
  void _internal_set_state(::ibeam_rawpanel::HWCMode_StateE value);
  public:

  // uint32 BlinkPattern = 3;
  void clear_blinkpattern();
  ::PROTOBUF_NAMESPACE_ID::uint32 blinkpattern() const;
  void set_blinkpattern(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_blinkpattern() const;
  void _internal_set_blinkpattern(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool Output = 4;
  void clear_output();
  bool output() const;
  void set_output(bool value);
  private:
  bool _internal_output() const;
  void _internal_set_output(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int state_;
  ::PROTOBUF_NAMESPACE_ID::uint32 blinkpattern_;
  bool output_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCExtended PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCExtended) */ {
 public:
  inline HWCExtended() : HWCExtended(nullptr) {}
  virtual ~HWCExtended();

  HWCExtended(const HWCExtended& from);
  HWCExtended(HWCExtended&& from) noexcept
    : HWCExtended() {
    *this = ::std::move(from);
  }

  inline HWCExtended& operator=(const HWCExtended& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCExtended& operator=(HWCExtended&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCExtended& default_instance();

  static inline const HWCExtended* internal_default_instance() {
    return reinterpret_cast<const HWCExtended*>(
               &_HWCExtended_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(HWCExtended& a, HWCExtended& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCExtended* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCExtended* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCExtended* New() const final {
    return CreateMaybeMessage<HWCExtended>(nullptr);
  }

  HWCExtended* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCExtended>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCExtended& from);
  void MergeFrom(const HWCExtended& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCExtended* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCExtended";
  }
  protected:
  explicit HWCExtended(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCExtended_InterpretationE InterpretationE;
  static constexpr InterpretationE NONE =
    HWCExtended_InterpretationE_NONE;
  static constexpr InterpretationE STRENGTH =
    HWCExtended_InterpretationE_STRENGTH;
  static constexpr InterpretationE STEPS =
    HWCExtended_InterpretationE_STEPS;
  static constexpr InterpretationE VU =
    HWCExtended_InterpretationE_VU;
  static constexpr InterpretationE FADER =
    HWCExtended_InterpretationE_FADER;
  static inline bool InterpretationE_IsValid(int value) {
    return HWCExtended_InterpretationE_IsValid(value);
  }
  static constexpr InterpretationE InterpretationE_MIN =
    HWCExtended_InterpretationE_InterpretationE_MIN;
  static constexpr InterpretationE InterpretationE_MAX =
    HWCExtended_InterpretationE_InterpretationE_MAX;
  static constexpr int InterpretationE_ARRAYSIZE =
    HWCExtended_InterpretationE_InterpretationE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  InterpretationE_descriptor() {
    return HWCExtended_InterpretationE_descriptor();
  }
  template<typename T>
  static inline const std::string& InterpretationE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, InterpretationE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function InterpretationE_Name.");
    return HWCExtended_InterpretationE_Name(enum_t_value);
  }
  static inline bool InterpretationE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      InterpretationE* value) {
    return HWCExtended_InterpretationE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInterpretationFieldNumber = 2,
    kValueFieldNumber = 3,
  };
  // .ibeam_rawpanel.HWCExtended.InterpretationE Interpretation = 2;
  void clear_interpretation();
  ::ibeam_rawpanel::HWCExtended_InterpretationE interpretation() const;
  void set_interpretation(::ibeam_rawpanel::HWCExtended_InterpretationE value);
  private:
  ::ibeam_rawpanel::HWCExtended_InterpretationE _internal_interpretation() const;
  void _internal_set_interpretation(::ibeam_rawpanel::HWCExtended_InterpretationE value);
  public:

  // uint32 Value = 3;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCExtended)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int interpretation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCColor PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCColor) */ {
 public:
  inline HWCColor() : HWCColor(nullptr) {}
  virtual ~HWCColor();

  HWCColor(const HWCColor& from);
  HWCColor(HWCColor&& from) noexcept
    : HWCColor() {
    *this = ::std::move(from);
  }

  inline HWCColor& operator=(const HWCColor& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCColor& operator=(HWCColor&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCColor& default_instance();

  static inline const HWCColor* internal_default_instance() {
    return reinterpret_cast<const HWCColor*>(
               &_HWCColor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(HWCColor& a, HWCColor& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCColor* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCColor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCColor* New() const final {
    return CreateMaybeMessage<HWCColor>(nullptr);
  }

  HWCColor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCColor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCColor& from);
  void MergeFrom(const HWCColor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCColor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCColor";
  }
  protected:
  explicit HWCColor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorRGBFieldNumber = 1,
    kColorIndexFieldNumber = 2,
  };
  // .ibeam_rawpanel.ColorRGB ColorRGB = 1;
  bool has_colorrgb() const;
  private:
  bool _internal_has_colorrgb() const;
  public:
  void clear_colorrgb();
  const ::ibeam_rawpanel::ColorRGB& colorrgb() const;
  ::ibeam_rawpanel::ColorRGB* release_colorrgb();
  ::ibeam_rawpanel::ColorRGB* mutable_colorrgb();
  void set_allocated_colorrgb(::ibeam_rawpanel::ColorRGB* colorrgb);
  private:
  const ::ibeam_rawpanel::ColorRGB& _internal_colorrgb() const;
  ::ibeam_rawpanel::ColorRGB* _internal_mutable_colorrgb();
  public:
  void unsafe_arena_set_allocated_colorrgb(
      ::ibeam_rawpanel::ColorRGB* colorrgb);
  ::ibeam_rawpanel::ColorRGB* unsafe_arena_release_colorrgb();

  // .ibeam_rawpanel.ColorIndex ColorIndex = 2;
  bool has_colorindex() const;
  private:
  bool _internal_has_colorindex() const;
  public:
  void clear_colorindex();
  const ::ibeam_rawpanel::ColorIndex& colorindex() const;
  ::ibeam_rawpanel::ColorIndex* release_colorindex();
  ::ibeam_rawpanel::ColorIndex* mutable_colorindex();
  void set_allocated_colorindex(::ibeam_rawpanel::ColorIndex* colorindex);
  private:
  const ::ibeam_rawpanel::ColorIndex& _internal_colorindex() const;
  ::ibeam_rawpanel::ColorIndex* _internal_mutable_colorindex();
  public:
  void unsafe_arena_set_allocated_colorindex(
      ::ibeam_rawpanel::ColorIndex* colorindex);
  ::ibeam_rawpanel::ColorIndex* unsafe_arena_release_colorindex();

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCColor)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ibeam_rawpanel::ColorRGB* colorrgb_;
  ::ibeam_rawpanel::ColorIndex* colorindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class Color PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.Color) */ {
 public:
  inline Color() : Color(nullptr) {}
  virtual ~Color();

  Color(const Color& from);
  Color(Color&& from) noexcept
    : Color() {
    *this = ::std::move(from);
  }

  inline Color& operator=(const Color& from) {
    CopyFrom(from);
    return *this;
  }
  inline Color& operator=(Color&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Color& default_instance();

  static inline const Color* internal_default_instance() {
    return reinterpret_cast<const Color*>(
               &_Color_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Color& a, Color& b) {
    a.Swap(&b);
  }
  inline void Swap(Color* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Color* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Color* New() const final {
    return CreateMaybeMessage<Color>(nullptr);
  }

  Color* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Color>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Color& from);
  void MergeFrom(const Color& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Color* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.Color";
  }
  protected:
  explicit Color(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorRGBFieldNumber = 1,
    kColorIndexFieldNumber = 2,
  };
  // .ibeam_rawpanel.ColorRGB ColorRGB = 1;
  bool has_colorrgb() const;
  private:
  bool _internal_has_colorrgb() const;
  public:
  void clear_colorrgb();
  const ::ibeam_rawpanel::ColorRGB& colorrgb() const;
  ::ibeam_rawpanel::ColorRGB* release_colorrgb();
  ::ibeam_rawpanel::ColorRGB* mutable_colorrgb();
  void set_allocated_colorrgb(::ibeam_rawpanel::ColorRGB* colorrgb);
  private:
  const ::ibeam_rawpanel::ColorRGB& _internal_colorrgb() const;
  ::ibeam_rawpanel::ColorRGB* _internal_mutable_colorrgb();
  public:
  void unsafe_arena_set_allocated_colorrgb(
      ::ibeam_rawpanel::ColorRGB* colorrgb);
  ::ibeam_rawpanel::ColorRGB* unsafe_arena_release_colorrgb();

  // .ibeam_rawpanel.ColorIndex ColorIndex = 2;
  bool has_colorindex() const;
  private:
  bool _internal_has_colorindex() const;
  public:
  void clear_colorindex();
  const ::ibeam_rawpanel::ColorIndex& colorindex() const;
  ::ibeam_rawpanel::ColorIndex* release_colorindex();
  ::ibeam_rawpanel::ColorIndex* mutable_colorindex();
  void set_allocated_colorindex(::ibeam_rawpanel::ColorIndex* colorindex);
  private:
  const ::ibeam_rawpanel::ColorIndex& _internal_colorindex() const;
  ::ibeam_rawpanel::ColorIndex* _internal_mutable_colorindex();
  public:
  void unsafe_arena_set_allocated_colorindex(
      ::ibeam_rawpanel::ColorIndex* colorindex);
  ::ibeam_rawpanel::ColorIndex* unsafe_arena_release_colorindex();

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.Color)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ibeam_rawpanel::ColorRGB* colorrgb_;
  ::ibeam_rawpanel::ColorIndex* colorindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class ColorRGB PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.ColorRGB) */ {
 public:
  inline ColorRGB() : ColorRGB(nullptr) {}
  virtual ~ColorRGB();

  ColorRGB(const ColorRGB& from);
  ColorRGB(ColorRGB&& from) noexcept
    : ColorRGB() {
    *this = ::std::move(from);
  }

  inline ColorRGB& operator=(const ColorRGB& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorRGB& operator=(ColorRGB&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColorRGB& default_instance();

  static inline const ColorRGB* internal_default_instance() {
    return reinterpret_cast<const ColorRGB*>(
               &_ColorRGB_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ColorRGB& a, ColorRGB& b) {
    a.Swap(&b);
  }
  inline void Swap(ColorRGB* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorRGB* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColorRGB* New() const final {
    return CreateMaybeMessage<ColorRGB>(nullptr);
  }

  ColorRGB* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColorRGB>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColorRGB& from);
  void MergeFrom(const ColorRGB& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColorRGB* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.ColorRGB";
  }
  protected:
  explicit ColorRGB(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRedFieldNumber = 1,
    kGreenFieldNumber = 2,
    kBlueFieldNumber = 3,
  };
  // uint32 Red = 1;
  void clear_red();
  ::PROTOBUF_NAMESPACE_ID::uint32 red() const;
  void set_red(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_red() const;
  void _internal_set_red(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 Green = 2;
  void clear_green();
  ::PROTOBUF_NAMESPACE_ID::uint32 green() const;
  void set_green(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_green() const;
  void _internal_set_green(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 Blue = 3;
  void clear_blue();
  ::PROTOBUF_NAMESPACE_ID::uint32 blue() const;
  void set_blue(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_blue() const;
  void _internal_set_blue(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.ColorRGB)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 red_;
  ::PROTOBUF_NAMESPACE_ID::uint32 green_;
  ::PROTOBUF_NAMESPACE_ID::uint32 blue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class ColorIndex PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.ColorIndex) */ {
 public:
  inline ColorIndex() : ColorIndex(nullptr) {}
  virtual ~ColorIndex();

  ColorIndex(const ColorIndex& from);
  ColorIndex(ColorIndex&& from) noexcept
    : ColorIndex() {
    *this = ::std::move(from);
  }

  inline ColorIndex& operator=(const ColorIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColorIndex& operator=(ColorIndex&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColorIndex& default_instance();

  static inline const ColorIndex* internal_default_instance() {
    return reinterpret_cast<const ColorIndex*>(
               &_ColorIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ColorIndex& a, ColorIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(ColorIndex* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColorIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColorIndex* New() const final {
    return CreateMaybeMessage<ColorIndex>(nullptr);
  }

  ColorIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColorIndex>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColorIndex& from);
  void MergeFrom(const ColorIndex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColorIndex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.ColorIndex";
  }
  protected:
  explicit ColorIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ColorIndex_Colors Colors;
  static constexpr Colors DEFAULT =
    ColorIndex_Colors_DEFAULT;
  static constexpr Colors OFF =
    ColorIndex_Colors_OFF;
  static constexpr Colors WHITE =
    ColorIndex_Colors_WHITE;
  static constexpr Colors WARM =
    ColorIndex_Colors_WARM;
  static constexpr Colors RED =
    ColorIndex_Colors_RED;
  static constexpr Colors ROSE =
    ColorIndex_Colors_ROSE;
  static constexpr Colors PINK =
    ColorIndex_Colors_PINK;
  static constexpr Colors PURPLE =
    ColorIndex_Colors_PURPLE;
  static constexpr Colors AMBER =
    ColorIndex_Colors_AMBER;
  static constexpr Colors YELLOW =
    ColorIndex_Colors_YELLOW;
  static constexpr Colors DARKBLUE =
    ColorIndex_Colors_DARKBLUE;
  static constexpr Colors BLUE =
    ColorIndex_Colors_BLUE;
  static constexpr Colors ICE =
    ColorIndex_Colors_ICE;
  static constexpr Colors CYAN =
    ColorIndex_Colors_CYAN;
  static constexpr Colors SPRING =
    ColorIndex_Colors_SPRING;
  static constexpr Colors GREEN =
    ColorIndex_Colors_GREEN;
  static constexpr Colors MINT =
    ColorIndex_Colors_MINT;
  static inline bool Colors_IsValid(int value) {
    return ColorIndex_Colors_IsValid(value);
  }
  static constexpr Colors Colors_MIN =
    ColorIndex_Colors_Colors_MIN;
  static constexpr Colors Colors_MAX =
    ColorIndex_Colors_Colors_MAX;
  static constexpr int Colors_ARRAYSIZE =
    ColorIndex_Colors_Colors_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Colors_descriptor() {
    return ColorIndex_Colors_descriptor();
  }
  template<typename T>
  static inline const std::string& Colors_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Colors>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Colors_Name.");
    return ColorIndex_Colors_Name(enum_t_value);
  }
  static inline bool Colors_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Colors* value) {
    return ColorIndex_Colors_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // .ibeam_rawpanel.ColorIndex.Colors Index = 1;
  void clear_index();
  ::ibeam_rawpanel::ColorIndex_Colors index() const;
  void set_index(::ibeam_rawpanel::ColorIndex_Colors value);
  private:
  ::ibeam_rawpanel::ColorIndex_Colors _internal_index() const;
  void _internal_set_index(::ibeam_rawpanel::ColorIndex_Colors value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.ColorIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCText_ScaleM PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCText.ScaleM) */ {
 public:
  inline HWCText_ScaleM() : HWCText_ScaleM(nullptr) {}
  virtual ~HWCText_ScaleM();

  HWCText_ScaleM(const HWCText_ScaleM& from);
  HWCText_ScaleM(HWCText_ScaleM&& from) noexcept
    : HWCText_ScaleM() {
    *this = ::std::move(from);
  }

  inline HWCText_ScaleM& operator=(const HWCText_ScaleM& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCText_ScaleM& operator=(HWCText_ScaleM&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCText_ScaleM& default_instance();

  static inline const HWCText_ScaleM* internal_default_instance() {
    return reinterpret_cast<const HWCText_ScaleM*>(
               &_HWCText_ScaleM_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(HWCText_ScaleM& a, HWCText_ScaleM& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCText_ScaleM* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCText_ScaleM* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCText_ScaleM* New() const final {
    return CreateMaybeMessage<HWCText_ScaleM>(nullptr);
  }

  HWCText_ScaleM* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCText_ScaleM>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCText_ScaleM& from);
  void MergeFrom(const HWCText_ScaleM& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCText_ScaleM* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCText.ScaleM";
  }
  protected:
  explicit HWCText_ScaleM(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCText_ScaleM_ScaleTypeE ScaleTypeE;
  static constexpr ScaleTypeE ST_OFF =
    HWCText_ScaleM_ScaleTypeE_ST_OFF;
  static constexpr ScaleTypeE ST_STRENGTH =
    HWCText_ScaleM_ScaleTypeE_ST_STRENGTH;
  static constexpr ScaleTypeE ST_CENTER_MARKER =
    HWCText_ScaleM_ScaleTypeE_ST_CENTER_MARKER;
  static constexpr ScaleTypeE ST_CENTER_BAR =
    HWCText_ScaleM_ScaleTypeE_ST_CENTER_BAR;
  static inline bool ScaleTypeE_IsValid(int value) {
    return HWCText_ScaleM_ScaleTypeE_IsValid(value);
  }
  static constexpr ScaleTypeE ScaleTypeE_MIN =
    HWCText_ScaleM_ScaleTypeE_ScaleTypeE_MIN;
  static constexpr ScaleTypeE ScaleTypeE_MAX =
    HWCText_ScaleM_ScaleTypeE_ScaleTypeE_MAX;
  static constexpr int ScaleTypeE_ARRAYSIZE =
    HWCText_ScaleM_ScaleTypeE_ScaleTypeE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScaleTypeE_descriptor() {
    return HWCText_ScaleM_ScaleTypeE_descriptor();
  }
  template<typename T>
  static inline const std::string& ScaleTypeE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScaleTypeE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScaleTypeE_Name.");
    return HWCText_ScaleM_ScaleTypeE_Name(enum_t_value);
  }
  static inline bool ScaleTypeE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScaleTypeE* value) {
    return HWCText_ScaleM_ScaleTypeE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kScaleTypeFieldNumber = 1,
    kRangeLowFieldNumber = 2,
    kRangeHighFieldNumber = 3,
    kLimitLowFieldNumber = 4,
    kLimitHighFieldNumber = 5,
  };
  // .ibeam_rawpanel.HWCText.ScaleM.ScaleTypeE ScaleType = 1;
  void clear_scaletype();
  ::ibeam_rawpanel::HWCText_ScaleM_ScaleTypeE scaletype() const;
  void set_scaletype(::ibeam_rawpanel::HWCText_ScaleM_ScaleTypeE value);
  private:
  ::ibeam_rawpanel::HWCText_ScaleM_ScaleTypeE _internal_scaletype() const;
  void _internal_set_scaletype(::ibeam_rawpanel::HWCText_ScaleM_ScaleTypeE value);
  public:

  // sint32 RangeLow = 2;
  void clear_rangelow();
  ::PROTOBUF_NAMESPACE_ID::int32 rangelow() const;
  void set_rangelow(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rangelow() const;
  void _internal_set_rangelow(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 RangeHigh = 3;
  void clear_rangehigh();
  ::PROTOBUF_NAMESPACE_ID::int32 rangehigh() const;
  void set_rangehigh(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rangehigh() const;
  void _internal_set_rangehigh(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 LimitLow = 4;
  void clear_limitlow();
  ::PROTOBUF_NAMESPACE_ID::int32 limitlow() const;
  void set_limitlow(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_limitlow() const;
  void _internal_set_limitlow(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 LimitHigh = 5;
  void clear_limithigh();
  ::PROTOBUF_NAMESPACE_ID::int32 limithigh() const;
  void set_limithigh(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_limithigh() const;
  void _internal_set_limithigh(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCText.ScaleM)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int scaletype_;
  ::PROTOBUF_NAMESPACE_ID::int32 rangelow_;
  ::PROTOBUF_NAMESPACE_ID::int32 rangehigh_;
  ::PROTOBUF_NAMESPACE_ID::int32 limitlow_;
  ::PROTOBUF_NAMESPACE_ID::int32 limithigh_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCText_TextStyle_Font PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCText.TextStyle.Font) */ {
 public:
  inline HWCText_TextStyle_Font() : HWCText_TextStyle_Font(nullptr) {}
  virtual ~HWCText_TextStyle_Font();

  HWCText_TextStyle_Font(const HWCText_TextStyle_Font& from);
  HWCText_TextStyle_Font(HWCText_TextStyle_Font&& from) noexcept
    : HWCText_TextStyle_Font() {
    *this = ::std::move(from);
  }

  inline HWCText_TextStyle_Font& operator=(const HWCText_TextStyle_Font& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCText_TextStyle_Font& operator=(HWCText_TextStyle_Font&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCText_TextStyle_Font& default_instance();

  static inline const HWCText_TextStyle_Font* internal_default_instance() {
    return reinterpret_cast<const HWCText_TextStyle_Font*>(
               &_HWCText_TextStyle_Font_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(HWCText_TextStyle_Font& a, HWCText_TextStyle_Font& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCText_TextStyle_Font* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCText_TextStyle_Font* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCText_TextStyle_Font* New() const final {
    return CreateMaybeMessage<HWCText_TextStyle_Font>(nullptr);
  }

  HWCText_TextStyle_Font* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCText_TextStyle_Font>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCText_TextStyle_Font& from);
  void MergeFrom(const HWCText_TextStyle_Font& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCText_TextStyle_Font* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCText.TextStyle.Font";
  }
  protected:
  explicit HWCText_TextStyle_Font(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCText_TextStyle_Font_FontFaceE FontFaceE;
  static constexpr FontFaceE ST_DEFAULT =
    HWCText_TextStyle_Font_FontFaceE_ST_DEFAULT;
  static constexpr FontFaceE ST_BOLD =
    HWCText_TextStyle_Font_FontFaceE_ST_BOLD;
  static constexpr FontFaceE ST_TINY =
    HWCText_TextStyle_Font_FontFaceE_ST_TINY;
  static inline bool FontFaceE_IsValid(int value) {
    return HWCText_TextStyle_Font_FontFaceE_IsValid(value);
  }
  static constexpr FontFaceE FontFaceE_MIN =
    HWCText_TextStyle_Font_FontFaceE_FontFaceE_MIN;
  static constexpr FontFaceE FontFaceE_MAX =
    HWCText_TextStyle_Font_FontFaceE_FontFaceE_MAX;
  static constexpr int FontFaceE_ARRAYSIZE =
    HWCText_TextStyle_Font_FontFaceE_FontFaceE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FontFaceE_descriptor() {
    return HWCText_TextStyle_Font_FontFaceE_descriptor();
  }
  template<typename T>
  static inline const std::string& FontFaceE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FontFaceE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FontFaceE_Name.");
    return HWCText_TextStyle_Font_FontFaceE_Name(enum_t_value);
  }
  static inline bool FontFaceE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FontFaceE* value) {
    return HWCText_TextStyle_Font_FontFaceE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFontFaceFieldNumber = 1,
    kTextHeightFieldNumber = 2,
    kTextWidthFieldNumber = 3,
  };
  // .ibeam_rawpanel.HWCText.TextStyle.Font.FontFaceE FontFace = 1;
  void clear_fontface();
  ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFaceE fontface() const;
  void set_fontface(::ibeam_rawpanel::HWCText_TextStyle_Font_FontFaceE value);
  private:
  ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFaceE _internal_fontface() const;
  void _internal_set_fontface(::ibeam_rawpanel::HWCText_TextStyle_Font_FontFaceE value);
  public:

  // uint32 TextHeight = 2;
  void clear_textheight();
  ::PROTOBUF_NAMESPACE_ID::uint32 textheight() const;
  void set_textheight(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_textheight() const;
  void _internal_set_textheight(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 TextWidth = 3;
  void clear_textwidth();
  ::PROTOBUF_NAMESPACE_ID::uint32 textwidth() const;
  void set_textwidth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_textwidth() const;
  void _internal_set_textwidth(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCText.TextStyle.Font)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int fontface_;
  ::PROTOBUF_NAMESPACE_ID::uint32 textheight_;
  ::PROTOBUF_NAMESPACE_ID::uint32 textwidth_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCText_TextStyle PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCText.TextStyle) */ {
 public:
  inline HWCText_TextStyle() : HWCText_TextStyle(nullptr) {}
  virtual ~HWCText_TextStyle();

  HWCText_TextStyle(const HWCText_TextStyle& from);
  HWCText_TextStyle(HWCText_TextStyle&& from) noexcept
    : HWCText_TextStyle() {
    *this = ::std::move(from);
  }

  inline HWCText_TextStyle& operator=(const HWCText_TextStyle& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCText_TextStyle& operator=(HWCText_TextStyle&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCText_TextStyle& default_instance();

  static inline const HWCText_TextStyle* internal_default_instance() {
    return reinterpret_cast<const HWCText_TextStyle*>(
               &_HWCText_TextStyle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HWCText_TextStyle& a, HWCText_TextStyle& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCText_TextStyle* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCText_TextStyle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCText_TextStyle* New() const final {
    return CreateMaybeMessage<HWCText_TextStyle>(nullptr);
  }

  HWCText_TextStyle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCText_TextStyle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCText_TextStyle& from);
  void MergeFrom(const HWCText_TextStyle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCText_TextStyle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCText.TextStyle";
  }
  protected:
  explicit HWCText_TextStyle(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCText_TextStyle_Font Font;

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFontFieldNumber = 1,
    kTextFontFieldNumber = 2,
    kFixedWidthFieldNumber = 3,
    kTitleBarPaddingFieldNumber = 4,
    kExtraCharacterSpacingFieldNumber = 5,
    kUnformattedFontSizeFieldNumber = 6,
  };
  // .ibeam_rawpanel.HWCText.TextStyle.Font TitleFont = 1;
  bool has_titlefont() const;
  private:
  bool _internal_has_titlefont() const;
  public:
  void clear_titlefont();
  const ::ibeam_rawpanel::HWCText_TextStyle_Font& titlefont() const;
  ::ibeam_rawpanel::HWCText_TextStyle_Font* release_titlefont();
  ::ibeam_rawpanel::HWCText_TextStyle_Font* mutable_titlefont();
  void set_allocated_titlefont(::ibeam_rawpanel::HWCText_TextStyle_Font* titlefont);
  private:
  const ::ibeam_rawpanel::HWCText_TextStyle_Font& _internal_titlefont() const;
  ::ibeam_rawpanel::HWCText_TextStyle_Font* _internal_mutable_titlefont();
  public:
  void unsafe_arena_set_allocated_titlefont(
      ::ibeam_rawpanel::HWCText_TextStyle_Font* titlefont);
  ::ibeam_rawpanel::HWCText_TextStyle_Font* unsafe_arena_release_titlefont();

  // .ibeam_rawpanel.HWCText.TextStyle.Font TextFont = 2;
  bool has_textfont() const;
  private:
  bool _internal_has_textfont() const;
  public:
  void clear_textfont();
  const ::ibeam_rawpanel::HWCText_TextStyle_Font& textfont() const;
  ::ibeam_rawpanel::HWCText_TextStyle_Font* release_textfont();
  ::ibeam_rawpanel::HWCText_TextStyle_Font* mutable_textfont();
  void set_allocated_textfont(::ibeam_rawpanel::HWCText_TextStyle_Font* textfont);
  private:
  const ::ibeam_rawpanel::HWCText_TextStyle_Font& _internal_textfont() const;
  ::ibeam_rawpanel::HWCText_TextStyle_Font* _internal_mutable_textfont();
  public:
  void unsafe_arena_set_allocated_textfont(
      ::ibeam_rawpanel::HWCText_TextStyle_Font* textfont);
  ::ibeam_rawpanel::HWCText_TextStyle_Font* unsafe_arena_release_textfont();

  // bool FixedWidth = 3;
  void clear_fixedwidth();
  bool fixedwidth() const;
  void set_fixedwidth(bool value);
  private:
  bool _internal_fixedwidth() const;
  void _internal_set_fixedwidth(bool value);
  public:

  // uint32 TitleBarPadding = 4;
  void clear_titlebarpadding();
  ::PROTOBUF_NAMESPACE_ID::uint32 titlebarpadding() const;
  void set_titlebarpadding(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_titlebarpadding() const;
  void _internal_set_titlebarpadding(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 ExtraCharacterSpacing = 5;
  void clear_extracharacterspacing();
  ::PROTOBUF_NAMESPACE_ID::uint32 extracharacterspacing() const;
  void set_extracharacterspacing(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_extracharacterspacing() const;
  void _internal_set_extracharacterspacing(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 UnformattedFontSize = 6;
  void clear_unformattedfontsize();
  ::PROTOBUF_NAMESPACE_ID::uint32 unformattedfontsize() const;
  void set_unformattedfontsize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_unformattedfontsize() const;
  void _internal_set_unformattedfontsize(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCText.TextStyle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ibeam_rawpanel::HWCText_TextStyle_Font* titlefont_;
  ::ibeam_rawpanel::HWCText_TextStyle_Font* textfont_;
  bool fixedwidth_;
  ::PROTOBUF_NAMESPACE_ID::uint32 titlebarpadding_;
  ::PROTOBUF_NAMESPACE_ID::uint32 extracharacterspacing_;
  ::PROTOBUF_NAMESPACE_ID::uint32 unformattedfontsize_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCText PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCText) */ {
 public:
  inline HWCText() : HWCText(nullptr) {}
  virtual ~HWCText();

  HWCText(const HWCText& from);
  HWCText(HWCText&& from) noexcept
    : HWCText() {
    *this = ::std::move(from);
  }

  inline HWCText& operator=(const HWCText& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCText& operator=(HWCText&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCText& default_instance();

  static inline const HWCText* internal_default_instance() {
    return reinterpret_cast<const HWCText*>(
               &_HWCText_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HWCText& a, HWCText& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCText* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCText* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCText* New() const final {
    return CreateMaybeMessage<HWCText>(nullptr);
  }

  HWCText* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCText>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCText& from);
  void MergeFrom(const HWCText& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCText* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCText";
  }
  protected:
  explicit HWCText(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCText_ScaleM ScaleM;
  typedef HWCText_TextStyle TextStyle;

  typedef HWCText_FormattingE FormattingE;
  static constexpr FormattingE FMT_INTEGER =
    HWCText_FormattingE_FMT_INTEGER;
  static constexpr FormattingE FMT_FLOAT_2DEZ =
    HWCText_FormattingE_FMT_FLOAT_2DEZ;
  static constexpr FormattingE FMT_PERCENTAGE =
    HWCText_FormattingE_FMT_PERCENTAGE;
  static constexpr FormattingE FMT_DB =
    HWCText_FormattingE_FMT_DB;
  static constexpr FormattingE FMT_FRAMES =
    HWCText_FormattingE_FMT_FRAMES;
  static constexpr FormattingE FMT_ONEOVERX =
    HWCText_FormattingE_FMT_ONEOVERX;
  static constexpr FormattingE FMT_KELVIN =
    HWCText_FormattingE_FMT_KELVIN;
  static constexpr FormattingE FMT_HIDE =
    HWCText_FormattingE_FMT_HIDE;
  static constexpr FormattingE FMT_FLOAT_X_XXX =
    HWCText_FormattingE_FMT_FLOAT_X_XXX;
  static constexpr FormattingE FMT_FLOAT_XX_XX =
    HWCText_FormattingE_FMT_FLOAT_XX_XX;
  static constexpr FormattingE FMT_ONELINE =
    HWCText_FormattingE_FMT_ONELINE;
  static constexpr FormattingE FMT_TWOLINES =
    HWCText_FormattingE_FMT_TWOLINES;
  static constexpr FormattingE FMT_FLOAT_XXX_X =
    HWCText_FormattingE_FMT_FLOAT_XXX_X;
  static inline bool FormattingE_IsValid(int value) {
    return HWCText_FormattingE_IsValid(value);
  }
  static constexpr FormattingE FormattingE_MIN =
    HWCText_FormattingE_FormattingE_MIN;
  static constexpr FormattingE FormattingE_MAX =
    HWCText_FormattingE_FormattingE_MAX;
  static constexpr int FormattingE_ARRAYSIZE =
    HWCText_FormattingE_FormattingE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FormattingE_descriptor() {
    return HWCText_FormattingE_descriptor();
  }
  template<typename T>
  static inline const std::string& FormattingE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FormattingE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FormattingE_Name.");
    return HWCText_FormattingE_Name(enum_t_value);
  }
  static inline bool FormattingE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FormattingE* value) {
    return HWCText_FormattingE_Parse(name, value);
  }

  typedef HWCText_StateIconE StateIconE;
  static constexpr StateIconE SI_NONE =
    HWCText_StateIconE_SI_NONE;
  static constexpr StateIconE SI_FINE =
    HWCText_StateIconE_SI_FINE;
  static constexpr StateIconE SI_LOCK =
    HWCText_StateIconE_SI_LOCK;
  static constexpr StateIconE SI_NOACCESS =
    HWCText_StateIconE_SI_NOACCESS;
  static inline bool StateIconE_IsValid(int value) {
    return HWCText_StateIconE_IsValid(value);
  }
  static constexpr StateIconE StateIconE_MIN =
    HWCText_StateIconE_StateIconE_MIN;
  static constexpr StateIconE StateIconE_MAX =
    HWCText_StateIconE_StateIconE_MAX;
  static constexpr int StateIconE_ARRAYSIZE =
    HWCText_StateIconE_StateIconE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StateIconE_descriptor() {
    return HWCText_StateIconE_descriptor();
  }
  template<typename T>
  static inline const std::string& StateIconE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StateIconE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StateIconE_Name.");
    return HWCText_StateIconE_Name(enum_t_value);
  }
  static inline bool StateIconE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StateIconE* value) {
    return HWCText_StateIconE_Parse(name, value);
  }

  typedef HWCText_ModifierIconE ModifierIconE;
  static constexpr ModifierIconE MI_NONE =
    HWCText_ModifierIconE_MI_NONE;
  static constexpr ModifierIconE MI_CYCLE =
    HWCText_ModifierIconE_MI_CYCLE;
  static constexpr ModifierIconE MI_DOWN =
    HWCText_ModifierIconE_MI_DOWN;
  static constexpr ModifierIconE MI_UP =
    HWCText_ModifierIconE_MI_UP;
  static constexpr ModifierIconE MI_HOLD =
    HWCText_ModifierIconE_MI_HOLD;
  static constexpr ModifierIconE MI_TOGGLE =
    HWCText_ModifierIconE_MI_TOGGLE;
  static constexpr ModifierIconE MI_OK =
    HWCText_ModifierIconE_MI_OK;
  static constexpr ModifierIconE MI_QUESTION =
    HWCText_ModifierIconE_MI_QUESTION;
  static inline bool ModifierIconE_IsValid(int value) {
    return HWCText_ModifierIconE_IsValid(value);
  }
  static constexpr ModifierIconE ModifierIconE_MIN =
    HWCText_ModifierIconE_ModifierIconE_MIN;
  static constexpr ModifierIconE ModifierIconE_MAX =
    HWCText_ModifierIconE_ModifierIconE_MAX;
  static constexpr int ModifierIconE_ARRAYSIZE =
    HWCText_ModifierIconE_ModifierIconE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ModifierIconE_descriptor() {
    return HWCText_ModifierIconE_descriptor();
  }
  template<typename T>
  static inline const std::string& ModifierIconE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ModifierIconE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ModifierIconE_Name.");
    return HWCText_ModifierIconE_Name(enum_t_value);
  }
  static inline bool ModifierIconE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ModifierIconE* value) {
    return HWCText_ModifierIconE_Parse(name, value);
  }

  typedef HWCText_PairModeE PairModeE;
  static constexpr PairModeE PM_OFF =
    HWCText_PairModeE_PM_OFF;
  static constexpr PairModeE PM_UNMARKED =
    HWCText_PairModeE_PM_UNMARKED;
  static constexpr PairModeE PM_UPPER_MARKED =
    HWCText_PairModeE_PM_UPPER_MARKED;
  static constexpr PairModeE PM_LOWER_MARKED =
    HWCText_PairModeE_PM_LOWER_MARKED;
  static constexpr PairModeE PM_BOTH_MARKED =
    HWCText_PairModeE_PM_BOTH_MARKED;
  static inline bool PairModeE_IsValid(int value) {
    return HWCText_PairModeE_IsValid(value);
  }
  static constexpr PairModeE PairModeE_MIN =
    HWCText_PairModeE_PairModeE_MIN;
  static constexpr PairModeE PairModeE_MAX =
    HWCText_PairModeE_PairModeE_MAX;
  static constexpr int PairModeE_ARRAYSIZE =
    HWCText_PairModeE_PairModeE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PairModeE_descriptor() {
    return HWCText_PairModeE_descriptor();
  }
  template<typename T>
  static inline const std::string& PairModeE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PairModeE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PairModeE_Name.");
    return HWCText_PairModeE_Name(enum_t_value);
  }
  static inline bool PairModeE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PairModeE* value) {
    return HWCText_PairModeE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 7,
    kTextline1FieldNumber = 9,
    kTextline2FieldNumber = 10,
    kScaleFieldNumber = 13,
    kTextStylingFieldNumber = 14,
    kPixelColorFieldNumber = 16,
    kBackgroundColorFieldNumber = 17,
    kIntegerValueFieldNumber = 2,
    kFormattingFieldNumber = 3,
    kStateIconFieldNumber = 5,
    kModifierIconFieldNumber = 6,
    kIntegerValue2FieldNumber = 11,
    kSolidHeaderBarFieldNumber = 8,
    kInvertedFieldNumber = 15,
    kPairModeFieldNumber = 12,
  };
  // string Title = 7;
  void clear_title();
  const std::string& title() const;
  void set_title(const std::string& value);
  void set_title(std::string&& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string Textline1 = 9;
  void clear_textline1();
  const std::string& textline1() const;
  void set_textline1(const std::string& value);
  void set_textline1(std::string&& value);
  void set_textline1(const char* value);
  void set_textline1(const char* value, size_t size);
  std::string* mutable_textline1();
  std::string* release_textline1();
  void set_allocated_textline1(std::string* textline1);
  private:
  const std::string& _internal_textline1() const;
  void _internal_set_textline1(const std::string& value);
  std::string* _internal_mutable_textline1();
  public:

  // string Textline2 = 10;
  void clear_textline2();
  const std::string& textline2() const;
  void set_textline2(const std::string& value);
  void set_textline2(std::string&& value);
  void set_textline2(const char* value);
  void set_textline2(const char* value, size_t size);
  std::string* mutable_textline2();
  std::string* release_textline2();
  void set_allocated_textline2(std::string* textline2);
  private:
  const std::string& _internal_textline2() const;
  void _internal_set_textline2(const std::string& value);
  std::string* _internal_mutable_textline2();
  public:

  // .ibeam_rawpanel.HWCText.ScaleM Scale = 13;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  const ::ibeam_rawpanel::HWCText_ScaleM& scale() const;
  ::ibeam_rawpanel::HWCText_ScaleM* release_scale();
  ::ibeam_rawpanel::HWCText_ScaleM* mutable_scale();
  void set_allocated_scale(::ibeam_rawpanel::HWCText_ScaleM* scale);
  private:
  const ::ibeam_rawpanel::HWCText_ScaleM& _internal_scale() const;
  ::ibeam_rawpanel::HWCText_ScaleM* _internal_mutable_scale();
  public:
  void unsafe_arena_set_allocated_scale(
      ::ibeam_rawpanel::HWCText_ScaleM* scale);
  ::ibeam_rawpanel::HWCText_ScaleM* unsafe_arena_release_scale();

  // .ibeam_rawpanel.HWCText.TextStyle TextStyling = 14;
  bool has_textstyling() const;
  private:
  bool _internal_has_textstyling() const;
  public:
  void clear_textstyling();
  const ::ibeam_rawpanel::HWCText_TextStyle& textstyling() const;
  ::ibeam_rawpanel::HWCText_TextStyle* release_textstyling();
  ::ibeam_rawpanel::HWCText_TextStyle* mutable_textstyling();
  void set_allocated_textstyling(::ibeam_rawpanel::HWCText_TextStyle* textstyling);
  private:
  const ::ibeam_rawpanel::HWCText_TextStyle& _internal_textstyling() const;
  ::ibeam_rawpanel::HWCText_TextStyle* _internal_mutable_textstyling();
  public:
  void unsafe_arena_set_allocated_textstyling(
      ::ibeam_rawpanel::HWCText_TextStyle* textstyling);
  ::ibeam_rawpanel::HWCText_TextStyle* unsafe_arena_release_textstyling();

  // .ibeam_rawpanel.Color PixelColor = 16;
  bool has_pixelcolor() const;
  private:
  bool _internal_has_pixelcolor() const;
  public:
  void clear_pixelcolor();
  const ::ibeam_rawpanel::Color& pixelcolor() const;
  ::ibeam_rawpanel::Color* release_pixelcolor();
  ::ibeam_rawpanel::Color* mutable_pixelcolor();
  void set_allocated_pixelcolor(::ibeam_rawpanel::Color* pixelcolor);
  private:
  const ::ibeam_rawpanel::Color& _internal_pixelcolor() const;
  ::ibeam_rawpanel::Color* _internal_mutable_pixelcolor();
  public:
  void unsafe_arena_set_allocated_pixelcolor(
      ::ibeam_rawpanel::Color* pixelcolor);
  ::ibeam_rawpanel::Color* unsafe_arena_release_pixelcolor();

  // .ibeam_rawpanel.Color BackgroundColor = 17;
  bool has_backgroundcolor() const;
  private:
  bool _internal_has_backgroundcolor() const;
  public:
  void clear_backgroundcolor();
  const ::ibeam_rawpanel::Color& backgroundcolor() const;
  ::ibeam_rawpanel::Color* release_backgroundcolor();
  ::ibeam_rawpanel::Color* mutable_backgroundcolor();
  void set_allocated_backgroundcolor(::ibeam_rawpanel::Color* backgroundcolor);
  private:
  const ::ibeam_rawpanel::Color& _internal_backgroundcolor() const;
  ::ibeam_rawpanel::Color* _internal_mutable_backgroundcolor();
  public:
  void unsafe_arena_set_allocated_backgroundcolor(
      ::ibeam_rawpanel::Color* backgroundcolor);
  ::ibeam_rawpanel::Color* unsafe_arena_release_backgroundcolor();

  // sint32 IntegerValue = 2;
  void clear_integervalue();
  ::PROTOBUF_NAMESPACE_ID::int32 integervalue() const;
  void set_integervalue(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_integervalue() const;
  void _internal_set_integervalue(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // .ibeam_rawpanel.HWCText.FormattingE Formatting = 3;
  void clear_formatting();
  ::ibeam_rawpanel::HWCText_FormattingE formatting() const;
  void set_formatting(::ibeam_rawpanel::HWCText_FormattingE value);
  private:
  ::ibeam_rawpanel::HWCText_FormattingE _internal_formatting() const;
  void _internal_set_formatting(::ibeam_rawpanel::HWCText_FormattingE value);
  public:

  // .ibeam_rawpanel.HWCText.StateIconE StateIcon = 5;
  void clear_stateicon();
  ::ibeam_rawpanel::HWCText_StateIconE stateicon() const;
  void set_stateicon(::ibeam_rawpanel::HWCText_StateIconE value);
  private:
  ::ibeam_rawpanel::HWCText_StateIconE _internal_stateicon() const;
  void _internal_set_stateicon(::ibeam_rawpanel::HWCText_StateIconE value);
  public:

  // .ibeam_rawpanel.HWCText.ModifierIconE ModifierIcon = 6;
  void clear_modifiericon();
  ::ibeam_rawpanel::HWCText_ModifierIconE modifiericon() const;
  void set_modifiericon(::ibeam_rawpanel::HWCText_ModifierIconE value);
  private:
  ::ibeam_rawpanel::HWCText_ModifierIconE _internal_modifiericon() const;
  void _internal_set_modifiericon(::ibeam_rawpanel::HWCText_ModifierIconE value);
  public:

  // sint32 IntegerValue2 = 11;
  void clear_integervalue2();
  ::PROTOBUF_NAMESPACE_ID::int32 integervalue2() const;
  void set_integervalue2(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_integervalue2() const;
  void _internal_set_integervalue2(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool SolidHeaderBar = 8;
  void clear_solidheaderbar();
  bool solidheaderbar() const;
  void set_solidheaderbar(bool value);
  private:
  bool _internal_solidheaderbar() const;
  void _internal_set_solidheaderbar(bool value);
  public:

  // bool Inverted = 15;
  void clear_inverted();
  bool inverted() const;
  void set_inverted(bool value);
  private:
  bool _internal_inverted() const;
  void _internal_set_inverted(bool value);
  public:

  // .ibeam_rawpanel.HWCText.PairModeE PairMode = 12;
  void clear_pairmode();
  ::ibeam_rawpanel::HWCText_PairModeE pairmode() const;
  void set_pairmode(::ibeam_rawpanel::HWCText_PairModeE value);
  private:
  ::ibeam_rawpanel::HWCText_PairModeE _internal_pairmode() const;
  void _internal_set_pairmode(::ibeam_rawpanel::HWCText_PairModeE value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCText)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr textline1_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr textline2_;
  ::ibeam_rawpanel::HWCText_ScaleM* scale_;
  ::ibeam_rawpanel::HWCText_TextStyle* textstyling_;
  ::ibeam_rawpanel::Color* pixelcolor_;
  ::ibeam_rawpanel::Color* backgroundcolor_;
  ::PROTOBUF_NAMESPACE_ID::int32 integervalue_;
  int formatting_;
  int stateicon_;
  int modifiericon_;
  ::PROTOBUF_NAMESPACE_ID::int32 integervalue2_;
  bool solidheaderbar_;
  bool inverted_;
  int pairmode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCGfx PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCGfx) */ {
 public:
  inline HWCGfx() : HWCGfx(nullptr) {}
  virtual ~HWCGfx();

  HWCGfx(const HWCGfx& from);
  HWCGfx(HWCGfx&& from) noexcept
    : HWCGfx() {
    *this = ::std::move(from);
  }

  inline HWCGfx& operator=(const HWCGfx& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCGfx& operator=(HWCGfx&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCGfx& default_instance();

  static inline const HWCGfx* internal_default_instance() {
    return reinterpret_cast<const HWCGfx*>(
               &_HWCGfx_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(HWCGfx& a, HWCGfx& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCGfx* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCGfx* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCGfx* New() const final {
    return CreateMaybeMessage<HWCGfx>(nullptr);
  }

  HWCGfx* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCGfx>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCGfx& from);
  void MergeFrom(const HWCGfx& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCGfx* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCGfx";
  }
  protected:
  explicit HWCGfx(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef HWCGfx_ImageTypeE ImageTypeE;
  static constexpr ImageTypeE MONO =
    HWCGfx_ImageTypeE_MONO;
  static constexpr ImageTypeE RGB16bit =
    HWCGfx_ImageTypeE_RGB16bit;
  static inline bool ImageTypeE_IsValid(int value) {
    return HWCGfx_ImageTypeE_IsValid(value);
  }
  static constexpr ImageTypeE ImageTypeE_MIN =
    HWCGfx_ImageTypeE_ImageTypeE_MIN;
  static constexpr ImageTypeE ImageTypeE_MAX =
    HWCGfx_ImageTypeE_ImageTypeE_MAX;
  static constexpr int ImageTypeE_ARRAYSIZE =
    HWCGfx_ImageTypeE_ImageTypeE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ImageTypeE_descriptor() {
    return HWCGfx_ImageTypeE_descriptor();
  }
  template<typename T>
  static inline const std::string& ImageTypeE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ImageTypeE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ImageTypeE_Name.");
    return HWCGfx_ImageTypeE_Name(enum_t_value);
  }
  static inline bool ImageTypeE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ImageTypeE* value) {
    return HWCGfx_ImageTypeE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kImageDataFieldNumber = 16,
    kImageTypeFieldNumber = 1,
    kWFieldNumber = 2,
    kHFieldNumber = 3,
    kXYoffsetFieldNumber = 4,
    kXFieldNumber = 5,
    kYFieldNumber = 6,
  };
  // bytes ImageData = 16;
  void clear_imagedata();
  const std::string& imagedata() const;
  void set_imagedata(const std::string& value);
  void set_imagedata(std::string&& value);
  void set_imagedata(const char* value);
  void set_imagedata(const void* value, size_t size);
  std::string* mutable_imagedata();
  std::string* release_imagedata();
  void set_allocated_imagedata(std::string* imagedata);
  private:
  const std::string& _internal_imagedata() const;
  void _internal_set_imagedata(const std::string& value);
  std::string* _internal_mutable_imagedata();
  public:

  // .ibeam_rawpanel.HWCGfx.ImageTypeE ImageType = 1;
  void clear_imagetype();
  ::ibeam_rawpanel::HWCGfx_ImageTypeE imagetype() const;
  void set_imagetype(::ibeam_rawpanel::HWCGfx_ImageTypeE value);
  private:
  ::ibeam_rawpanel::HWCGfx_ImageTypeE _internal_imagetype() const;
  void _internal_set_imagetype(::ibeam_rawpanel::HWCGfx_ImageTypeE value);
  public:

  // uint32 W = 2;
  void clear_w();
  ::PROTOBUF_NAMESPACE_ID::uint32 w() const;
  void set_w(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_w() const;
  void _internal_set_w(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 H = 3;
  void clear_h();
  ::PROTOBUF_NAMESPACE_ID::uint32 h() const;
  void set_h(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_h() const;
  void _internal_set_h(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool XYoffset = 4;
  void clear_xyoffset();
  bool xyoffset() const;
  void set_xyoffset(bool value);
  private:
  bool _internal_xyoffset() const;
  void _internal_set_xyoffset(bool value);
  public:

  // uint32 X = 5;
  void clear_x();
  ::PROTOBUF_NAMESPACE_ID::uint32 x() const;
  void set_x(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_x() const;
  void _internal_set_x(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 Y = 6;
  void clear_y();
  ::PROTOBUF_NAMESPACE_ID::uint32 y() const;
  void set_y(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_y() const;
  void _internal_set_y(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCGfx)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr imagedata_;
  int imagetype_;
  ::PROTOBUF_NAMESPACE_ID::uint32 w_;
  ::PROTOBUF_NAMESPACE_ID::uint32 h_;
  bool xyoffset_;
  ::PROTOBUF_NAMESPACE_ID::uint32 x_;
  ::PROTOBUF_NAMESPACE_ID::uint32 y_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class ImgConvert PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.ImgConvert) */ {
 public:
  inline ImgConvert() : ImgConvert(nullptr) {}
  virtual ~ImgConvert();

  ImgConvert(const ImgConvert& from);
  ImgConvert(ImgConvert&& from) noexcept
    : ImgConvert() {
    *this = ::std::move(from);
  }

  inline ImgConvert& operator=(const ImgConvert& from) {
    CopyFrom(from);
    return *this;
  }
  inline ImgConvert& operator=(ImgConvert&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ImgConvert& default_instance();

  static inline const ImgConvert* internal_default_instance() {
    return reinterpret_cast<const ImgConvert*>(
               &_ImgConvert_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ImgConvert& a, ImgConvert& b) {
    a.Swap(&b);
  }
  inline void Swap(ImgConvert* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ImgConvert* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ImgConvert* New() const final {
    return CreateMaybeMessage<ImgConvert>(nullptr);
  }

  ImgConvert* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ImgConvert>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ImgConvert& from);
  void MergeFrom(const ImgConvert& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImgConvert* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.ImgConvert";
  }
  protected:
  explicit ImgConvert(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ImgConvert_FileTypeE FileTypeE;
  static constexpr FileTypeE PNG =
    ImgConvert_FileTypeE_PNG;
  static constexpr FileTypeE JPEG =
    ImgConvert_FileTypeE_JPEG;
  static inline bool FileTypeE_IsValid(int value) {
    return ImgConvert_FileTypeE_IsValid(value);
  }
  static constexpr FileTypeE FileTypeE_MIN =
    ImgConvert_FileTypeE_FileTypeE_MIN;
  static constexpr FileTypeE FileTypeE_MAX =
    ImgConvert_FileTypeE_FileTypeE_MAX;
  static constexpr int FileTypeE_ARRAYSIZE =
    ImgConvert_FileTypeE_FileTypeE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FileTypeE_descriptor() {
    return ImgConvert_FileTypeE_descriptor();
  }
  template<typename T>
  static inline const std::string& FileTypeE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FileTypeE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FileTypeE_Name.");
    return ImgConvert_FileTypeE_Name(enum_t_value);
  }
  static inline bool FileTypeE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FileTypeE* value) {
    return ImgConvert_FileTypeE_Parse(name, value);
  }

  typedef ImgConvert_ScalingE ScalingE;
  static constexpr ScalingE FILL =
    ImgConvert_ScalingE_FILL;
  static constexpr ScalingE FIT =
    ImgConvert_ScalingE_FIT;
  static constexpr ScalingE CROP =
    ImgConvert_ScalingE_CROP;
  static inline bool ScalingE_IsValid(int value) {
    return ImgConvert_ScalingE_IsValid(value);
  }
  static constexpr ScalingE ScalingE_MIN =
    ImgConvert_ScalingE_ScalingE_MIN;
  static constexpr ScalingE ScalingE_MAX =
    ImgConvert_ScalingE_ScalingE_MAX;
  static constexpr int ScalingE_ARRAYSIZE =
    ImgConvert_ScalingE_ScalingE_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ScalingE_descriptor() {
    return ImgConvert_ScalingE_descriptor();
  }
  template<typename T>
  static inline const std::string& ScalingE_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ScalingE>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ScalingE_Name.");
    return ImgConvert_ScalingE_Name(enum_t_value);
  }
  static inline bool ScalingE_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ScalingE* value) {
    return ImgConvert_ScalingE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFileTypeFieldNumber = 1,
    kScalingFieldNumber = 2,
    kGrayscaleFieldNumber = 3,
  };
  // .ibeam_rawpanel.ImgConvert.FileTypeE FileType = 1;
  void clear_filetype();
  ::ibeam_rawpanel::ImgConvert_FileTypeE filetype() const;
  void set_filetype(::ibeam_rawpanel::ImgConvert_FileTypeE value);
  private:
  ::ibeam_rawpanel::ImgConvert_FileTypeE _internal_filetype() const;
  void _internal_set_filetype(::ibeam_rawpanel::ImgConvert_FileTypeE value);
  public:

  // .ibeam_rawpanel.ImgConvert.ScalingE Scaling = 2;
  void clear_scaling();
  ::ibeam_rawpanel::ImgConvert_ScalingE scaling() const;
  void set_scaling(::ibeam_rawpanel::ImgConvert_ScalingE value);
  private:
  ::ibeam_rawpanel::ImgConvert_ScalingE _internal_scaling() const;
  void _internal_set_scaling(::ibeam_rawpanel::ImgConvert_ScalingE value);
  public:

  // bool Grayscale = 3;
  void clear_grayscale();
  bool grayscale() const;
  void set_grayscale(bool value);
  private:
  bool _internal_grayscale() const;
  void _internal_set_grayscale(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.ImgConvert)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int filetype_;
  int scaling_;
  bool grayscale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class OutboundMessage_HWCavailabilityEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OutboundMessage_HWCavailabilityEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::uint32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<OutboundMessage_HWCavailabilityEntry_DoNotUse, 
    ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::uint32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32> SuperType;
  OutboundMessage_HWCavailabilityEntry_DoNotUse();
  explicit OutboundMessage_HWCavailabilityEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const OutboundMessage_HWCavailabilityEntry_DoNotUse& other);
  static const OutboundMessage_HWCavailabilityEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const OutboundMessage_HWCavailabilityEntry_DoNotUse*>(&_OutboundMessage_HWCavailabilityEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[19];
  }

  public:
};

// -------------------------------------------------------------------

class OutboundMessage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.OutboundMessage) */ {
 public:
  inline OutboundMessage() : OutboundMessage(nullptr) {}
  virtual ~OutboundMessage();

  OutboundMessage(const OutboundMessage& from);
  OutboundMessage(OutboundMessage&& from) noexcept
    : OutboundMessage() {
    *this = ::std::move(from);
  }

  inline OutboundMessage& operator=(const OutboundMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline OutboundMessage& operator=(OutboundMessage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const OutboundMessage& default_instance();

  static inline const OutboundMessage* internal_default_instance() {
    return reinterpret_cast<const OutboundMessage*>(
               &_OutboundMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(OutboundMessage& a, OutboundMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(OutboundMessage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OutboundMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OutboundMessage* New() const final {
    return CreateMaybeMessage<OutboundMessage>(nullptr);
  }

  OutboundMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OutboundMessage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const OutboundMessage& from);
  void MergeFrom(const OutboundMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OutboundMessage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.OutboundMessage";
  }
  protected:
  explicit OutboundMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  typedef OutboundMessage_FlowMsg FlowMsg;
  static constexpr FlowMsg NONE =
    OutboundMessage_FlowMsg_NONE;
  static constexpr FlowMsg PING =
    OutboundMessage_FlowMsg_PING;
  static constexpr FlowMsg ACK =
    OutboundMessage_FlowMsg_ACK;
  static constexpr FlowMsg NACK =
    OutboundMessage_FlowMsg_NACK;
  static constexpr FlowMsg BSY =
    OutboundMessage_FlowMsg_BSY;
  static constexpr FlowMsg RDY =
    OutboundMessage_FlowMsg_RDY;
  static constexpr FlowMsg HELLO =
    OutboundMessage_FlowMsg_HELLO;
  static inline bool FlowMsg_IsValid(int value) {
    return OutboundMessage_FlowMsg_IsValid(value);
  }
  static constexpr FlowMsg FlowMsg_MIN =
    OutboundMessage_FlowMsg_FlowMsg_MIN;
  static constexpr FlowMsg FlowMsg_MAX =
    OutboundMessage_FlowMsg_FlowMsg_MAX;
  static constexpr int FlowMsg_ARRAYSIZE =
    OutboundMessage_FlowMsg_FlowMsg_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FlowMsg_descriptor() {
    return OutboundMessage_FlowMsg_descriptor();
  }
  template<typename T>
  static inline const std::string& FlowMsg_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FlowMsg>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FlowMsg_Name.");
    return OutboundMessage_FlowMsg_Name(enum_t_value);
  }
  static inline bool FlowMsg_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FlowMsg* value) {
    return OutboundMessage_FlowMsg_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHWCavailabilityFieldNumber = 2,
    kEventsFieldNumber = 8,
    kPanelInfoFieldNumber = 4,
    kPanelTopologyFieldNumber = 5,
    kSleepTimeoutFieldNumber = 6,
    kSleepStateFieldNumber = 7,
    kBurninProfileFieldNumber = 9,
    kFlowMessageFieldNumber = 1,
  };
  // map<uint32, uint32> HWCavailability = 2;
  int hwcavailability_size() const;
  private:
  int _internal_hwcavailability_size() const;
  public:
  void clear_hwcavailability();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::uint32 >&
      _internal_hwcavailability() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::uint32 >*
      _internal_mutable_hwcavailability();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::uint32 >&
      hwcavailability() const;
  ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_hwcavailability();

  // repeated .ibeam_rawpanel.HWCEvent Events = 8;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::ibeam_rawpanel::HWCEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCEvent >*
      mutable_events();
  private:
  const ::ibeam_rawpanel::HWCEvent& _internal_events(int index) const;
  ::ibeam_rawpanel::HWCEvent* _internal_add_events();
  public:
  const ::ibeam_rawpanel::HWCEvent& events(int index) const;
  ::ibeam_rawpanel::HWCEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCEvent >&
      events() const;

  // .ibeam_rawpanel.PanelInfo PanelInfo = 4;
  bool has_panelinfo() const;
  private:
  bool _internal_has_panelinfo() const;
  public:
  void clear_panelinfo();
  const ::ibeam_rawpanel::PanelInfo& panelinfo() const;
  ::ibeam_rawpanel::PanelInfo* release_panelinfo();
  ::ibeam_rawpanel::PanelInfo* mutable_panelinfo();
  void set_allocated_panelinfo(::ibeam_rawpanel::PanelInfo* panelinfo);
  private:
  const ::ibeam_rawpanel::PanelInfo& _internal_panelinfo() const;
  ::ibeam_rawpanel::PanelInfo* _internal_mutable_panelinfo();
  public:
  void unsafe_arena_set_allocated_panelinfo(
      ::ibeam_rawpanel::PanelInfo* panelinfo);
  ::ibeam_rawpanel::PanelInfo* unsafe_arena_release_panelinfo();

  // .ibeam_rawpanel.PanelTopology PanelTopology = 5;
  bool has_paneltopology() const;
  private:
  bool _internal_has_paneltopology() const;
  public:
  void clear_paneltopology();
  const ::ibeam_rawpanel::PanelTopology& paneltopology() const;
  ::ibeam_rawpanel::PanelTopology* release_paneltopology();
  ::ibeam_rawpanel::PanelTopology* mutable_paneltopology();
  void set_allocated_paneltopology(::ibeam_rawpanel::PanelTopology* paneltopology);
  private:
  const ::ibeam_rawpanel::PanelTopology& _internal_paneltopology() const;
  ::ibeam_rawpanel::PanelTopology* _internal_mutable_paneltopology();
  public:
  void unsafe_arena_set_allocated_paneltopology(
      ::ibeam_rawpanel::PanelTopology* paneltopology);
  ::ibeam_rawpanel::PanelTopology* unsafe_arena_release_paneltopology();

  // .ibeam_rawpanel.SleepTimeout SleepTimeout = 6;
  bool has_sleeptimeout() const;
  private:
  bool _internal_has_sleeptimeout() const;
  public:
  void clear_sleeptimeout();
  const ::ibeam_rawpanel::SleepTimeout& sleeptimeout() const;
  ::ibeam_rawpanel::SleepTimeout* release_sleeptimeout();
  ::ibeam_rawpanel::SleepTimeout* mutable_sleeptimeout();
  void set_allocated_sleeptimeout(::ibeam_rawpanel::SleepTimeout* sleeptimeout);
  private:
  const ::ibeam_rawpanel::SleepTimeout& _internal_sleeptimeout() const;
  ::ibeam_rawpanel::SleepTimeout* _internal_mutable_sleeptimeout();
  public:
  void unsafe_arena_set_allocated_sleeptimeout(
      ::ibeam_rawpanel::SleepTimeout* sleeptimeout);
  ::ibeam_rawpanel::SleepTimeout* unsafe_arena_release_sleeptimeout();

  // .ibeam_rawpanel.SleepState SleepState = 7;
  bool has_sleepstate() const;
  private:
  bool _internal_has_sleepstate() const;
  public:
  void clear_sleepstate();
  const ::ibeam_rawpanel::SleepState& sleepstate() const;
  ::ibeam_rawpanel::SleepState* release_sleepstate();
  ::ibeam_rawpanel::SleepState* mutable_sleepstate();
  void set_allocated_sleepstate(::ibeam_rawpanel::SleepState* sleepstate);
  private:
  const ::ibeam_rawpanel::SleepState& _internal_sleepstate() const;
  ::ibeam_rawpanel::SleepState* _internal_mutable_sleepstate();
  public:
  void unsafe_arena_set_allocated_sleepstate(
      ::ibeam_rawpanel::SleepState* sleepstate);
  ::ibeam_rawpanel::SleepState* unsafe_arena_release_sleepstate();

  // .ibeam_rawpanel.BurninProfile BurninProfile = 9;
  bool has_burninprofile() const;
  private:
  bool _internal_has_burninprofile() const;
  public:
  void clear_burninprofile();
  const ::ibeam_rawpanel::BurninProfile& burninprofile() const;
  ::ibeam_rawpanel::BurninProfile* release_burninprofile();
  ::ibeam_rawpanel::BurninProfile* mutable_burninprofile();
  void set_allocated_burninprofile(::ibeam_rawpanel::BurninProfile* burninprofile);
  private:
  const ::ibeam_rawpanel::BurninProfile& _internal_burninprofile() const;
  ::ibeam_rawpanel::BurninProfile* _internal_mutable_burninprofile();
  public:
  void unsafe_arena_set_allocated_burninprofile(
      ::ibeam_rawpanel::BurninProfile* burninprofile);
  ::ibeam_rawpanel::BurninProfile* unsafe_arena_release_burninprofile();

  // .ibeam_rawpanel.OutboundMessage.FlowMsg FlowMessage = 1;
  void clear_flowmessage();
  ::ibeam_rawpanel::OutboundMessage_FlowMsg flowmessage() const;
  void set_flowmessage(::ibeam_rawpanel::OutboundMessage_FlowMsg value);
  private:
  ::ibeam_rawpanel::OutboundMessage_FlowMsg _internal_flowmessage() const;
  void _internal_set_flowmessage(::ibeam_rawpanel::OutboundMessage_FlowMsg value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.OutboundMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      OutboundMessage_HWCavailabilityEntry_DoNotUse,
      ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::uint32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32> hwcavailability_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCEvent > events_;
  ::ibeam_rawpanel::PanelInfo* panelinfo_;
  ::ibeam_rawpanel::PanelTopology* paneltopology_;
  ::ibeam_rawpanel::SleepTimeout* sleeptimeout_;
  ::ibeam_rawpanel::SleepState* sleepstate_;
  ::ibeam_rawpanel::BurninProfile* burninprofile_;
  int flowmessage_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class SleepState PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.SleepState) */ {
 public:
  inline SleepState() : SleepState(nullptr) {}
  virtual ~SleepState();

  SleepState(const SleepState& from);
  SleepState(SleepState&& from) noexcept
    : SleepState() {
    *this = ::std::move(from);
  }

  inline SleepState& operator=(const SleepState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SleepState& operator=(SleepState&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SleepState& default_instance();

  static inline const SleepState* internal_default_instance() {
    return reinterpret_cast<const SleepState*>(
               &_SleepState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SleepState& a, SleepState& b) {
    a.Swap(&b);
  }
  inline void Swap(SleepState* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SleepState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SleepState* New() const final {
    return CreateMaybeMessage<SleepState>(nullptr);
  }

  SleepState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SleepState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SleepState& from);
  void MergeFrom(const SleepState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SleepState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.SleepState";
  }
  protected:
  explicit SleepState(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSleepingFieldNumber = 1,
  };
  // bool IsSleeping = 1;
  void clear_issleeping();
  bool issleeping() const;
  void set_issleeping(bool value);
  private:
  bool _internal_issleeping() const;
  void _internal_set_issleeping(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.SleepState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool issleeping_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class HWCEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.HWCEvent) */ {
 public:
  inline HWCEvent() : HWCEvent(nullptr) {}
  virtual ~HWCEvent();

  HWCEvent(const HWCEvent& from);
  HWCEvent(HWCEvent&& from) noexcept
    : HWCEvent() {
    *this = ::std::move(from);
  }

  inline HWCEvent& operator=(const HWCEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline HWCEvent& operator=(HWCEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HWCEvent& default_instance();

  static inline const HWCEvent* internal_default_instance() {
    return reinterpret_cast<const HWCEvent*>(
               &_HWCEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(HWCEvent& a, HWCEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(HWCEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HWCEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HWCEvent* New() const final {
    return CreateMaybeMessage<HWCEvent>(nullptr);
  }

  HWCEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HWCEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HWCEvent& from);
  void MergeFrom(const HWCEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HWCEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.HWCEvent";
  }
  protected:
  explicit HWCEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBinaryFieldNumber = 2,
    kPulsedFieldNumber = 3,
    kAbsoluteFieldNumber = 4,
    kSpeedFieldNumber = 5,
    kRawAnalogFieldNumber = 7,
    kHWCIDFieldNumber = 1,
    kTimestampFieldNumber = 6,
  };
  // .ibeam_rawpanel.BinaryEvent Binary = 2;
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;
  public:
  void clear_binary();
  const ::ibeam_rawpanel::BinaryEvent& binary() const;
  ::ibeam_rawpanel::BinaryEvent* release_binary();
  ::ibeam_rawpanel::BinaryEvent* mutable_binary();
  void set_allocated_binary(::ibeam_rawpanel::BinaryEvent* binary);
  private:
  const ::ibeam_rawpanel::BinaryEvent& _internal_binary() const;
  ::ibeam_rawpanel::BinaryEvent* _internal_mutable_binary();
  public:
  void unsafe_arena_set_allocated_binary(
      ::ibeam_rawpanel::BinaryEvent* binary);
  ::ibeam_rawpanel::BinaryEvent* unsafe_arena_release_binary();

  // .ibeam_rawpanel.PulsedEvent Pulsed = 3;
  bool has_pulsed() const;
  private:
  bool _internal_has_pulsed() const;
  public:
  void clear_pulsed();
  const ::ibeam_rawpanel::PulsedEvent& pulsed() const;
  ::ibeam_rawpanel::PulsedEvent* release_pulsed();
  ::ibeam_rawpanel::PulsedEvent* mutable_pulsed();
  void set_allocated_pulsed(::ibeam_rawpanel::PulsedEvent* pulsed);
  private:
  const ::ibeam_rawpanel::PulsedEvent& _internal_pulsed() const;
  ::ibeam_rawpanel::PulsedEvent* _internal_mutable_pulsed();
  public:
  void unsafe_arena_set_allocated_pulsed(
      ::ibeam_rawpanel::PulsedEvent* pulsed);
  ::ibeam_rawpanel::PulsedEvent* unsafe_arena_release_pulsed();

  // .ibeam_rawpanel.AbsoluteEvent Absolute = 4;
  bool has_absolute() const;
  private:
  bool _internal_has_absolute() const;
  public:
  void clear_absolute();
  const ::ibeam_rawpanel::AbsoluteEvent& absolute() const;
  ::ibeam_rawpanel::AbsoluteEvent* release_absolute();
  ::ibeam_rawpanel::AbsoluteEvent* mutable_absolute();
  void set_allocated_absolute(::ibeam_rawpanel::AbsoluteEvent* absolute);
  private:
  const ::ibeam_rawpanel::AbsoluteEvent& _internal_absolute() const;
  ::ibeam_rawpanel::AbsoluteEvent* _internal_mutable_absolute();
  public:
  void unsafe_arena_set_allocated_absolute(
      ::ibeam_rawpanel::AbsoluteEvent* absolute);
  ::ibeam_rawpanel::AbsoluteEvent* unsafe_arena_release_absolute();

  // .ibeam_rawpanel.SpeedEvent Speed = 5;
  bool has_speed() const;
  private:
  bool _internal_has_speed() const;
  public:
  void clear_speed();
  const ::ibeam_rawpanel::SpeedEvent& speed() const;
  ::ibeam_rawpanel::SpeedEvent* release_speed();
  ::ibeam_rawpanel::SpeedEvent* mutable_speed();
  void set_allocated_speed(::ibeam_rawpanel::SpeedEvent* speed);
  private:
  const ::ibeam_rawpanel::SpeedEvent& _internal_speed() const;
  ::ibeam_rawpanel::SpeedEvent* _internal_mutable_speed();
  public:
  void unsafe_arena_set_allocated_speed(
      ::ibeam_rawpanel::SpeedEvent* speed);
  ::ibeam_rawpanel::SpeedEvent* unsafe_arena_release_speed();

  // .ibeam_rawpanel.RawAnalogEvent RawAnalog = 7;
  bool has_rawanalog() const;
  private:
  bool _internal_has_rawanalog() const;
  public:
  void clear_rawanalog();
  const ::ibeam_rawpanel::RawAnalogEvent& rawanalog() const;
  ::ibeam_rawpanel::RawAnalogEvent* release_rawanalog();
  ::ibeam_rawpanel::RawAnalogEvent* mutable_rawanalog();
  void set_allocated_rawanalog(::ibeam_rawpanel::RawAnalogEvent* rawanalog);
  private:
  const ::ibeam_rawpanel::RawAnalogEvent& _internal_rawanalog() const;
  ::ibeam_rawpanel::RawAnalogEvent* _internal_mutable_rawanalog();
  public:
  void unsafe_arena_set_allocated_rawanalog(
      ::ibeam_rawpanel::RawAnalogEvent* rawanalog);
  ::ibeam_rawpanel::RawAnalogEvent* unsafe_arena_release_rawanalog();

  // uint32 HWCID = 1;
  void clear_hwcid();
  ::PROTOBUF_NAMESPACE_ID::uint32 hwcid() const;
  void set_hwcid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hwcid() const;
  void _internal_set_hwcid(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 Timestamp = 6;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.HWCEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ibeam_rawpanel::BinaryEvent* binary_;
  ::ibeam_rawpanel::PulsedEvent* pulsed_;
  ::ibeam_rawpanel::AbsoluteEvent* absolute_;
  ::ibeam_rawpanel::SpeedEvent* speed_;
  ::ibeam_rawpanel::RawAnalogEvent* rawanalog_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hwcid_;
  ::PROTOBUF_NAMESPACE_ID::uint32 timestamp_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class BinaryEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.BinaryEvent) */ {
 public:
  inline BinaryEvent() : BinaryEvent(nullptr) {}
  virtual ~BinaryEvent();

  BinaryEvent(const BinaryEvent& from);
  BinaryEvent(BinaryEvent&& from) noexcept
    : BinaryEvent() {
    *this = ::std::move(from);
  }

  inline BinaryEvent& operator=(const BinaryEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryEvent& operator=(BinaryEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BinaryEvent& default_instance();

  static inline const BinaryEvent* internal_default_instance() {
    return reinterpret_cast<const BinaryEvent*>(
               &_BinaryEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(BinaryEvent& a, BinaryEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(BinaryEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BinaryEvent* New() const final {
    return CreateMaybeMessage<BinaryEvent>(nullptr);
  }

  BinaryEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BinaryEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BinaryEvent& from);
  void MergeFrom(const BinaryEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.BinaryEvent";
  }
  protected:
  explicit BinaryEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BinaryEvent_EdgeID EdgeID;
  static constexpr EdgeID UNKNOWN =
    BinaryEvent_EdgeID_UNKNOWN;
  static constexpr EdgeID TOP =
    BinaryEvent_EdgeID_TOP;
  static constexpr EdgeID LEFT =
    BinaryEvent_EdgeID_LEFT;
  static constexpr EdgeID BOTTOM =
    BinaryEvent_EdgeID_BOTTOM;
  static constexpr EdgeID RIGHT =
    BinaryEvent_EdgeID_RIGHT;
  static inline bool EdgeID_IsValid(int value) {
    return BinaryEvent_EdgeID_IsValid(value);
  }
  static constexpr EdgeID EdgeID_MIN =
    BinaryEvent_EdgeID_EdgeID_MIN;
  static constexpr EdgeID EdgeID_MAX =
    BinaryEvent_EdgeID_EdgeID_MAX;
  static constexpr int EdgeID_ARRAYSIZE =
    BinaryEvent_EdgeID_EdgeID_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EdgeID_descriptor() {
    return BinaryEvent_EdgeID_descriptor();
  }
  template<typename T>
  static inline const std::string& EdgeID_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EdgeID>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EdgeID_Name.");
    return BinaryEvent_EdgeID_Name(enum_t_value);
  }
  static inline bool EdgeID_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EdgeID* value) {
    return BinaryEvent_EdgeID_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kPressedFieldNumber = 1,
    kEdgeFieldNumber = 2,
  };
  // bool Pressed = 1;
  void clear_pressed();
  bool pressed() const;
  void set_pressed(bool value);
  private:
  bool _internal_pressed() const;
  void _internal_set_pressed(bool value);
  public:

  // .ibeam_rawpanel.BinaryEvent.EdgeID Edge = 2;
  void clear_edge();
  ::ibeam_rawpanel::BinaryEvent_EdgeID edge() const;
  void set_edge(::ibeam_rawpanel::BinaryEvent_EdgeID value);
  private:
  ::ibeam_rawpanel::BinaryEvent_EdgeID _internal_edge() const;
  void _internal_set_edge(::ibeam_rawpanel::BinaryEvent_EdgeID value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.BinaryEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool pressed_;
  int edge_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class PulsedEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.PulsedEvent) */ {
 public:
  inline PulsedEvent() : PulsedEvent(nullptr) {}
  virtual ~PulsedEvent();

  PulsedEvent(const PulsedEvent& from);
  PulsedEvent(PulsedEvent&& from) noexcept
    : PulsedEvent() {
    *this = ::std::move(from);
  }

  inline PulsedEvent& operator=(const PulsedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline PulsedEvent& operator=(PulsedEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PulsedEvent& default_instance();

  static inline const PulsedEvent* internal_default_instance() {
    return reinterpret_cast<const PulsedEvent*>(
               &_PulsedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PulsedEvent& a, PulsedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(PulsedEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PulsedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PulsedEvent* New() const final {
    return CreateMaybeMessage<PulsedEvent>(nullptr);
  }

  PulsedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PulsedEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PulsedEvent& from);
  void MergeFrom(const PulsedEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PulsedEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.PulsedEvent";
  }
  protected:
  explicit PulsedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // sint32 Value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.PulsedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class AbsoluteEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.AbsoluteEvent) */ {
 public:
  inline AbsoluteEvent() : AbsoluteEvent(nullptr) {}
  virtual ~AbsoluteEvent();

  AbsoluteEvent(const AbsoluteEvent& from);
  AbsoluteEvent(AbsoluteEvent&& from) noexcept
    : AbsoluteEvent() {
    *this = ::std::move(from);
  }

  inline AbsoluteEvent& operator=(const AbsoluteEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AbsoluteEvent& operator=(AbsoluteEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AbsoluteEvent& default_instance();

  static inline const AbsoluteEvent* internal_default_instance() {
    return reinterpret_cast<const AbsoluteEvent*>(
               &_AbsoluteEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(AbsoluteEvent& a, AbsoluteEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(AbsoluteEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AbsoluteEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AbsoluteEvent* New() const final {
    return CreateMaybeMessage<AbsoluteEvent>(nullptr);
  }

  AbsoluteEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AbsoluteEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AbsoluteEvent& from);
  void MergeFrom(const AbsoluteEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbsoluteEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.AbsoluteEvent";
  }
  protected:
  explicit AbsoluteEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 Value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.AbsoluteEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class SpeedEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.SpeedEvent) */ {
 public:
  inline SpeedEvent() : SpeedEvent(nullptr) {}
  virtual ~SpeedEvent();

  SpeedEvent(const SpeedEvent& from);
  SpeedEvent(SpeedEvent&& from) noexcept
    : SpeedEvent() {
    *this = ::std::move(from);
  }

  inline SpeedEvent& operator=(const SpeedEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedEvent& operator=(SpeedEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpeedEvent& default_instance();

  static inline const SpeedEvent* internal_default_instance() {
    return reinterpret_cast<const SpeedEvent*>(
               &_SpeedEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SpeedEvent& a, SpeedEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeedEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeedEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpeedEvent* New() const final {
    return CreateMaybeMessage<SpeedEvent>(nullptr);
  }

  SpeedEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpeedEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpeedEvent& from);
  void MergeFrom(const SpeedEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.SpeedEvent";
  }
  protected:
  explicit SpeedEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // sint32 Value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.SpeedEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class RawAnalogEvent PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.RawAnalogEvent) */ {
 public:
  inline RawAnalogEvent() : RawAnalogEvent(nullptr) {}
  virtual ~RawAnalogEvent();

  RawAnalogEvent(const RawAnalogEvent& from);
  RawAnalogEvent(RawAnalogEvent&& from) noexcept
    : RawAnalogEvent() {
    *this = ::std::move(from);
  }

  inline RawAnalogEvent& operator=(const RawAnalogEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline RawAnalogEvent& operator=(RawAnalogEvent&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RawAnalogEvent& default_instance();

  static inline const RawAnalogEvent* internal_default_instance() {
    return reinterpret_cast<const RawAnalogEvent*>(
               &_RawAnalogEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(RawAnalogEvent& a, RawAnalogEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(RawAnalogEvent* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RawAnalogEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RawAnalogEvent* New() const final {
    return CreateMaybeMessage<RawAnalogEvent>(nullptr);
  }

  RawAnalogEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RawAnalogEvent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RawAnalogEvent& from);
  void MergeFrom(const RawAnalogEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RawAnalogEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.RawAnalogEvent";
  }
  protected:
  explicit RawAnalogEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // uint32 Value = 1;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::uint32 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_value() const;
  void _internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.RawAnalogEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class PanelInfo PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.PanelInfo) */ {
 public:
  inline PanelInfo() : PanelInfo(nullptr) {}
  virtual ~PanelInfo();

  PanelInfo(const PanelInfo& from);
  PanelInfo(PanelInfo&& from) noexcept
    : PanelInfo() {
    *this = ::std::move(from);
  }

  inline PanelInfo& operator=(const PanelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PanelInfo& operator=(PanelInfo&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PanelInfo& default_instance();

  static inline const PanelInfo* internal_default_instance() {
    return reinterpret_cast<const PanelInfo*>(
               &_PanelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(PanelInfo& a, PanelInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PanelInfo* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PanelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PanelInfo* New() const final {
    return CreateMaybeMessage<PanelInfo>(nullptr);
  }

  PanelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PanelInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PanelInfo& from);
  void MergeFrom(const PanelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PanelInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.PanelInfo";
  }
  protected:
  explicit PanelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFieldNumber = 1,
    kSerialFieldNumber = 2,
    kNameFieldNumber = 3,
    kSoftwareVersionFieldNumber = 4,
    kPlatformFieldNumber = 5,
  };
  // string Model = 1;
  void clear_model();
  const std::string& model() const;
  void set_model(const std::string& value);
  void set_model(std::string&& value);
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  std::string* mutable_model();
  std::string* release_model();
  void set_allocated_model(std::string* model);
  private:
  const std::string& _internal_model() const;
  void _internal_set_model(const std::string& value);
  std::string* _internal_mutable_model();
  public:

  // string Serial = 2;
  void clear_serial();
  const std::string& serial() const;
  void set_serial(const std::string& value);
  void set_serial(std::string&& value);
  void set_serial(const char* value);
  void set_serial(const char* value, size_t size);
  std::string* mutable_serial();
  std::string* release_serial();
  void set_allocated_serial(std::string* serial);
  private:
  const std::string& _internal_serial() const;
  void _internal_set_serial(const std::string& value);
  std::string* _internal_mutable_serial();
  public:

  // string Name = 3;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string SoftwareVersion = 4;
  void clear_softwareversion();
  const std::string& softwareversion() const;
  void set_softwareversion(const std::string& value);
  void set_softwareversion(std::string&& value);
  void set_softwareversion(const char* value);
  void set_softwareversion(const char* value, size_t size);
  std::string* mutable_softwareversion();
  std::string* release_softwareversion();
  void set_allocated_softwareversion(std::string* softwareversion);
  private:
  const std::string& _internal_softwareversion() const;
  void _internal_set_softwareversion(const std::string& value);
  std::string* _internal_mutable_softwareversion();
  public:

  // string Platform = 5;
  void clear_platform();
  const std::string& platform() const;
  void set_platform(const std::string& value);
  void set_platform(std::string&& value);
  void set_platform(const char* value);
  void set_platform(const char* value, size_t size);
  std::string* mutable_platform();
  std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.PanelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serial_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr softwareversion_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class PanelTopology PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.PanelTopology) */ {
 public:
  inline PanelTopology() : PanelTopology(nullptr) {}
  virtual ~PanelTopology();

  PanelTopology(const PanelTopology& from);
  PanelTopology(PanelTopology&& from) noexcept
    : PanelTopology() {
    *this = ::std::move(from);
  }

  inline PanelTopology& operator=(const PanelTopology& from) {
    CopyFrom(from);
    return *this;
  }
  inline PanelTopology& operator=(PanelTopology&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PanelTopology& default_instance();

  static inline const PanelTopology* internal_default_instance() {
    return reinterpret_cast<const PanelTopology*>(
               &_PanelTopology_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(PanelTopology& a, PanelTopology& b) {
    a.Swap(&b);
  }
  inline void Swap(PanelTopology* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PanelTopology* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PanelTopology* New() const final {
    return CreateMaybeMessage<PanelTopology>(nullptr);
  }

  PanelTopology* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PanelTopology>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PanelTopology& from);
  void MergeFrom(const PanelTopology& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PanelTopology* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.PanelTopology";
  }
  protected:
  explicit PanelTopology(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSvgbaseFieldNumber = 1,
    kJsonFieldNumber = 2,
  };
  // string Svgbase = 1;
  void clear_svgbase();
  const std::string& svgbase() const;
  void set_svgbase(const std::string& value);
  void set_svgbase(std::string&& value);
  void set_svgbase(const char* value);
  void set_svgbase(const char* value, size_t size);
  std::string* mutable_svgbase();
  std::string* release_svgbase();
  void set_allocated_svgbase(std::string* svgbase);
  private:
  const std::string& _internal_svgbase() const;
  void _internal_set_svgbase(const std::string& value);
  std::string* _internal_mutable_svgbase();
  public:

  // string Json = 2;
  void clear_json();
  const std::string& json() const;
  void set_json(const std::string& value);
  void set_json(std::string&& value);
  void set_json(const char* value);
  void set_json(const char* value, size_t size);
  std::string* mutable_json();
  std::string* release_json();
  void set_allocated_json(std::string* json);
  private:
  const std::string& _internal_json() const;
  void _internal_set_json(const std::string& value);
  std::string* _internal_mutable_json();
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.PanelTopology)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr svgbase_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// -------------------------------------------------------------------

class BurninProfile PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ibeam_rawpanel.BurninProfile) */ {
 public:
  inline BurninProfile() : BurninProfile(nullptr) {}
  virtual ~BurninProfile();

  BurninProfile(const BurninProfile& from);
  BurninProfile(BurninProfile&& from) noexcept
    : BurninProfile() {
    *this = ::std::move(from);
  }

  inline BurninProfile& operator=(const BurninProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline BurninProfile& operator=(BurninProfile&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BurninProfile& default_instance();

  static inline const BurninProfile* internal_default_instance() {
    return reinterpret_cast<const BurninProfile*>(
               &_BurninProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(BurninProfile& a, BurninProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(BurninProfile* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BurninProfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BurninProfile* New() const final {
    return CreateMaybeMessage<BurninProfile>(nullptr);
  }

  BurninProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BurninProfile>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BurninProfile& from);
  void MergeFrom(const BurninProfile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BurninProfile* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ibeam_rawpanel.BurninProfile";
  }
  protected:
  explicit BurninProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ibeam_2drawpanel_2eproto);
    return ::descriptor_table_ibeam_2drawpanel_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kJsonFieldNumber = 1,
  };
  // string Json = 1;
  void clear_json();
  const std::string& json() const;
  void set_json(const std::string& value);
  void set_json(std::string&& value);
  void set_json(const char* value);
  void set_json(const char* value, size_t size);
  std::string* mutable_json();
  std::string* release_json();
  void set_allocated_json(std::string* json);
  private:
  const std::string& _internal_json() const;
  void _internal_set_json(const std::string& value);
  std::string* _internal_mutable_json();
  public:

  // @@protoc_insertion_point(class_scope:ibeam_rawpanel.BurninProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr json_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ibeam_2drawpanel_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// InboundMessage

// .ibeam_rawpanel.InboundMessage.FlowMsg FlowMessage = 1;
inline void InboundMessage::clear_flowmessage() {
  flowmessage_ = 0;
}
inline ::ibeam_rawpanel::InboundMessage_FlowMsg InboundMessage::_internal_flowmessage() const {
  return static_cast< ::ibeam_rawpanel::InboundMessage_FlowMsg >(flowmessage_);
}
inline ::ibeam_rawpanel::InboundMessage_FlowMsg InboundMessage::flowmessage() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.InboundMessage.FlowMessage)
  return _internal_flowmessage();
}
inline void InboundMessage::_internal_set_flowmessage(::ibeam_rawpanel::InboundMessage_FlowMsg value) {
  
  flowmessage_ = value;
}
inline void InboundMessage::set_flowmessage(::ibeam_rawpanel::InboundMessage_FlowMsg value) {
  _internal_set_flowmessage(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.InboundMessage.FlowMessage)
}

// .ibeam_rawpanel.Command Command = 2;
inline bool InboundMessage::_internal_has_command() const {
  return this != internal_default_instance() && command_ != nullptr;
}
inline bool InboundMessage::has_command() const {
  return _internal_has_command();
}
inline void InboundMessage::clear_command() {
  if (GetArena() == nullptr && command_ != nullptr) {
    delete command_;
  }
  command_ = nullptr;
}
inline const ::ibeam_rawpanel::Command& InboundMessage::_internal_command() const {
  const ::ibeam_rawpanel::Command* p = command_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::Command&>(
      ::ibeam_rawpanel::_Command_default_instance_);
}
inline const ::ibeam_rawpanel::Command& InboundMessage::command() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.InboundMessage.Command)
  return _internal_command();
}
inline void InboundMessage::unsafe_arena_set_allocated_command(
    ::ibeam_rawpanel::Command* command) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(command_);
  }
  command_ = command;
  if (command) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.InboundMessage.Command)
}
inline ::ibeam_rawpanel::Command* InboundMessage::release_command() {
  
  ::ibeam_rawpanel::Command* temp = command_;
  command_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::Command* InboundMessage::unsafe_arena_release_command() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.InboundMessage.Command)
  
  ::ibeam_rawpanel::Command* temp = command_;
  command_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::Command* InboundMessage::_internal_mutable_command() {
  
  if (command_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::Command>(GetArena());
    command_ = p;
  }
  return command_;
}
inline ::ibeam_rawpanel::Command* InboundMessage::mutable_command() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.InboundMessage.Command)
  return _internal_mutable_command();
}
inline void InboundMessage::set_allocated_command(::ibeam_rawpanel::Command* command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete command_;
  }
  if (command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(command);
    if (message_arena != submessage_arena) {
      command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, command, submessage_arena);
    }
    
  } else {
    
  }
  command_ = command;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.InboundMessage.Command)
}

// repeated .ibeam_rawpanel.HWCState States = 8;
inline int InboundMessage::_internal_states_size() const {
  return states_.size();
}
inline int InboundMessage::states_size() const {
  return _internal_states_size();
}
inline void InboundMessage::clear_states() {
  states_.Clear();
}
inline ::ibeam_rawpanel::HWCState* InboundMessage::mutable_states(int index) {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.InboundMessage.States)
  return states_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCState >*
InboundMessage::mutable_states() {
  // @@protoc_insertion_point(field_mutable_list:ibeam_rawpanel.InboundMessage.States)
  return &states_;
}
inline const ::ibeam_rawpanel::HWCState& InboundMessage::_internal_states(int index) const {
  return states_.Get(index);
}
inline const ::ibeam_rawpanel::HWCState& InboundMessage::states(int index) const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.InboundMessage.States)
  return _internal_states(index);
}
inline ::ibeam_rawpanel::HWCState* InboundMessage::_internal_add_states() {
  return states_.Add();
}
inline ::ibeam_rawpanel::HWCState* InboundMessage::add_states() {
  // @@protoc_insertion_point(field_add:ibeam_rawpanel.InboundMessage.States)
  return _internal_add_states();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCState >&
InboundMessage::states() const {
  // @@protoc_insertion_point(field_list:ibeam_rawpanel.InboundMessage.States)
  return states_;
}

// -------------------------------------------------------------------

// Command

// bool ActivatePanel = 1;
inline void Command::clear_activatepanel() {
  activatepanel_ = false;
}
inline bool Command::_internal_activatepanel() const {
  return activatepanel_;
}
inline bool Command::activatepanel() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.ActivatePanel)
  return _internal_activatepanel();
}
inline void Command::_internal_set_activatepanel(bool value) {
  
  activatepanel_ = value;
}
inline void Command::set_activatepanel(bool value) {
  _internal_set_activatepanel(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.ActivatePanel)
}

// bool SendPanelInfo = 2;
inline void Command::clear_sendpanelinfo() {
  sendpanelinfo_ = false;
}
inline bool Command::_internal_sendpanelinfo() const {
  return sendpanelinfo_;
}
inline bool Command::sendpanelinfo() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.SendPanelInfo)
  return _internal_sendpanelinfo();
}
inline void Command::_internal_set_sendpanelinfo(bool value) {
  
  sendpanelinfo_ = value;
}
inline void Command::set_sendpanelinfo(bool value) {
  _internal_set_sendpanelinfo(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.SendPanelInfo)
}

// bool SendPanelTopology = 3;
inline void Command::clear_sendpaneltopology() {
  sendpaneltopology_ = false;
}
inline bool Command::_internal_sendpaneltopology() const {
  return sendpaneltopology_;
}
inline bool Command::sendpaneltopology() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.SendPanelTopology)
  return _internal_sendpaneltopology();
}
inline void Command::_internal_set_sendpaneltopology(bool value) {
  
  sendpaneltopology_ = value;
}
inline void Command::set_sendpaneltopology(bool value) {
  _internal_set_sendpaneltopology(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.SendPanelTopology)
}

// bool ReportHWCavailability = 4;
inline void Command::clear_reporthwcavailability() {
  reporthwcavailability_ = false;
}
inline bool Command::_internal_reporthwcavailability() const {
  return reporthwcavailability_;
}
inline bool Command::reporthwcavailability() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.ReportHWCavailability)
  return _internal_reporthwcavailability();
}
inline void Command::_internal_set_reporthwcavailability(bool value) {
  
  reporthwcavailability_ = value;
}
inline void Command::set_reporthwcavailability(bool value) {
  _internal_set_reporthwcavailability(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.ReportHWCavailability)
}

// bool SendBurninProfile = 6;
inline void Command::clear_sendburninprofile() {
  sendburninprofile_ = false;
}
inline bool Command::_internal_sendburninprofile() const {
  return sendburninprofile_;
}
inline bool Command::sendburninprofile() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.SendBurninProfile)
  return _internal_sendburninprofile();
}
inline void Command::_internal_set_sendburninprofile(bool value) {
  
  sendburninprofile_ = value;
}
inline void Command::set_sendburninprofile(bool value) {
  _internal_set_sendburninprofile(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.SendBurninProfile)
}

// bool ClearAll = 10;
inline void Command::clear_clearall() {
  clearall_ = false;
}
inline bool Command::_internal_clearall() const {
  return clearall_;
}
inline bool Command::clearall() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.ClearAll)
  return _internal_clearall();
}
inline void Command::_internal_set_clearall(bool value) {
  
  clearall_ = value;
}
inline void Command::set_clearall(bool value) {
  _internal_set_clearall(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.ClearAll)
}

// bool ClearLEDs = 11;
inline void Command::clear_clearleds() {
  clearleds_ = false;
}
inline bool Command::_internal_clearleds() const {
  return clearleds_;
}
inline bool Command::clearleds() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.ClearLEDs)
  return _internal_clearleds();
}
inline void Command::_internal_set_clearleds(bool value) {
  
  clearleds_ = value;
}
inline void Command::set_clearleds(bool value) {
  _internal_set_clearleds(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.ClearLEDs)
}

// bool ClearDisplays = 12;
inline void Command::clear_cleardisplays() {
  cleardisplays_ = false;
}
inline bool Command::_internal_cleardisplays() const {
  return cleardisplays_;
}
inline bool Command::cleardisplays() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.ClearDisplays)
  return _internal_cleardisplays();
}
inline void Command::_internal_set_cleardisplays(bool value) {
  
  cleardisplays_ = value;
}
inline void Command::set_cleardisplays(bool value) {
  _internal_set_cleardisplays(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.ClearDisplays)
}

// bool WakeUp = 5;
inline void Command::clear_wakeup() {
  wakeup_ = false;
}
inline bool Command::_internal_wakeup() const {
  return wakeup_;
}
inline bool Command::wakeup() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.WakeUp)
  return _internal_wakeup();
}
inline void Command::_internal_set_wakeup(bool value) {
  
  wakeup_ = value;
}
inline void Command::set_wakeup(bool value) {
  _internal_set_wakeup(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.WakeUp)
}

// bool GetSleepTimeout = 20;
inline void Command::clear_getsleeptimeout() {
  getsleeptimeout_ = false;
}
inline bool Command::_internal_getsleeptimeout() const {
  return getsleeptimeout_;
}
inline bool Command::getsleeptimeout() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.GetSleepTimeout)
  return _internal_getsleeptimeout();
}
inline void Command::_internal_set_getsleeptimeout(bool value) {
  
  getsleeptimeout_ = value;
}
inline void Command::set_getsleeptimeout(bool value) {
  _internal_set_getsleeptimeout(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Command.GetSleepTimeout)
}

// .ibeam_rawpanel.SleepTimeout SetSleepTimeout = 21;
inline bool Command::_internal_has_setsleeptimeout() const {
  return this != internal_default_instance() && setsleeptimeout_ != nullptr;
}
inline bool Command::has_setsleeptimeout() const {
  return _internal_has_setsleeptimeout();
}
inline void Command::clear_setsleeptimeout() {
  if (GetArena() == nullptr && setsleeptimeout_ != nullptr) {
    delete setsleeptimeout_;
  }
  setsleeptimeout_ = nullptr;
}
inline const ::ibeam_rawpanel::SleepTimeout& Command::_internal_setsleeptimeout() const {
  const ::ibeam_rawpanel::SleepTimeout* p = setsleeptimeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::SleepTimeout&>(
      ::ibeam_rawpanel::_SleepTimeout_default_instance_);
}
inline const ::ibeam_rawpanel::SleepTimeout& Command::setsleeptimeout() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.SetSleepTimeout)
  return _internal_setsleeptimeout();
}
inline void Command::unsafe_arena_set_allocated_setsleeptimeout(
    ::ibeam_rawpanel::SleepTimeout* setsleeptimeout) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setsleeptimeout_);
  }
  setsleeptimeout_ = setsleeptimeout;
  if (setsleeptimeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.Command.SetSleepTimeout)
}
inline ::ibeam_rawpanel::SleepTimeout* Command::release_setsleeptimeout() {
  
  ::ibeam_rawpanel::SleepTimeout* temp = setsleeptimeout_;
  setsleeptimeout_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::SleepTimeout* Command::unsafe_arena_release_setsleeptimeout() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.Command.SetSleepTimeout)
  
  ::ibeam_rawpanel::SleepTimeout* temp = setsleeptimeout_;
  setsleeptimeout_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::SleepTimeout* Command::_internal_mutable_setsleeptimeout() {
  
  if (setsleeptimeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::SleepTimeout>(GetArena());
    setsleeptimeout_ = p;
  }
  return setsleeptimeout_;
}
inline ::ibeam_rawpanel::SleepTimeout* Command::mutable_setsleeptimeout() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.Command.SetSleepTimeout)
  return _internal_mutable_setsleeptimeout();
}
inline void Command::set_allocated_setsleeptimeout(::ibeam_rawpanel::SleepTimeout* setsleeptimeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete setsleeptimeout_;
  }
  if (setsleeptimeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(setsleeptimeout);
    if (message_arena != submessage_arena) {
      setsleeptimeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setsleeptimeout, submessage_arena);
    }
    
  } else {
    
  }
  setsleeptimeout_ = setsleeptimeout;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.Command.SetSleepTimeout)
}

// .ibeam_rawpanel.WebserverState SetWebserverEnabled = 22;
inline bool Command::_internal_has_setwebserverenabled() const {
  return this != internal_default_instance() && setwebserverenabled_ != nullptr;
}
inline bool Command::has_setwebserverenabled() const {
  return _internal_has_setwebserverenabled();
}
inline void Command::clear_setwebserverenabled() {
  if (GetArena() == nullptr && setwebserverenabled_ != nullptr) {
    delete setwebserverenabled_;
  }
  setwebserverenabled_ = nullptr;
}
inline const ::ibeam_rawpanel::WebserverState& Command::_internal_setwebserverenabled() const {
  const ::ibeam_rawpanel::WebserverState* p = setwebserverenabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::WebserverState&>(
      ::ibeam_rawpanel::_WebserverState_default_instance_);
}
inline const ::ibeam_rawpanel::WebserverState& Command::setwebserverenabled() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.SetWebserverEnabled)
  return _internal_setwebserverenabled();
}
inline void Command::unsafe_arena_set_allocated_setwebserverenabled(
    ::ibeam_rawpanel::WebserverState* setwebserverenabled) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(setwebserverenabled_);
  }
  setwebserverenabled_ = setwebserverenabled;
  if (setwebserverenabled) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.Command.SetWebserverEnabled)
}
inline ::ibeam_rawpanel::WebserverState* Command::release_setwebserverenabled() {
  
  ::ibeam_rawpanel::WebserverState* temp = setwebserverenabled_;
  setwebserverenabled_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::WebserverState* Command::unsafe_arena_release_setwebserverenabled() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.Command.SetWebserverEnabled)
  
  ::ibeam_rawpanel::WebserverState* temp = setwebserverenabled_;
  setwebserverenabled_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::WebserverState* Command::_internal_mutable_setwebserverenabled() {
  
  if (setwebserverenabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::WebserverState>(GetArena());
    setwebserverenabled_ = p;
  }
  return setwebserverenabled_;
}
inline ::ibeam_rawpanel::WebserverState* Command::mutable_setwebserverenabled() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.Command.SetWebserverEnabled)
  return _internal_mutable_setwebserverenabled();
}
inline void Command::set_allocated_setwebserverenabled(::ibeam_rawpanel::WebserverState* setwebserverenabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete setwebserverenabled_;
  }
  if (setwebserverenabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(setwebserverenabled);
    if (message_arena != submessage_arena) {
      setwebserverenabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, setwebserverenabled, submessage_arena);
    }
    
  } else {
    
  }
  setwebserverenabled_ = setwebserverenabled;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.Command.SetWebserverEnabled)
}

// .ibeam_rawpanel.Brightness PanelBrightness = 23;
inline bool Command::_internal_has_panelbrightness() const {
  return this != internal_default_instance() && panelbrightness_ != nullptr;
}
inline bool Command::has_panelbrightness() const {
  return _internal_has_panelbrightness();
}
inline void Command::clear_panelbrightness() {
  if (GetArena() == nullptr && panelbrightness_ != nullptr) {
    delete panelbrightness_;
  }
  panelbrightness_ = nullptr;
}
inline const ::ibeam_rawpanel::Brightness& Command::_internal_panelbrightness() const {
  const ::ibeam_rawpanel::Brightness* p = panelbrightness_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::Brightness&>(
      ::ibeam_rawpanel::_Brightness_default_instance_);
}
inline const ::ibeam_rawpanel::Brightness& Command::panelbrightness() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Command.PanelBrightness)
  return _internal_panelbrightness();
}
inline void Command::unsafe_arena_set_allocated_panelbrightness(
    ::ibeam_rawpanel::Brightness* panelbrightness) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(panelbrightness_);
  }
  panelbrightness_ = panelbrightness;
  if (panelbrightness) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.Command.PanelBrightness)
}
inline ::ibeam_rawpanel::Brightness* Command::release_panelbrightness() {
  
  ::ibeam_rawpanel::Brightness* temp = panelbrightness_;
  panelbrightness_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::Brightness* Command::unsafe_arena_release_panelbrightness() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.Command.PanelBrightness)
  
  ::ibeam_rawpanel::Brightness* temp = panelbrightness_;
  panelbrightness_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::Brightness* Command::_internal_mutable_panelbrightness() {
  
  if (panelbrightness_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::Brightness>(GetArena());
    panelbrightness_ = p;
  }
  return panelbrightness_;
}
inline ::ibeam_rawpanel::Brightness* Command::mutable_panelbrightness() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.Command.PanelBrightness)
  return _internal_mutable_panelbrightness();
}
inline void Command::set_allocated_panelbrightness(::ibeam_rawpanel::Brightness* panelbrightness) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete panelbrightness_;
  }
  if (panelbrightness) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(panelbrightness);
    if (message_arena != submessage_arena) {
      panelbrightness = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, panelbrightness, submessage_arena);
    }
    
  } else {
    
  }
  panelbrightness_ = panelbrightness;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.Command.PanelBrightness)
}

// -------------------------------------------------------------------

// SleepTimeout

// uint32 Value = 1;
inline void SleepTimeout::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SleepTimeout::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 SleepTimeout::value() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.SleepTimeout.Value)
  return _internal_value();
}
inline void SleepTimeout::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void SleepTimeout::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.SleepTimeout.Value)
}

// -------------------------------------------------------------------

// WebserverState

// bool Enabled = 1;
inline void WebserverState::clear_enabled() {
  enabled_ = false;
}
inline bool WebserverState::_internal_enabled() const {
  return enabled_;
}
inline bool WebserverState::enabled() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.WebserverState.Enabled)
  return _internal_enabled();
}
inline void WebserverState::_internal_set_enabled(bool value) {
  
  enabled_ = value;
}
inline void WebserverState::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.WebserverState.Enabled)
}

// -------------------------------------------------------------------

// Brightness

// uint32 OLEDs = 1;
inline void Brightness::clear_oleds() {
  oleds_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Brightness::_internal_oleds() const {
  return oleds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Brightness::oleds() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Brightness.OLEDs)
  return _internal_oleds();
}
inline void Brightness::_internal_set_oleds(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  oleds_ = value;
}
inline void Brightness::set_oleds(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_oleds(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Brightness.OLEDs)
}

// uint32 LEDs = 2;
inline void Brightness::clear_leds() {
  leds_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Brightness::_internal_leds() const {
  return leds_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Brightness::leds() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Brightness.LEDs)
  return _internal_leds();
}
inline void Brightness::_internal_set_leds(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  leds_ = value;
}
inline void Brightness::set_leds(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_leds(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.Brightness.LEDs)
}

// -------------------------------------------------------------------

// HWCState

// repeated uint32 HWCIDs = 1;
inline int HWCState::_internal_hwcids_size() const {
  return hwcids_.size();
}
inline int HWCState::hwcids_size() const {
  return _internal_hwcids_size();
}
inline void HWCState::clear_hwcids() {
  hwcids_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCState::_internal_hwcids(int index) const {
  return hwcids_.Get(index);
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCState::hwcids(int index) const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.HWCIDs)
  return _internal_hwcids(index);
}
inline void HWCState::set_hwcids(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  hwcids_.Set(index, value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCState.HWCIDs)
}
inline void HWCState::_internal_add_hwcids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  hwcids_.Add(value);
}
inline void HWCState::add_hwcids(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_add_hwcids(value);
  // @@protoc_insertion_point(field_add:ibeam_rawpanel.HWCState.HWCIDs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
HWCState::_internal_hwcids() const {
  return hwcids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
HWCState::hwcids() const {
  // @@protoc_insertion_point(field_list:ibeam_rawpanel.HWCState.HWCIDs)
  return _internal_hwcids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
HWCState::_internal_mutable_hwcids() {
  return &hwcids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
HWCState::mutable_hwcids() {
  // @@protoc_insertion_point(field_mutable_list:ibeam_rawpanel.HWCState.HWCIDs)
  return _internal_mutable_hwcids();
}

// .ibeam_rawpanel.HWCMode HWCMode = 2;
inline bool HWCState::_internal_has_hwcmode() const {
  return this != internal_default_instance() && hwcmode_ != nullptr;
}
inline bool HWCState::has_hwcmode() const {
  return _internal_has_hwcmode();
}
inline void HWCState::clear_hwcmode() {
  if (GetArena() == nullptr && hwcmode_ != nullptr) {
    delete hwcmode_;
  }
  hwcmode_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCMode& HWCState::_internal_hwcmode() const {
  const ::ibeam_rawpanel::HWCMode* p = hwcmode_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::HWCMode&>(
      ::ibeam_rawpanel::_HWCMode_default_instance_);
}
inline const ::ibeam_rawpanel::HWCMode& HWCState::hwcmode() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.HWCMode)
  return _internal_hwcmode();
}
inline void HWCState::unsafe_arena_set_allocated_hwcmode(
    ::ibeam_rawpanel::HWCMode* hwcmode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hwcmode_);
  }
  hwcmode_ = hwcmode;
  if (hwcmode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCState.HWCMode)
}
inline ::ibeam_rawpanel::HWCMode* HWCState::release_hwcmode() {
  
  ::ibeam_rawpanel::HWCMode* temp = hwcmode_;
  hwcmode_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCMode* HWCState::unsafe_arena_release_hwcmode() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCState.HWCMode)
  
  ::ibeam_rawpanel::HWCMode* temp = hwcmode_;
  hwcmode_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCMode* HWCState::_internal_mutable_hwcmode() {
  
  if (hwcmode_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCMode>(GetArena());
    hwcmode_ = p;
  }
  return hwcmode_;
}
inline ::ibeam_rawpanel::HWCMode* HWCState::mutable_hwcmode() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCState.HWCMode)
  return _internal_mutable_hwcmode();
}
inline void HWCState::set_allocated_hwcmode(::ibeam_rawpanel::HWCMode* hwcmode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hwcmode_;
  }
  if (hwcmode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hwcmode);
    if (message_arena != submessage_arena) {
      hwcmode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hwcmode, submessage_arena);
    }
    
  } else {
    
  }
  hwcmode_ = hwcmode;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCState.HWCMode)
}

// .ibeam_rawpanel.HWCColor HWCColor = 3;
inline bool HWCState::_internal_has_hwccolor() const {
  return this != internal_default_instance() && hwccolor_ != nullptr;
}
inline bool HWCState::has_hwccolor() const {
  return _internal_has_hwccolor();
}
inline void HWCState::clear_hwccolor() {
  if (GetArena() == nullptr && hwccolor_ != nullptr) {
    delete hwccolor_;
  }
  hwccolor_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCColor& HWCState::_internal_hwccolor() const {
  const ::ibeam_rawpanel::HWCColor* p = hwccolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::HWCColor&>(
      ::ibeam_rawpanel::_HWCColor_default_instance_);
}
inline const ::ibeam_rawpanel::HWCColor& HWCState::hwccolor() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.HWCColor)
  return _internal_hwccolor();
}
inline void HWCState::unsafe_arena_set_allocated_hwccolor(
    ::ibeam_rawpanel::HWCColor* hwccolor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hwccolor_);
  }
  hwccolor_ = hwccolor;
  if (hwccolor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCState.HWCColor)
}
inline ::ibeam_rawpanel::HWCColor* HWCState::release_hwccolor() {
  
  ::ibeam_rawpanel::HWCColor* temp = hwccolor_;
  hwccolor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCColor* HWCState::unsafe_arena_release_hwccolor() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCState.HWCColor)
  
  ::ibeam_rawpanel::HWCColor* temp = hwccolor_;
  hwccolor_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCColor* HWCState::_internal_mutable_hwccolor() {
  
  if (hwccolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCColor>(GetArena());
    hwccolor_ = p;
  }
  return hwccolor_;
}
inline ::ibeam_rawpanel::HWCColor* HWCState::mutable_hwccolor() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCState.HWCColor)
  return _internal_mutable_hwccolor();
}
inline void HWCState::set_allocated_hwccolor(::ibeam_rawpanel::HWCColor* hwccolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hwccolor_;
  }
  if (hwccolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hwccolor);
    if (message_arena != submessage_arena) {
      hwccolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hwccolor, submessage_arena);
    }
    
  } else {
    
  }
  hwccolor_ = hwccolor;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCState.HWCColor)
}

// .ibeam_rawpanel.HWCExtended HWCExtended = 4;
inline bool HWCState::_internal_has_hwcextended() const {
  return this != internal_default_instance() && hwcextended_ != nullptr;
}
inline bool HWCState::has_hwcextended() const {
  return _internal_has_hwcextended();
}
inline void HWCState::clear_hwcextended() {
  if (GetArena() == nullptr && hwcextended_ != nullptr) {
    delete hwcextended_;
  }
  hwcextended_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCExtended& HWCState::_internal_hwcextended() const {
  const ::ibeam_rawpanel::HWCExtended* p = hwcextended_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::HWCExtended&>(
      ::ibeam_rawpanel::_HWCExtended_default_instance_);
}
inline const ::ibeam_rawpanel::HWCExtended& HWCState::hwcextended() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.HWCExtended)
  return _internal_hwcextended();
}
inline void HWCState::unsafe_arena_set_allocated_hwcextended(
    ::ibeam_rawpanel::HWCExtended* hwcextended) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hwcextended_);
  }
  hwcextended_ = hwcextended;
  if (hwcextended) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCState.HWCExtended)
}
inline ::ibeam_rawpanel::HWCExtended* HWCState::release_hwcextended() {
  
  ::ibeam_rawpanel::HWCExtended* temp = hwcextended_;
  hwcextended_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCExtended* HWCState::unsafe_arena_release_hwcextended() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCState.HWCExtended)
  
  ::ibeam_rawpanel::HWCExtended* temp = hwcextended_;
  hwcextended_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCExtended* HWCState::_internal_mutable_hwcextended() {
  
  if (hwcextended_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCExtended>(GetArena());
    hwcextended_ = p;
  }
  return hwcextended_;
}
inline ::ibeam_rawpanel::HWCExtended* HWCState::mutable_hwcextended() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCState.HWCExtended)
  return _internal_mutable_hwcextended();
}
inline void HWCState::set_allocated_hwcextended(::ibeam_rawpanel::HWCExtended* hwcextended) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hwcextended_;
  }
  if (hwcextended) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hwcextended);
    if (message_arena != submessage_arena) {
      hwcextended = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hwcextended, submessage_arena);
    }
    
  } else {
    
  }
  hwcextended_ = hwcextended;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCState.HWCExtended)
}

// .ibeam_rawpanel.HWCText HWCText = 5;
inline bool HWCState::_internal_has_hwctext() const {
  return this != internal_default_instance() && hwctext_ != nullptr;
}
inline bool HWCState::has_hwctext() const {
  return _internal_has_hwctext();
}
inline void HWCState::clear_hwctext() {
  if (GetArena() == nullptr && hwctext_ != nullptr) {
    delete hwctext_;
  }
  hwctext_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCText& HWCState::_internal_hwctext() const {
  const ::ibeam_rawpanel::HWCText* p = hwctext_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::HWCText&>(
      ::ibeam_rawpanel::_HWCText_default_instance_);
}
inline const ::ibeam_rawpanel::HWCText& HWCState::hwctext() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.HWCText)
  return _internal_hwctext();
}
inline void HWCState::unsafe_arena_set_allocated_hwctext(
    ::ibeam_rawpanel::HWCText* hwctext) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hwctext_);
  }
  hwctext_ = hwctext;
  if (hwctext) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCState.HWCText)
}
inline ::ibeam_rawpanel::HWCText* HWCState::release_hwctext() {
  
  ::ibeam_rawpanel::HWCText* temp = hwctext_;
  hwctext_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCText* HWCState::unsafe_arena_release_hwctext() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCState.HWCText)
  
  ::ibeam_rawpanel::HWCText* temp = hwctext_;
  hwctext_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCText* HWCState::_internal_mutable_hwctext() {
  
  if (hwctext_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCText>(GetArena());
    hwctext_ = p;
  }
  return hwctext_;
}
inline ::ibeam_rawpanel::HWCText* HWCState::mutable_hwctext() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCState.HWCText)
  return _internal_mutable_hwctext();
}
inline void HWCState::set_allocated_hwctext(::ibeam_rawpanel::HWCText* hwctext) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hwctext_;
  }
  if (hwctext) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hwctext);
    if (message_arena != submessage_arena) {
      hwctext = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hwctext, submessage_arena);
    }
    
  } else {
    
  }
  hwctext_ = hwctext;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCState.HWCText)
}

// .ibeam_rawpanel.HWCGfx HWCGfx = 6;
inline bool HWCState::_internal_has_hwcgfx() const {
  return this != internal_default_instance() && hwcgfx_ != nullptr;
}
inline bool HWCState::has_hwcgfx() const {
  return _internal_has_hwcgfx();
}
inline void HWCState::clear_hwcgfx() {
  if (GetArena() == nullptr && hwcgfx_ != nullptr) {
    delete hwcgfx_;
  }
  hwcgfx_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCGfx& HWCState::_internal_hwcgfx() const {
  const ::ibeam_rawpanel::HWCGfx* p = hwcgfx_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::HWCGfx&>(
      ::ibeam_rawpanel::_HWCGfx_default_instance_);
}
inline const ::ibeam_rawpanel::HWCGfx& HWCState::hwcgfx() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.HWCGfx)
  return _internal_hwcgfx();
}
inline void HWCState::unsafe_arena_set_allocated_hwcgfx(
    ::ibeam_rawpanel::HWCGfx* hwcgfx) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hwcgfx_);
  }
  hwcgfx_ = hwcgfx;
  if (hwcgfx) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCState.HWCGfx)
}
inline ::ibeam_rawpanel::HWCGfx* HWCState::release_hwcgfx() {
  
  ::ibeam_rawpanel::HWCGfx* temp = hwcgfx_;
  hwcgfx_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCGfx* HWCState::unsafe_arena_release_hwcgfx() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCState.HWCGfx)
  
  ::ibeam_rawpanel::HWCGfx* temp = hwcgfx_;
  hwcgfx_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCGfx* HWCState::_internal_mutable_hwcgfx() {
  
  if (hwcgfx_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCGfx>(GetArena());
    hwcgfx_ = p;
  }
  return hwcgfx_;
}
inline ::ibeam_rawpanel::HWCGfx* HWCState::mutable_hwcgfx() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCState.HWCGfx)
  return _internal_mutable_hwcgfx();
}
inline void HWCState::set_allocated_hwcgfx(::ibeam_rawpanel::HWCGfx* hwcgfx) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete hwcgfx_;
  }
  if (hwcgfx) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(hwcgfx);
    if (message_arena != submessage_arena) {
      hwcgfx = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hwcgfx, submessage_arena);
    }
    
  } else {
    
  }
  hwcgfx_ = hwcgfx;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCState.HWCGfx)
}

// .ibeam_rawpanel.PublishRawADCValues PublishRawADCValues = 7;
inline bool HWCState::_internal_has_publishrawadcvalues() const {
  return this != internal_default_instance() && publishrawadcvalues_ != nullptr;
}
inline bool HWCState::has_publishrawadcvalues() const {
  return _internal_has_publishrawadcvalues();
}
inline void HWCState::clear_publishrawadcvalues() {
  if (GetArena() == nullptr && publishrawadcvalues_ != nullptr) {
    delete publishrawadcvalues_;
  }
  publishrawadcvalues_ = nullptr;
}
inline const ::ibeam_rawpanel::PublishRawADCValues& HWCState::_internal_publishrawadcvalues() const {
  const ::ibeam_rawpanel::PublishRawADCValues* p = publishrawadcvalues_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::PublishRawADCValues&>(
      ::ibeam_rawpanel::_PublishRawADCValues_default_instance_);
}
inline const ::ibeam_rawpanel::PublishRawADCValues& HWCState::publishrawadcvalues() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCState.PublishRawADCValues)
  return _internal_publishrawadcvalues();
}
inline void HWCState::unsafe_arena_set_allocated_publishrawadcvalues(
    ::ibeam_rawpanel::PublishRawADCValues* publishrawadcvalues) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(publishrawadcvalues_);
  }
  publishrawadcvalues_ = publishrawadcvalues;
  if (publishrawadcvalues) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCState.PublishRawADCValues)
}
inline ::ibeam_rawpanel::PublishRawADCValues* HWCState::release_publishrawadcvalues() {
  
  ::ibeam_rawpanel::PublishRawADCValues* temp = publishrawadcvalues_;
  publishrawadcvalues_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::PublishRawADCValues* HWCState::unsafe_arena_release_publishrawadcvalues() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCState.PublishRawADCValues)
  
  ::ibeam_rawpanel::PublishRawADCValues* temp = publishrawadcvalues_;
  publishrawadcvalues_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::PublishRawADCValues* HWCState::_internal_mutable_publishrawadcvalues() {
  
  if (publishrawadcvalues_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::PublishRawADCValues>(GetArena());
    publishrawadcvalues_ = p;
  }
  return publishrawadcvalues_;
}
inline ::ibeam_rawpanel::PublishRawADCValues* HWCState::mutable_publishrawadcvalues() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCState.PublishRawADCValues)
  return _internal_mutable_publishrawadcvalues();
}
inline void HWCState::set_allocated_publishrawadcvalues(::ibeam_rawpanel::PublishRawADCValues* publishrawadcvalues) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete publishrawadcvalues_;
  }
  if (publishrawadcvalues) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(publishrawadcvalues);
    if (message_arena != submessage_arena) {
      publishrawadcvalues = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, publishrawadcvalues, submessage_arena);
    }
    
  } else {
    
  }
  publishrawadcvalues_ = publishrawadcvalues;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCState.PublishRawADCValues)
}

// -------------------------------------------------------------------

// PublishRawADCValues

// bool enable = 1;
inline void PublishRawADCValues::clear_enable() {
  enable_ = false;
}
inline bool PublishRawADCValues::_internal_enable() const {
  return enable_;
}
inline bool PublishRawADCValues::enable() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PublishRawADCValues.enable)
  return _internal_enable();
}
inline void PublishRawADCValues::_internal_set_enable(bool value) {
  
  enable_ = value;
}
inline void PublishRawADCValues::set_enable(bool value) {
  _internal_set_enable(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PublishRawADCValues.enable)
}

// -------------------------------------------------------------------

// HWCMode

// .ibeam_rawpanel.HWCMode.StateE State = 2;
inline void HWCMode::clear_state() {
  state_ = 0;
}
inline ::ibeam_rawpanel::HWCMode_StateE HWCMode::_internal_state() const {
  return static_cast< ::ibeam_rawpanel::HWCMode_StateE >(state_);
}
inline ::ibeam_rawpanel::HWCMode_StateE HWCMode::state() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCMode.State)
  return _internal_state();
}
inline void HWCMode::_internal_set_state(::ibeam_rawpanel::HWCMode_StateE value) {
  
  state_ = value;
}
inline void HWCMode::set_state(::ibeam_rawpanel::HWCMode_StateE value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCMode.State)
}

// bool Output = 4;
inline void HWCMode::clear_output() {
  output_ = false;
}
inline bool HWCMode::_internal_output() const {
  return output_;
}
inline bool HWCMode::output() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCMode.Output)
  return _internal_output();
}
inline void HWCMode::_internal_set_output(bool value) {
  
  output_ = value;
}
inline void HWCMode::set_output(bool value) {
  _internal_set_output(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCMode.Output)
}

// uint32 BlinkPattern = 3;
inline void HWCMode::clear_blinkpattern() {
  blinkpattern_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCMode::_internal_blinkpattern() const {
  return blinkpattern_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCMode::blinkpattern() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCMode.BlinkPattern)
  return _internal_blinkpattern();
}
inline void HWCMode::_internal_set_blinkpattern(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  blinkpattern_ = value;
}
inline void HWCMode::set_blinkpattern(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_blinkpattern(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCMode.BlinkPattern)
}

// -------------------------------------------------------------------

// HWCExtended

// .ibeam_rawpanel.HWCExtended.InterpretationE Interpretation = 2;
inline void HWCExtended::clear_interpretation() {
  interpretation_ = 0;
}
inline ::ibeam_rawpanel::HWCExtended_InterpretationE HWCExtended::_internal_interpretation() const {
  return static_cast< ::ibeam_rawpanel::HWCExtended_InterpretationE >(interpretation_);
}
inline ::ibeam_rawpanel::HWCExtended_InterpretationE HWCExtended::interpretation() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCExtended.Interpretation)
  return _internal_interpretation();
}
inline void HWCExtended::_internal_set_interpretation(::ibeam_rawpanel::HWCExtended_InterpretationE value) {
  
  interpretation_ = value;
}
inline void HWCExtended::set_interpretation(::ibeam_rawpanel::HWCExtended_InterpretationE value) {
  _internal_set_interpretation(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCExtended.Interpretation)
}

// uint32 Value = 3;
inline void HWCExtended::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCExtended::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCExtended::value() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCExtended.Value)
  return _internal_value();
}
inline void HWCExtended::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void HWCExtended::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCExtended.Value)
}

// -------------------------------------------------------------------

// HWCColor

// .ibeam_rawpanel.ColorRGB ColorRGB = 1;
inline bool HWCColor::_internal_has_colorrgb() const {
  return this != internal_default_instance() && colorrgb_ != nullptr;
}
inline bool HWCColor::has_colorrgb() const {
  return _internal_has_colorrgb();
}
inline void HWCColor::clear_colorrgb() {
  if (GetArena() == nullptr && colorrgb_ != nullptr) {
    delete colorrgb_;
  }
  colorrgb_ = nullptr;
}
inline const ::ibeam_rawpanel::ColorRGB& HWCColor::_internal_colorrgb() const {
  const ::ibeam_rawpanel::ColorRGB* p = colorrgb_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::ColorRGB&>(
      ::ibeam_rawpanel::_ColorRGB_default_instance_);
}
inline const ::ibeam_rawpanel::ColorRGB& HWCColor::colorrgb() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCColor.ColorRGB)
  return _internal_colorrgb();
}
inline void HWCColor::unsafe_arena_set_allocated_colorrgb(
    ::ibeam_rawpanel::ColorRGB* colorrgb) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(colorrgb_);
  }
  colorrgb_ = colorrgb;
  if (colorrgb) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCColor.ColorRGB)
}
inline ::ibeam_rawpanel::ColorRGB* HWCColor::release_colorrgb() {
  
  ::ibeam_rawpanel::ColorRGB* temp = colorrgb_;
  colorrgb_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::ColorRGB* HWCColor::unsafe_arena_release_colorrgb() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCColor.ColorRGB)
  
  ::ibeam_rawpanel::ColorRGB* temp = colorrgb_;
  colorrgb_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::ColorRGB* HWCColor::_internal_mutable_colorrgb() {
  
  if (colorrgb_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::ColorRGB>(GetArena());
    colorrgb_ = p;
  }
  return colorrgb_;
}
inline ::ibeam_rawpanel::ColorRGB* HWCColor::mutable_colorrgb() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCColor.ColorRGB)
  return _internal_mutable_colorrgb();
}
inline void HWCColor::set_allocated_colorrgb(::ibeam_rawpanel::ColorRGB* colorrgb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete colorrgb_;
  }
  if (colorrgb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(colorrgb);
    if (message_arena != submessage_arena) {
      colorrgb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, colorrgb, submessage_arena);
    }
    
  } else {
    
  }
  colorrgb_ = colorrgb;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCColor.ColorRGB)
}

// .ibeam_rawpanel.ColorIndex ColorIndex = 2;
inline bool HWCColor::_internal_has_colorindex() const {
  return this != internal_default_instance() && colorindex_ != nullptr;
}
inline bool HWCColor::has_colorindex() const {
  return _internal_has_colorindex();
}
inline void HWCColor::clear_colorindex() {
  if (GetArena() == nullptr && colorindex_ != nullptr) {
    delete colorindex_;
  }
  colorindex_ = nullptr;
}
inline const ::ibeam_rawpanel::ColorIndex& HWCColor::_internal_colorindex() const {
  const ::ibeam_rawpanel::ColorIndex* p = colorindex_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::ColorIndex&>(
      ::ibeam_rawpanel::_ColorIndex_default_instance_);
}
inline const ::ibeam_rawpanel::ColorIndex& HWCColor::colorindex() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCColor.ColorIndex)
  return _internal_colorindex();
}
inline void HWCColor::unsafe_arena_set_allocated_colorindex(
    ::ibeam_rawpanel::ColorIndex* colorindex) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(colorindex_);
  }
  colorindex_ = colorindex;
  if (colorindex) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCColor.ColorIndex)
}
inline ::ibeam_rawpanel::ColorIndex* HWCColor::release_colorindex() {
  
  ::ibeam_rawpanel::ColorIndex* temp = colorindex_;
  colorindex_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::ColorIndex* HWCColor::unsafe_arena_release_colorindex() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCColor.ColorIndex)
  
  ::ibeam_rawpanel::ColorIndex* temp = colorindex_;
  colorindex_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::ColorIndex* HWCColor::_internal_mutable_colorindex() {
  
  if (colorindex_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::ColorIndex>(GetArena());
    colorindex_ = p;
  }
  return colorindex_;
}
inline ::ibeam_rawpanel::ColorIndex* HWCColor::mutable_colorindex() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCColor.ColorIndex)
  return _internal_mutable_colorindex();
}
inline void HWCColor::set_allocated_colorindex(::ibeam_rawpanel::ColorIndex* colorindex) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete colorindex_;
  }
  if (colorindex) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(colorindex);
    if (message_arena != submessage_arena) {
      colorindex = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, colorindex, submessage_arena);
    }
    
  } else {
    
  }
  colorindex_ = colorindex;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCColor.ColorIndex)
}

// -------------------------------------------------------------------

// Color

// .ibeam_rawpanel.ColorRGB ColorRGB = 1;
inline bool Color::_internal_has_colorrgb() const {
  return this != internal_default_instance() && colorrgb_ != nullptr;
}
inline bool Color::has_colorrgb() const {
  return _internal_has_colorrgb();
}
inline void Color::clear_colorrgb() {
  if (GetArena() == nullptr && colorrgb_ != nullptr) {
    delete colorrgb_;
  }
  colorrgb_ = nullptr;
}
inline const ::ibeam_rawpanel::ColorRGB& Color::_internal_colorrgb() const {
  const ::ibeam_rawpanel::ColorRGB* p = colorrgb_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::ColorRGB&>(
      ::ibeam_rawpanel::_ColorRGB_default_instance_);
}
inline const ::ibeam_rawpanel::ColorRGB& Color::colorrgb() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Color.ColorRGB)
  return _internal_colorrgb();
}
inline void Color::unsafe_arena_set_allocated_colorrgb(
    ::ibeam_rawpanel::ColorRGB* colorrgb) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(colorrgb_);
  }
  colorrgb_ = colorrgb;
  if (colorrgb) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.Color.ColorRGB)
}
inline ::ibeam_rawpanel::ColorRGB* Color::release_colorrgb() {
  
  ::ibeam_rawpanel::ColorRGB* temp = colorrgb_;
  colorrgb_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::ColorRGB* Color::unsafe_arena_release_colorrgb() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.Color.ColorRGB)
  
  ::ibeam_rawpanel::ColorRGB* temp = colorrgb_;
  colorrgb_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::ColorRGB* Color::_internal_mutable_colorrgb() {
  
  if (colorrgb_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::ColorRGB>(GetArena());
    colorrgb_ = p;
  }
  return colorrgb_;
}
inline ::ibeam_rawpanel::ColorRGB* Color::mutable_colorrgb() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.Color.ColorRGB)
  return _internal_mutable_colorrgb();
}
inline void Color::set_allocated_colorrgb(::ibeam_rawpanel::ColorRGB* colorrgb) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete colorrgb_;
  }
  if (colorrgb) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(colorrgb);
    if (message_arena != submessage_arena) {
      colorrgb = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, colorrgb, submessage_arena);
    }
    
  } else {
    
  }
  colorrgb_ = colorrgb;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.Color.ColorRGB)
}

// .ibeam_rawpanel.ColorIndex ColorIndex = 2;
inline bool Color::_internal_has_colorindex() const {
  return this != internal_default_instance() && colorindex_ != nullptr;
}
inline bool Color::has_colorindex() const {
  return _internal_has_colorindex();
}
inline void Color::clear_colorindex() {
  if (GetArena() == nullptr && colorindex_ != nullptr) {
    delete colorindex_;
  }
  colorindex_ = nullptr;
}
inline const ::ibeam_rawpanel::ColorIndex& Color::_internal_colorindex() const {
  const ::ibeam_rawpanel::ColorIndex* p = colorindex_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::ColorIndex&>(
      ::ibeam_rawpanel::_ColorIndex_default_instance_);
}
inline const ::ibeam_rawpanel::ColorIndex& Color::colorindex() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.Color.ColorIndex)
  return _internal_colorindex();
}
inline void Color::unsafe_arena_set_allocated_colorindex(
    ::ibeam_rawpanel::ColorIndex* colorindex) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(colorindex_);
  }
  colorindex_ = colorindex;
  if (colorindex) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.Color.ColorIndex)
}
inline ::ibeam_rawpanel::ColorIndex* Color::release_colorindex() {
  
  ::ibeam_rawpanel::ColorIndex* temp = colorindex_;
  colorindex_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::ColorIndex* Color::unsafe_arena_release_colorindex() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.Color.ColorIndex)
  
  ::ibeam_rawpanel::ColorIndex* temp = colorindex_;
  colorindex_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::ColorIndex* Color::_internal_mutable_colorindex() {
  
  if (colorindex_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::ColorIndex>(GetArena());
    colorindex_ = p;
  }
  return colorindex_;
}
inline ::ibeam_rawpanel::ColorIndex* Color::mutable_colorindex() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.Color.ColorIndex)
  return _internal_mutable_colorindex();
}
inline void Color::set_allocated_colorindex(::ibeam_rawpanel::ColorIndex* colorindex) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete colorindex_;
  }
  if (colorindex) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(colorindex);
    if (message_arena != submessage_arena) {
      colorindex = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, colorindex, submessage_arena);
    }
    
  } else {
    
  }
  colorindex_ = colorindex;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.Color.ColorIndex)
}

// -------------------------------------------------------------------

// ColorRGB

// uint32 Red = 1;
inline void ColorRGB::clear_red() {
  red_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColorRGB::_internal_red() const {
  return red_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColorRGB::red() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ColorRGB.Red)
  return _internal_red();
}
inline void ColorRGB::_internal_set_red(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  red_ = value;
}
inline void ColorRGB::set_red(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_red(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ColorRGB.Red)
}

// uint32 Green = 2;
inline void ColorRGB::clear_green() {
  green_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColorRGB::_internal_green() const {
  return green_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColorRGB::green() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ColorRGB.Green)
  return _internal_green();
}
inline void ColorRGB::_internal_set_green(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  green_ = value;
}
inline void ColorRGB::set_green(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_green(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ColorRGB.Green)
}

// uint32 Blue = 3;
inline void ColorRGB::clear_blue() {
  blue_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColorRGB::_internal_blue() const {
  return blue_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ColorRGB::blue() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ColorRGB.Blue)
  return _internal_blue();
}
inline void ColorRGB::_internal_set_blue(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  blue_ = value;
}
inline void ColorRGB::set_blue(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_blue(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ColorRGB.Blue)
}

// -------------------------------------------------------------------

// ColorIndex

// .ibeam_rawpanel.ColorIndex.Colors Index = 1;
inline void ColorIndex::clear_index() {
  index_ = 0;
}
inline ::ibeam_rawpanel::ColorIndex_Colors ColorIndex::_internal_index() const {
  return static_cast< ::ibeam_rawpanel::ColorIndex_Colors >(index_);
}
inline ::ibeam_rawpanel::ColorIndex_Colors ColorIndex::index() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ColorIndex.Index)
  return _internal_index();
}
inline void ColorIndex::_internal_set_index(::ibeam_rawpanel::ColorIndex_Colors value) {
  
  index_ = value;
}
inline void ColorIndex::set_index(::ibeam_rawpanel::ColorIndex_Colors value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ColorIndex.Index)
}

// -------------------------------------------------------------------

// HWCText_ScaleM

// .ibeam_rawpanel.HWCText.ScaleM.ScaleTypeE ScaleType = 1;
inline void HWCText_ScaleM::clear_scaletype() {
  scaletype_ = 0;
}
inline ::ibeam_rawpanel::HWCText_ScaleM_ScaleTypeE HWCText_ScaleM::_internal_scaletype() const {
  return static_cast< ::ibeam_rawpanel::HWCText_ScaleM_ScaleTypeE >(scaletype_);
}
inline ::ibeam_rawpanel::HWCText_ScaleM_ScaleTypeE HWCText_ScaleM::scaletype() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.ScaleM.ScaleType)
  return _internal_scaletype();
}
inline void HWCText_ScaleM::_internal_set_scaletype(::ibeam_rawpanel::HWCText_ScaleM_ScaleTypeE value) {
  
  scaletype_ = value;
}
inline void HWCText_ScaleM::set_scaletype(::ibeam_rawpanel::HWCText_ScaleM_ScaleTypeE value) {
  _internal_set_scaletype(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.ScaleM.ScaleType)
}

// sint32 RangeLow = 2;
inline void HWCText_ScaleM::clear_rangelow() {
  rangelow_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_ScaleM::_internal_rangelow() const {
  return rangelow_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_ScaleM::rangelow() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.ScaleM.RangeLow)
  return _internal_rangelow();
}
inline void HWCText_ScaleM::_internal_set_rangelow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rangelow_ = value;
}
inline void HWCText_ScaleM::set_rangelow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rangelow(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.ScaleM.RangeLow)
}

// sint32 RangeHigh = 3;
inline void HWCText_ScaleM::clear_rangehigh() {
  rangehigh_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_ScaleM::_internal_rangehigh() const {
  return rangehigh_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_ScaleM::rangehigh() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.ScaleM.RangeHigh)
  return _internal_rangehigh();
}
inline void HWCText_ScaleM::_internal_set_rangehigh(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rangehigh_ = value;
}
inline void HWCText_ScaleM::set_rangehigh(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rangehigh(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.ScaleM.RangeHigh)
}

// sint32 LimitLow = 4;
inline void HWCText_ScaleM::clear_limitlow() {
  limitlow_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_ScaleM::_internal_limitlow() const {
  return limitlow_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_ScaleM::limitlow() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.ScaleM.LimitLow)
  return _internal_limitlow();
}
inline void HWCText_ScaleM::_internal_set_limitlow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  limitlow_ = value;
}
inline void HWCText_ScaleM::set_limitlow(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_limitlow(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.ScaleM.LimitLow)
}

// sint32 LimitHigh = 5;
inline void HWCText_ScaleM::clear_limithigh() {
  limithigh_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_ScaleM::_internal_limithigh() const {
  return limithigh_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText_ScaleM::limithigh() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.ScaleM.LimitHigh)
  return _internal_limithigh();
}
inline void HWCText_ScaleM::_internal_set_limithigh(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  limithigh_ = value;
}
inline void HWCText_ScaleM::set_limithigh(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_limithigh(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.ScaleM.LimitHigh)
}

// -------------------------------------------------------------------

// HWCText_TextStyle_Font

// .ibeam_rawpanel.HWCText.TextStyle.Font.FontFaceE FontFace = 1;
inline void HWCText_TextStyle_Font::clear_fontface() {
  fontface_ = 0;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFaceE HWCText_TextStyle_Font::_internal_fontface() const {
  return static_cast< ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFaceE >(fontface_);
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFaceE HWCText_TextStyle_Font::fontface() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.Font.FontFace)
  return _internal_fontface();
}
inline void HWCText_TextStyle_Font::_internal_set_fontface(::ibeam_rawpanel::HWCText_TextStyle_Font_FontFaceE value) {
  
  fontface_ = value;
}
inline void HWCText_TextStyle_Font::set_fontface(::ibeam_rawpanel::HWCText_TextStyle_Font_FontFaceE value) {
  _internal_set_fontface(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.Font.FontFace)
}

// uint32 TextHeight = 2;
inline void HWCText_TextStyle_Font::clear_textheight() {
  textheight_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle_Font::_internal_textheight() const {
  return textheight_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle_Font::textheight() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.Font.TextHeight)
  return _internal_textheight();
}
inline void HWCText_TextStyle_Font::_internal_set_textheight(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  textheight_ = value;
}
inline void HWCText_TextStyle_Font::set_textheight(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_textheight(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.Font.TextHeight)
}

// uint32 TextWidth = 3;
inline void HWCText_TextStyle_Font::clear_textwidth() {
  textwidth_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle_Font::_internal_textwidth() const {
  return textwidth_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle_Font::textwidth() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.Font.TextWidth)
  return _internal_textwidth();
}
inline void HWCText_TextStyle_Font::_internal_set_textwidth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  textwidth_ = value;
}
inline void HWCText_TextStyle_Font::set_textwidth(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_textwidth(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.Font.TextWidth)
}

// -------------------------------------------------------------------

// HWCText_TextStyle

// .ibeam_rawpanel.HWCText.TextStyle.Font TitleFont = 1;
inline bool HWCText_TextStyle::_internal_has_titlefont() const {
  return this != internal_default_instance() && titlefont_ != nullptr;
}
inline bool HWCText_TextStyle::has_titlefont() const {
  return _internal_has_titlefont();
}
inline void HWCText_TextStyle::clear_titlefont() {
  if (GetArena() == nullptr && titlefont_ != nullptr) {
    delete titlefont_;
  }
  titlefont_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCText_TextStyle_Font& HWCText_TextStyle::_internal_titlefont() const {
  const ::ibeam_rawpanel::HWCText_TextStyle_Font* p = titlefont_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::HWCText_TextStyle_Font&>(
      ::ibeam_rawpanel::_HWCText_TextStyle_Font_default_instance_);
}
inline const ::ibeam_rawpanel::HWCText_TextStyle_Font& HWCText_TextStyle::titlefont() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.TitleFont)
  return _internal_titlefont();
}
inline void HWCText_TextStyle::unsafe_arena_set_allocated_titlefont(
    ::ibeam_rawpanel::HWCText_TextStyle_Font* titlefont) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(titlefont_);
  }
  titlefont_ = titlefont;
  if (titlefont) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCText.TextStyle.TitleFont)
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::release_titlefont() {
  
  ::ibeam_rawpanel::HWCText_TextStyle_Font* temp = titlefont_;
  titlefont_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::unsafe_arena_release_titlefont() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.TextStyle.TitleFont)
  
  ::ibeam_rawpanel::HWCText_TextStyle_Font* temp = titlefont_;
  titlefont_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::_internal_mutable_titlefont() {
  
  if (titlefont_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCText_TextStyle_Font>(GetArena());
    titlefont_ = p;
  }
  return titlefont_;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::mutable_titlefont() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.TextStyle.TitleFont)
  return _internal_mutable_titlefont();
}
inline void HWCText_TextStyle::set_allocated_titlefont(::ibeam_rawpanel::HWCText_TextStyle_Font* titlefont) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete titlefont_;
  }
  if (titlefont) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(titlefont);
    if (message_arena != submessage_arena) {
      titlefont = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, titlefont, submessage_arena);
    }
    
  } else {
    
  }
  titlefont_ = titlefont;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.TextStyle.TitleFont)
}

// .ibeam_rawpanel.HWCText.TextStyle.Font TextFont = 2;
inline bool HWCText_TextStyle::_internal_has_textfont() const {
  return this != internal_default_instance() && textfont_ != nullptr;
}
inline bool HWCText_TextStyle::has_textfont() const {
  return _internal_has_textfont();
}
inline void HWCText_TextStyle::clear_textfont() {
  if (GetArena() == nullptr && textfont_ != nullptr) {
    delete textfont_;
  }
  textfont_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCText_TextStyle_Font& HWCText_TextStyle::_internal_textfont() const {
  const ::ibeam_rawpanel::HWCText_TextStyle_Font* p = textfont_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::HWCText_TextStyle_Font&>(
      ::ibeam_rawpanel::_HWCText_TextStyle_Font_default_instance_);
}
inline const ::ibeam_rawpanel::HWCText_TextStyle_Font& HWCText_TextStyle::textfont() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.TextFont)
  return _internal_textfont();
}
inline void HWCText_TextStyle::unsafe_arena_set_allocated_textfont(
    ::ibeam_rawpanel::HWCText_TextStyle_Font* textfont) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(textfont_);
  }
  textfont_ = textfont;
  if (textfont) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCText.TextStyle.TextFont)
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::release_textfont() {
  
  ::ibeam_rawpanel::HWCText_TextStyle_Font* temp = textfont_;
  textfont_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::unsafe_arena_release_textfont() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.TextStyle.TextFont)
  
  ::ibeam_rawpanel::HWCText_TextStyle_Font* temp = textfont_;
  textfont_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::_internal_mutable_textfont() {
  
  if (textfont_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCText_TextStyle_Font>(GetArena());
    textfont_ = p;
  }
  return textfont_;
}
inline ::ibeam_rawpanel::HWCText_TextStyle_Font* HWCText_TextStyle::mutable_textfont() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.TextStyle.TextFont)
  return _internal_mutable_textfont();
}
inline void HWCText_TextStyle::set_allocated_textfont(::ibeam_rawpanel::HWCText_TextStyle_Font* textfont) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete textfont_;
  }
  if (textfont) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(textfont);
    if (message_arena != submessage_arena) {
      textfont = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, textfont, submessage_arena);
    }
    
  } else {
    
  }
  textfont_ = textfont;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.TextStyle.TextFont)
}

// bool FixedWidth = 3;
inline void HWCText_TextStyle::clear_fixedwidth() {
  fixedwidth_ = false;
}
inline bool HWCText_TextStyle::_internal_fixedwidth() const {
  return fixedwidth_;
}
inline bool HWCText_TextStyle::fixedwidth() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.FixedWidth)
  return _internal_fixedwidth();
}
inline void HWCText_TextStyle::_internal_set_fixedwidth(bool value) {
  
  fixedwidth_ = value;
}
inline void HWCText_TextStyle::set_fixedwidth(bool value) {
  _internal_set_fixedwidth(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.FixedWidth)
}

// uint32 TitleBarPadding = 4;
inline void HWCText_TextStyle::clear_titlebarpadding() {
  titlebarpadding_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle::_internal_titlebarpadding() const {
  return titlebarpadding_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle::titlebarpadding() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.TitleBarPadding)
  return _internal_titlebarpadding();
}
inline void HWCText_TextStyle::_internal_set_titlebarpadding(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  titlebarpadding_ = value;
}
inline void HWCText_TextStyle::set_titlebarpadding(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_titlebarpadding(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.TitleBarPadding)
}

// uint32 ExtraCharacterSpacing = 5;
inline void HWCText_TextStyle::clear_extracharacterspacing() {
  extracharacterspacing_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle::_internal_extracharacterspacing() const {
  return extracharacterspacing_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle::extracharacterspacing() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.ExtraCharacterSpacing)
  return _internal_extracharacterspacing();
}
inline void HWCText_TextStyle::_internal_set_extracharacterspacing(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  extracharacterspacing_ = value;
}
inline void HWCText_TextStyle::set_extracharacterspacing(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_extracharacterspacing(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.ExtraCharacterSpacing)
}

// uint32 UnformattedFontSize = 6;
inline void HWCText_TextStyle::clear_unformattedfontsize() {
  unformattedfontsize_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle::_internal_unformattedfontsize() const {
  return unformattedfontsize_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCText_TextStyle::unformattedfontsize() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyle.UnformattedFontSize)
  return _internal_unformattedfontsize();
}
inline void HWCText_TextStyle::_internal_set_unformattedfontsize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  unformattedfontsize_ = value;
}
inline void HWCText_TextStyle::set_unformattedfontsize(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_unformattedfontsize(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.TextStyle.UnformattedFontSize)
}

// -------------------------------------------------------------------

// HWCText

// sint32 IntegerValue = 2;
inline void HWCText::clear_integervalue() {
  integervalue_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText::_internal_integervalue() const {
  return integervalue_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText::integervalue() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.IntegerValue)
  return _internal_integervalue();
}
inline void HWCText::_internal_set_integervalue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  integervalue_ = value;
}
inline void HWCText::set_integervalue(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_integervalue(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.IntegerValue)
}

// .ibeam_rawpanel.HWCText.FormattingE Formatting = 3;
inline void HWCText::clear_formatting() {
  formatting_ = 0;
}
inline ::ibeam_rawpanel::HWCText_FormattingE HWCText::_internal_formatting() const {
  return static_cast< ::ibeam_rawpanel::HWCText_FormattingE >(formatting_);
}
inline ::ibeam_rawpanel::HWCText_FormattingE HWCText::formatting() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Formatting)
  return _internal_formatting();
}
inline void HWCText::_internal_set_formatting(::ibeam_rawpanel::HWCText_FormattingE value) {
  
  formatting_ = value;
}
inline void HWCText::set_formatting(::ibeam_rawpanel::HWCText_FormattingE value) {
  _internal_set_formatting(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Formatting)
}

// .ibeam_rawpanel.HWCText.StateIconE StateIcon = 5;
inline void HWCText::clear_stateicon() {
  stateicon_ = 0;
}
inline ::ibeam_rawpanel::HWCText_StateIconE HWCText::_internal_stateicon() const {
  return static_cast< ::ibeam_rawpanel::HWCText_StateIconE >(stateicon_);
}
inline ::ibeam_rawpanel::HWCText_StateIconE HWCText::stateicon() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.StateIcon)
  return _internal_stateicon();
}
inline void HWCText::_internal_set_stateicon(::ibeam_rawpanel::HWCText_StateIconE value) {
  
  stateicon_ = value;
}
inline void HWCText::set_stateicon(::ibeam_rawpanel::HWCText_StateIconE value) {
  _internal_set_stateicon(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.StateIcon)
}

// .ibeam_rawpanel.HWCText.ModifierIconE ModifierIcon = 6;
inline void HWCText::clear_modifiericon() {
  modifiericon_ = 0;
}
inline ::ibeam_rawpanel::HWCText_ModifierIconE HWCText::_internal_modifiericon() const {
  return static_cast< ::ibeam_rawpanel::HWCText_ModifierIconE >(modifiericon_);
}
inline ::ibeam_rawpanel::HWCText_ModifierIconE HWCText::modifiericon() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.ModifierIcon)
  return _internal_modifiericon();
}
inline void HWCText::_internal_set_modifiericon(::ibeam_rawpanel::HWCText_ModifierIconE value) {
  
  modifiericon_ = value;
}
inline void HWCText::set_modifiericon(::ibeam_rawpanel::HWCText_ModifierIconE value) {
  _internal_set_modifiericon(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.ModifierIcon)
}

// string Title = 7;
inline void HWCText::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& HWCText::title() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Title)
  return _internal_title();
}
inline void HWCText::set_title(const std::string& value) {
  _internal_set_title(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Title)
}
inline std::string* HWCText::mutable_title() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.Title)
  return _internal_mutable_title();
}
inline const std::string& HWCText::_internal_title() const {
  return title_.Get();
}
inline void HWCText::_internal_set_title(const std::string& value) {
  
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HWCText::set_title(std::string&& value) {
  
  title_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.HWCText.Title)
}
inline void HWCText::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.HWCText.Title)
}
inline void HWCText::set_title(const char* value,
    size_t size) {
  
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.HWCText.Title)
}
inline std::string* HWCText::_internal_mutable_title() {
  
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HWCText::release_title() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.Title)
  return title_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HWCText::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.Title)
}

// bool SolidHeaderBar = 8;
inline void HWCText::clear_solidheaderbar() {
  solidheaderbar_ = false;
}
inline bool HWCText::_internal_solidheaderbar() const {
  return solidheaderbar_;
}
inline bool HWCText::solidheaderbar() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.SolidHeaderBar)
  return _internal_solidheaderbar();
}
inline void HWCText::_internal_set_solidheaderbar(bool value) {
  
  solidheaderbar_ = value;
}
inline void HWCText::set_solidheaderbar(bool value) {
  _internal_set_solidheaderbar(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.SolidHeaderBar)
}

// string Textline1 = 9;
inline void HWCText::clear_textline1() {
  textline1_.ClearToEmpty();
}
inline const std::string& HWCText::textline1() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Textline1)
  return _internal_textline1();
}
inline void HWCText::set_textline1(const std::string& value) {
  _internal_set_textline1(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Textline1)
}
inline std::string* HWCText::mutable_textline1() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.Textline1)
  return _internal_mutable_textline1();
}
inline const std::string& HWCText::_internal_textline1() const {
  return textline1_.Get();
}
inline void HWCText::_internal_set_textline1(const std::string& value) {
  
  textline1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HWCText::set_textline1(std::string&& value) {
  
  textline1_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.HWCText.Textline1)
}
inline void HWCText::set_textline1(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  textline1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.HWCText.Textline1)
}
inline void HWCText::set_textline1(const char* value,
    size_t size) {
  
  textline1_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.HWCText.Textline1)
}
inline std::string* HWCText::_internal_mutable_textline1() {
  
  return textline1_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HWCText::release_textline1() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.Textline1)
  return textline1_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HWCText::set_allocated_textline1(std::string* textline1) {
  if (textline1 != nullptr) {
    
  } else {
    
  }
  textline1_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), textline1,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.Textline1)
}

// string Textline2 = 10;
inline void HWCText::clear_textline2() {
  textline2_.ClearToEmpty();
}
inline const std::string& HWCText::textline2() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Textline2)
  return _internal_textline2();
}
inline void HWCText::set_textline2(const std::string& value) {
  _internal_set_textline2(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Textline2)
}
inline std::string* HWCText::mutable_textline2() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.Textline2)
  return _internal_mutable_textline2();
}
inline const std::string& HWCText::_internal_textline2() const {
  return textline2_.Get();
}
inline void HWCText::_internal_set_textline2(const std::string& value) {
  
  textline2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HWCText::set_textline2(std::string&& value) {
  
  textline2_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.HWCText.Textline2)
}
inline void HWCText::set_textline2(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  textline2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.HWCText.Textline2)
}
inline void HWCText::set_textline2(const char* value,
    size_t size) {
  
  textline2_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.HWCText.Textline2)
}
inline std::string* HWCText::_internal_mutable_textline2() {
  
  return textline2_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HWCText::release_textline2() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.Textline2)
  return textline2_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HWCText::set_allocated_textline2(std::string* textline2) {
  if (textline2 != nullptr) {
    
  } else {
    
  }
  textline2_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), textline2,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.Textline2)
}

// sint32 IntegerValue2 = 11;
inline void HWCText::clear_integervalue2() {
  integervalue2_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText::_internal_integervalue2() const {
  return integervalue2_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 HWCText::integervalue2() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.IntegerValue2)
  return _internal_integervalue2();
}
inline void HWCText::_internal_set_integervalue2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  integervalue2_ = value;
}
inline void HWCText::set_integervalue2(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_integervalue2(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.IntegerValue2)
}

// .ibeam_rawpanel.HWCText.PairModeE PairMode = 12;
inline void HWCText::clear_pairmode() {
  pairmode_ = 0;
}
inline ::ibeam_rawpanel::HWCText_PairModeE HWCText::_internal_pairmode() const {
  return static_cast< ::ibeam_rawpanel::HWCText_PairModeE >(pairmode_);
}
inline ::ibeam_rawpanel::HWCText_PairModeE HWCText::pairmode() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.PairMode)
  return _internal_pairmode();
}
inline void HWCText::_internal_set_pairmode(::ibeam_rawpanel::HWCText_PairModeE value) {
  
  pairmode_ = value;
}
inline void HWCText::set_pairmode(::ibeam_rawpanel::HWCText_PairModeE value) {
  _internal_set_pairmode(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.PairMode)
}

// .ibeam_rawpanel.HWCText.ScaleM Scale = 13;
inline bool HWCText::_internal_has_scale() const {
  return this != internal_default_instance() && scale_ != nullptr;
}
inline bool HWCText::has_scale() const {
  return _internal_has_scale();
}
inline void HWCText::clear_scale() {
  if (GetArena() == nullptr && scale_ != nullptr) {
    delete scale_;
  }
  scale_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCText_ScaleM& HWCText::_internal_scale() const {
  const ::ibeam_rawpanel::HWCText_ScaleM* p = scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::HWCText_ScaleM&>(
      ::ibeam_rawpanel::_HWCText_ScaleM_default_instance_);
}
inline const ::ibeam_rawpanel::HWCText_ScaleM& HWCText::scale() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Scale)
  return _internal_scale();
}
inline void HWCText::unsafe_arena_set_allocated_scale(
    ::ibeam_rawpanel::HWCText_ScaleM* scale) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(scale_);
  }
  scale_ = scale;
  if (scale) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCText.Scale)
}
inline ::ibeam_rawpanel::HWCText_ScaleM* HWCText::release_scale() {
  
  ::ibeam_rawpanel::HWCText_ScaleM* temp = scale_;
  scale_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCText_ScaleM* HWCText::unsafe_arena_release_scale() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.Scale)
  
  ::ibeam_rawpanel::HWCText_ScaleM* temp = scale_;
  scale_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCText_ScaleM* HWCText::_internal_mutable_scale() {
  
  if (scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCText_ScaleM>(GetArena());
    scale_ = p;
  }
  return scale_;
}
inline ::ibeam_rawpanel::HWCText_ScaleM* HWCText::mutable_scale() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.Scale)
  return _internal_mutable_scale();
}
inline void HWCText::set_allocated_scale(::ibeam_rawpanel::HWCText_ScaleM* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete scale_;
  }
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(scale);
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    
  } else {
    
  }
  scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.Scale)
}

// .ibeam_rawpanel.HWCText.TextStyle TextStyling = 14;
inline bool HWCText::_internal_has_textstyling() const {
  return this != internal_default_instance() && textstyling_ != nullptr;
}
inline bool HWCText::has_textstyling() const {
  return _internal_has_textstyling();
}
inline void HWCText::clear_textstyling() {
  if (GetArena() == nullptr && textstyling_ != nullptr) {
    delete textstyling_;
  }
  textstyling_ = nullptr;
}
inline const ::ibeam_rawpanel::HWCText_TextStyle& HWCText::_internal_textstyling() const {
  const ::ibeam_rawpanel::HWCText_TextStyle* p = textstyling_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::HWCText_TextStyle&>(
      ::ibeam_rawpanel::_HWCText_TextStyle_default_instance_);
}
inline const ::ibeam_rawpanel::HWCText_TextStyle& HWCText::textstyling() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.TextStyling)
  return _internal_textstyling();
}
inline void HWCText::unsafe_arena_set_allocated_textstyling(
    ::ibeam_rawpanel::HWCText_TextStyle* textstyling) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(textstyling_);
  }
  textstyling_ = textstyling;
  if (textstyling) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCText.TextStyling)
}
inline ::ibeam_rawpanel::HWCText_TextStyle* HWCText::release_textstyling() {
  
  ::ibeam_rawpanel::HWCText_TextStyle* temp = textstyling_;
  textstyling_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::HWCText_TextStyle* HWCText::unsafe_arena_release_textstyling() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.TextStyling)
  
  ::ibeam_rawpanel::HWCText_TextStyle* temp = textstyling_;
  textstyling_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::HWCText_TextStyle* HWCText::_internal_mutable_textstyling() {
  
  if (textstyling_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::HWCText_TextStyle>(GetArena());
    textstyling_ = p;
  }
  return textstyling_;
}
inline ::ibeam_rawpanel::HWCText_TextStyle* HWCText::mutable_textstyling() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.TextStyling)
  return _internal_mutable_textstyling();
}
inline void HWCText::set_allocated_textstyling(::ibeam_rawpanel::HWCText_TextStyle* textstyling) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete textstyling_;
  }
  if (textstyling) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(textstyling);
    if (message_arena != submessage_arena) {
      textstyling = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, textstyling, submessage_arena);
    }
    
  } else {
    
  }
  textstyling_ = textstyling;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.TextStyling)
}

// bool Inverted = 15;
inline void HWCText::clear_inverted() {
  inverted_ = false;
}
inline bool HWCText::_internal_inverted() const {
  return inverted_;
}
inline bool HWCText::inverted() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.Inverted)
  return _internal_inverted();
}
inline void HWCText::_internal_set_inverted(bool value) {
  
  inverted_ = value;
}
inline void HWCText::set_inverted(bool value) {
  _internal_set_inverted(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCText.Inverted)
}

// .ibeam_rawpanel.Color PixelColor = 16;
inline bool HWCText::_internal_has_pixelcolor() const {
  return this != internal_default_instance() && pixelcolor_ != nullptr;
}
inline bool HWCText::has_pixelcolor() const {
  return _internal_has_pixelcolor();
}
inline void HWCText::clear_pixelcolor() {
  if (GetArena() == nullptr && pixelcolor_ != nullptr) {
    delete pixelcolor_;
  }
  pixelcolor_ = nullptr;
}
inline const ::ibeam_rawpanel::Color& HWCText::_internal_pixelcolor() const {
  const ::ibeam_rawpanel::Color* p = pixelcolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::Color&>(
      ::ibeam_rawpanel::_Color_default_instance_);
}
inline const ::ibeam_rawpanel::Color& HWCText::pixelcolor() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.PixelColor)
  return _internal_pixelcolor();
}
inline void HWCText::unsafe_arena_set_allocated_pixelcolor(
    ::ibeam_rawpanel::Color* pixelcolor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pixelcolor_);
  }
  pixelcolor_ = pixelcolor;
  if (pixelcolor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCText.PixelColor)
}
inline ::ibeam_rawpanel::Color* HWCText::release_pixelcolor() {
  
  ::ibeam_rawpanel::Color* temp = pixelcolor_;
  pixelcolor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::Color* HWCText::unsafe_arena_release_pixelcolor() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.PixelColor)
  
  ::ibeam_rawpanel::Color* temp = pixelcolor_;
  pixelcolor_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::Color* HWCText::_internal_mutable_pixelcolor() {
  
  if (pixelcolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::Color>(GetArena());
    pixelcolor_ = p;
  }
  return pixelcolor_;
}
inline ::ibeam_rawpanel::Color* HWCText::mutable_pixelcolor() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.PixelColor)
  return _internal_mutable_pixelcolor();
}
inline void HWCText::set_allocated_pixelcolor(::ibeam_rawpanel::Color* pixelcolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pixelcolor_;
  }
  if (pixelcolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pixelcolor);
    if (message_arena != submessage_arena) {
      pixelcolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pixelcolor, submessage_arena);
    }
    
  } else {
    
  }
  pixelcolor_ = pixelcolor;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.PixelColor)
}

// .ibeam_rawpanel.Color BackgroundColor = 17;
inline bool HWCText::_internal_has_backgroundcolor() const {
  return this != internal_default_instance() && backgroundcolor_ != nullptr;
}
inline bool HWCText::has_backgroundcolor() const {
  return _internal_has_backgroundcolor();
}
inline void HWCText::clear_backgroundcolor() {
  if (GetArena() == nullptr && backgroundcolor_ != nullptr) {
    delete backgroundcolor_;
  }
  backgroundcolor_ = nullptr;
}
inline const ::ibeam_rawpanel::Color& HWCText::_internal_backgroundcolor() const {
  const ::ibeam_rawpanel::Color* p = backgroundcolor_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::Color&>(
      ::ibeam_rawpanel::_Color_default_instance_);
}
inline const ::ibeam_rawpanel::Color& HWCText::backgroundcolor() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCText.BackgroundColor)
  return _internal_backgroundcolor();
}
inline void HWCText::unsafe_arena_set_allocated_backgroundcolor(
    ::ibeam_rawpanel::Color* backgroundcolor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(backgroundcolor_);
  }
  backgroundcolor_ = backgroundcolor;
  if (backgroundcolor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCText.BackgroundColor)
}
inline ::ibeam_rawpanel::Color* HWCText::release_backgroundcolor() {
  
  ::ibeam_rawpanel::Color* temp = backgroundcolor_;
  backgroundcolor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::Color* HWCText::unsafe_arena_release_backgroundcolor() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCText.BackgroundColor)
  
  ::ibeam_rawpanel::Color* temp = backgroundcolor_;
  backgroundcolor_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::Color* HWCText::_internal_mutable_backgroundcolor() {
  
  if (backgroundcolor_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::Color>(GetArena());
    backgroundcolor_ = p;
  }
  return backgroundcolor_;
}
inline ::ibeam_rawpanel::Color* HWCText::mutable_backgroundcolor() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCText.BackgroundColor)
  return _internal_mutable_backgroundcolor();
}
inline void HWCText::set_allocated_backgroundcolor(::ibeam_rawpanel::Color* backgroundcolor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete backgroundcolor_;
  }
  if (backgroundcolor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(backgroundcolor);
    if (message_arena != submessage_arena) {
      backgroundcolor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, backgroundcolor, submessage_arena);
    }
    
  } else {
    
  }
  backgroundcolor_ = backgroundcolor;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCText.BackgroundColor)
}

// -------------------------------------------------------------------

// HWCGfx

// .ibeam_rawpanel.HWCGfx.ImageTypeE ImageType = 1;
inline void HWCGfx::clear_imagetype() {
  imagetype_ = 0;
}
inline ::ibeam_rawpanel::HWCGfx_ImageTypeE HWCGfx::_internal_imagetype() const {
  return static_cast< ::ibeam_rawpanel::HWCGfx_ImageTypeE >(imagetype_);
}
inline ::ibeam_rawpanel::HWCGfx_ImageTypeE HWCGfx::imagetype() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.ImageType)
  return _internal_imagetype();
}
inline void HWCGfx::_internal_set_imagetype(::ibeam_rawpanel::HWCGfx_ImageTypeE value) {
  
  imagetype_ = value;
}
inline void HWCGfx::set_imagetype(::ibeam_rawpanel::HWCGfx_ImageTypeE value) {
  _internal_set_imagetype(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.ImageType)
}

// uint32 W = 2;
inline void HWCGfx::clear_w() {
  w_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::_internal_w() const {
  return w_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::w() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.W)
  return _internal_w();
}
inline void HWCGfx::_internal_set_w(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  w_ = value;
}
inline void HWCGfx::set_w(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.W)
}

// uint32 H = 3;
inline void HWCGfx::clear_h() {
  h_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::_internal_h() const {
  return h_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::h() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.H)
  return _internal_h();
}
inline void HWCGfx::_internal_set_h(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  h_ = value;
}
inline void HWCGfx::set_h(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_h(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.H)
}

// bool XYoffset = 4;
inline void HWCGfx::clear_xyoffset() {
  xyoffset_ = false;
}
inline bool HWCGfx::_internal_xyoffset() const {
  return xyoffset_;
}
inline bool HWCGfx::xyoffset() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.XYoffset)
  return _internal_xyoffset();
}
inline void HWCGfx::_internal_set_xyoffset(bool value) {
  
  xyoffset_ = value;
}
inline void HWCGfx::set_xyoffset(bool value) {
  _internal_set_xyoffset(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.XYoffset)
}

// uint32 X = 5;
inline void HWCGfx::clear_x() {
  x_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::_internal_x() const {
  return x_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::x() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.X)
  return _internal_x();
}
inline void HWCGfx::_internal_set_x(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  x_ = value;
}
inline void HWCGfx::set_x(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.X)
}

// uint32 Y = 6;
inline void HWCGfx::clear_y() {
  y_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::_internal_y() const {
  return y_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCGfx::y() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.Y)
  return _internal_y();
}
inline void HWCGfx::_internal_set_y(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  y_ = value;
}
inline void HWCGfx::set_y(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.Y)
}

// bytes ImageData = 16;
inline void HWCGfx::clear_imagedata() {
  imagedata_.ClearToEmpty();
}
inline const std::string& HWCGfx::imagedata() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCGfx.ImageData)
  return _internal_imagedata();
}
inline void HWCGfx::set_imagedata(const std::string& value) {
  _internal_set_imagedata(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCGfx.ImageData)
}
inline std::string* HWCGfx::mutable_imagedata() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCGfx.ImageData)
  return _internal_mutable_imagedata();
}
inline const std::string& HWCGfx::_internal_imagedata() const {
  return imagedata_.Get();
}
inline void HWCGfx::_internal_set_imagedata(const std::string& value) {
  
  imagedata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void HWCGfx::set_imagedata(std::string&& value) {
  
  imagedata_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.HWCGfx.ImageData)
}
inline void HWCGfx::set_imagedata(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  imagedata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.HWCGfx.ImageData)
}
inline void HWCGfx::set_imagedata(const void* value,
    size_t size) {
  
  imagedata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.HWCGfx.ImageData)
}
inline std::string* HWCGfx::_internal_mutable_imagedata() {
  
  return imagedata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* HWCGfx::release_imagedata() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCGfx.ImageData)
  return imagedata_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void HWCGfx::set_allocated_imagedata(std::string* imagedata) {
  if (imagedata != nullptr) {
    
  } else {
    
  }
  imagedata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), imagedata,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCGfx.ImageData)
}

// -------------------------------------------------------------------

// ImgConvert

// .ibeam_rawpanel.ImgConvert.FileTypeE FileType = 1;
inline void ImgConvert::clear_filetype() {
  filetype_ = 0;
}
inline ::ibeam_rawpanel::ImgConvert_FileTypeE ImgConvert::_internal_filetype() const {
  return static_cast< ::ibeam_rawpanel::ImgConvert_FileTypeE >(filetype_);
}
inline ::ibeam_rawpanel::ImgConvert_FileTypeE ImgConvert::filetype() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ImgConvert.FileType)
  return _internal_filetype();
}
inline void ImgConvert::_internal_set_filetype(::ibeam_rawpanel::ImgConvert_FileTypeE value) {
  
  filetype_ = value;
}
inline void ImgConvert::set_filetype(::ibeam_rawpanel::ImgConvert_FileTypeE value) {
  _internal_set_filetype(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ImgConvert.FileType)
}

// .ibeam_rawpanel.ImgConvert.ScalingE Scaling = 2;
inline void ImgConvert::clear_scaling() {
  scaling_ = 0;
}
inline ::ibeam_rawpanel::ImgConvert_ScalingE ImgConvert::_internal_scaling() const {
  return static_cast< ::ibeam_rawpanel::ImgConvert_ScalingE >(scaling_);
}
inline ::ibeam_rawpanel::ImgConvert_ScalingE ImgConvert::scaling() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ImgConvert.Scaling)
  return _internal_scaling();
}
inline void ImgConvert::_internal_set_scaling(::ibeam_rawpanel::ImgConvert_ScalingE value) {
  
  scaling_ = value;
}
inline void ImgConvert::set_scaling(::ibeam_rawpanel::ImgConvert_ScalingE value) {
  _internal_set_scaling(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ImgConvert.Scaling)
}

// bool Grayscale = 3;
inline void ImgConvert::clear_grayscale() {
  grayscale_ = false;
}
inline bool ImgConvert::_internal_grayscale() const {
  return grayscale_;
}
inline bool ImgConvert::grayscale() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.ImgConvert.Grayscale)
  return _internal_grayscale();
}
inline void ImgConvert::_internal_set_grayscale(bool value) {
  
  grayscale_ = value;
}
inline void ImgConvert::set_grayscale(bool value) {
  _internal_set_grayscale(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.ImgConvert.Grayscale)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// OutboundMessage

// .ibeam_rawpanel.OutboundMessage.FlowMsg FlowMessage = 1;
inline void OutboundMessage::clear_flowmessage() {
  flowmessage_ = 0;
}
inline ::ibeam_rawpanel::OutboundMessage_FlowMsg OutboundMessage::_internal_flowmessage() const {
  return static_cast< ::ibeam_rawpanel::OutboundMessage_FlowMsg >(flowmessage_);
}
inline ::ibeam_rawpanel::OutboundMessage_FlowMsg OutboundMessage::flowmessage() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.FlowMessage)
  return _internal_flowmessage();
}
inline void OutboundMessage::_internal_set_flowmessage(::ibeam_rawpanel::OutboundMessage_FlowMsg value) {
  
  flowmessage_ = value;
}
inline void OutboundMessage::set_flowmessage(::ibeam_rawpanel::OutboundMessage_FlowMsg value) {
  _internal_set_flowmessage(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.OutboundMessage.FlowMessage)
}

// map<uint32, uint32> HWCavailability = 2;
inline int OutboundMessage::_internal_hwcavailability_size() const {
  return hwcavailability_.size();
}
inline int OutboundMessage::hwcavailability_size() const {
  return _internal_hwcavailability_size();
}
inline void OutboundMessage::clear_hwcavailability() {
  hwcavailability_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::uint32 >&
OutboundMessage::_internal_hwcavailability() const {
  return hwcavailability_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::uint32 >&
OutboundMessage::hwcavailability() const {
  // @@protoc_insertion_point(field_map:ibeam_rawpanel.OutboundMessage.HWCavailability)
  return _internal_hwcavailability();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::uint32 >*
OutboundMessage::_internal_mutable_hwcavailability() {
  return hwcavailability_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::uint32 >*
OutboundMessage::mutable_hwcavailability() {
  // @@protoc_insertion_point(field_mutable_map:ibeam_rawpanel.OutboundMessage.HWCavailability)
  return _internal_mutable_hwcavailability();
}

// .ibeam_rawpanel.PanelInfo PanelInfo = 4;
inline bool OutboundMessage::_internal_has_panelinfo() const {
  return this != internal_default_instance() && panelinfo_ != nullptr;
}
inline bool OutboundMessage::has_panelinfo() const {
  return _internal_has_panelinfo();
}
inline void OutboundMessage::clear_panelinfo() {
  if (GetArena() == nullptr && panelinfo_ != nullptr) {
    delete panelinfo_;
  }
  panelinfo_ = nullptr;
}
inline const ::ibeam_rawpanel::PanelInfo& OutboundMessage::_internal_panelinfo() const {
  const ::ibeam_rawpanel::PanelInfo* p = panelinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::PanelInfo&>(
      ::ibeam_rawpanel::_PanelInfo_default_instance_);
}
inline const ::ibeam_rawpanel::PanelInfo& OutboundMessage::panelinfo() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.PanelInfo)
  return _internal_panelinfo();
}
inline void OutboundMessage::unsafe_arena_set_allocated_panelinfo(
    ::ibeam_rawpanel::PanelInfo* panelinfo) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(panelinfo_);
  }
  panelinfo_ = panelinfo;
  if (panelinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.OutboundMessage.PanelInfo)
}
inline ::ibeam_rawpanel::PanelInfo* OutboundMessage::release_panelinfo() {
  
  ::ibeam_rawpanel::PanelInfo* temp = panelinfo_;
  panelinfo_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::PanelInfo* OutboundMessage::unsafe_arena_release_panelinfo() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.OutboundMessage.PanelInfo)
  
  ::ibeam_rawpanel::PanelInfo* temp = panelinfo_;
  panelinfo_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::PanelInfo* OutboundMessage::_internal_mutable_panelinfo() {
  
  if (panelinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::PanelInfo>(GetArena());
    panelinfo_ = p;
  }
  return panelinfo_;
}
inline ::ibeam_rawpanel::PanelInfo* OutboundMessage::mutable_panelinfo() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.OutboundMessage.PanelInfo)
  return _internal_mutable_panelinfo();
}
inline void OutboundMessage::set_allocated_panelinfo(::ibeam_rawpanel::PanelInfo* panelinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete panelinfo_;
  }
  if (panelinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(panelinfo);
    if (message_arena != submessage_arena) {
      panelinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, panelinfo, submessage_arena);
    }
    
  } else {
    
  }
  panelinfo_ = panelinfo;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.OutboundMessage.PanelInfo)
}

// .ibeam_rawpanel.PanelTopology PanelTopology = 5;
inline bool OutboundMessage::_internal_has_paneltopology() const {
  return this != internal_default_instance() && paneltopology_ != nullptr;
}
inline bool OutboundMessage::has_paneltopology() const {
  return _internal_has_paneltopology();
}
inline void OutboundMessage::clear_paneltopology() {
  if (GetArena() == nullptr && paneltopology_ != nullptr) {
    delete paneltopology_;
  }
  paneltopology_ = nullptr;
}
inline const ::ibeam_rawpanel::PanelTopology& OutboundMessage::_internal_paneltopology() const {
  const ::ibeam_rawpanel::PanelTopology* p = paneltopology_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::PanelTopology&>(
      ::ibeam_rawpanel::_PanelTopology_default_instance_);
}
inline const ::ibeam_rawpanel::PanelTopology& OutboundMessage::paneltopology() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.PanelTopology)
  return _internal_paneltopology();
}
inline void OutboundMessage::unsafe_arena_set_allocated_paneltopology(
    ::ibeam_rawpanel::PanelTopology* paneltopology) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(paneltopology_);
  }
  paneltopology_ = paneltopology;
  if (paneltopology) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.OutboundMessage.PanelTopology)
}
inline ::ibeam_rawpanel::PanelTopology* OutboundMessage::release_paneltopology() {
  
  ::ibeam_rawpanel::PanelTopology* temp = paneltopology_;
  paneltopology_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::PanelTopology* OutboundMessage::unsafe_arena_release_paneltopology() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.OutboundMessage.PanelTopology)
  
  ::ibeam_rawpanel::PanelTopology* temp = paneltopology_;
  paneltopology_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::PanelTopology* OutboundMessage::_internal_mutable_paneltopology() {
  
  if (paneltopology_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::PanelTopology>(GetArena());
    paneltopology_ = p;
  }
  return paneltopology_;
}
inline ::ibeam_rawpanel::PanelTopology* OutboundMessage::mutable_paneltopology() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.OutboundMessage.PanelTopology)
  return _internal_mutable_paneltopology();
}
inline void OutboundMessage::set_allocated_paneltopology(::ibeam_rawpanel::PanelTopology* paneltopology) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete paneltopology_;
  }
  if (paneltopology) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(paneltopology);
    if (message_arena != submessage_arena) {
      paneltopology = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, paneltopology, submessage_arena);
    }
    
  } else {
    
  }
  paneltopology_ = paneltopology;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.OutboundMessage.PanelTopology)
}

// .ibeam_rawpanel.BurninProfile BurninProfile = 9;
inline bool OutboundMessage::_internal_has_burninprofile() const {
  return this != internal_default_instance() && burninprofile_ != nullptr;
}
inline bool OutboundMessage::has_burninprofile() const {
  return _internal_has_burninprofile();
}
inline void OutboundMessage::clear_burninprofile() {
  if (GetArena() == nullptr && burninprofile_ != nullptr) {
    delete burninprofile_;
  }
  burninprofile_ = nullptr;
}
inline const ::ibeam_rawpanel::BurninProfile& OutboundMessage::_internal_burninprofile() const {
  const ::ibeam_rawpanel::BurninProfile* p = burninprofile_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::BurninProfile&>(
      ::ibeam_rawpanel::_BurninProfile_default_instance_);
}
inline const ::ibeam_rawpanel::BurninProfile& OutboundMessage::burninprofile() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.BurninProfile)
  return _internal_burninprofile();
}
inline void OutboundMessage::unsafe_arena_set_allocated_burninprofile(
    ::ibeam_rawpanel::BurninProfile* burninprofile) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(burninprofile_);
  }
  burninprofile_ = burninprofile;
  if (burninprofile) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.OutboundMessage.BurninProfile)
}
inline ::ibeam_rawpanel::BurninProfile* OutboundMessage::release_burninprofile() {
  
  ::ibeam_rawpanel::BurninProfile* temp = burninprofile_;
  burninprofile_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::BurninProfile* OutboundMessage::unsafe_arena_release_burninprofile() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.OutboundMessage.BurninProfile)
  
  ::ibeam_rawpanel::BurninProfile* temp = burninprofile_;
  burninprofile_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::BurninProfile* OutboundMessage::_internal_mutable_burninprofile() {
  
  if (burninprofile_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::BurninProfile>(GetArena());
    burninprofile_ = p;
  }
  return burninprofile_;
}
inline ::ibeam_rawpanel::BurninProfile* OutboundMessage::mutable_burninprofile() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.OutboundMessage.BurninProfile)
  return _internal_mutable_burninprofile();
}
inline void OutboundMessage::set_allocated_burninprofile(::ibeam_rawpanel::BurninProfile* burninprofile) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete burninprofile_;
  }
  if (burninprofile) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(burninprofile);
    if (message_arena != submessage_arena) {
      burninprofile = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, burninprofile, submessage_arena);
    }
    
  } else {
    
  }
  burninprofile_ = burninprofile;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.OutboundMessage.BurninProfile)
}

// .ibeam_rawpanel.SleepTimeout SleepTimeout = 6;
inline bool OutboundMessage::_internal_has_sleeptimeout() const {
  return this != internal_default_instance() && sleeptimeout_ != nullptr;
}
inline bool OutboundMessage::has_sleeptimeout() const {
  return _internal_has_sleeptimeout();
}
inline void OutboundMessage::clear_sleeptimeout() {
  if (GetArena() == nullptr && sleeptimeout_ != nullptr) {
    delete sleeptimeout_;
  }
  sleeptimeout_ = nullptr;
}
inline const ::ibeam_rawpanel::SleepTimeout& OutboundMessage::_internal_sleeptimeout() const {
  const ::ibeam_rawpanel::SleepTimeout* p = sleeptimeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::SleepTimeout&>(
      ::ibeam_rawpanel::_SleepTimeout_default_instance_);
}
inline const ::ibeam_rawpanel::SleepTimeout& OutboundMessage::sleeptimeout() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.SleepTimeout)
  return _internal_sleeptimeout();
}
inline void OutboundMessage::unsafe_arena_set_allocated_sleeptimeout(
    ::ibeam_rawpanel::SleepTimeout* sleeptimeout) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sleeptimeout_);
  }
  sleeptimeout_ = sleeptimeout;
  if (sleeptimeout) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.OutboundMessage.SleepTimeout)
}
inline ::ibeam_rawpanel::SleepTimeout* OutboundMessage::release_sleeptimeout() {
  
  ::ibeam_rawpanel::SleepTimeout* temp = sleeptimeout_;
  sleeptimeout_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::SleepTimeout* OutboundMessage::unsafe_arena_release_sleeptimeout() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.OutboundMessage.SleepTimeout)
  
  ::ibeam_rawpanel::SleepTimeout* temp = sleeptimeout_;
  sleeptimeout_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::SleepTimeout* OutboundMessage::_internal_mutable_sleeptimeout() {
  
  if (sleeptimeout_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::SleepTimeout>(GetArena());
    sleeptimeout_ = p;
  }
  return sleeptimeout_;
}
inline ::ibeam_rawpanel::SleepTimeout* OutboundMessage::mutable_sleeptimeout() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.OutboundMessage.SleepTimeout)
  return _internal_mutable_sleeptimeout();
}
inline void OutboundMessage::set_allocated_sleeptimeout(::ibeam_rawpanel::SleepTimeout* sleeptimeout) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sleeptimeout_;
  }
  if (sleeptimeout) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sleeptimeout);
    if (message_arena != submessage_arena) {
      sleeptimeout = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sleeptimeout, submessage_arena);
    }
    
  } else {
    
  }
  sleeptimeout_ = sleeptimeout;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.OutboundMessage.SleepTimeout)
}

// .ibeam_rawpanel.SleepState SleepState = 7;
inline bool OutboundMessage::_internal_has_sleepstate() const {
  return this != internal_default_instance() && sleepstate_ != nullptr;
}
inline bool OutboundMessage::has_sleepstate() const {
  return _internal_has_sleepstate();
}
inline void OutboundMessage::clear_sleepstate() {
  if (GetArena() == nullptr && sleepstate_ != nullptr) {
    delete sleepstate_;
  }
  sleepstate_ = nullptr;
}
inline const ::ibeam_rawpanel::SleepState& OutboundMessage::_internal_sleepstate() const {
  const ::ibeam_rawpanel::SleepState* p = sleepstate_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::SleepState&>(
      ::ibeam_rawpanel::_SleepState_default_instance_);
}
inline const ::ibeam_rawpanel::SleepState& OutboundMessage::sleepstate() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.SleepState)
  return _internal_sleepstate();
}
inline void OutboundMessage::unsafe_arena_set_allocated_sleepstate(
    ::ibeam_rawpanel::SleepState* sleepstate) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sleepstate_);
  }
  sleepstate_ = sleepstate;
  if (sleepstate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.OutboundMessage.SleepState)
}
inline ::ibeam_rawpanel::SleepState* OutboundMessage::release_sleepstate() {
  
  ::ibeam_rawpanel::SleepState* temp = sleepstate_;
  sleepstate_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::SleepState* OutboundMessage::unsafe_arena_release_sleepstate() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.OutboundMessage.SleepState)
  
  ::ibeam_rawpanel::SleepState* temp = sleepstate_;
  sleepstate_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::SleepState* OutboundMessage::_internal_mutable_sleepstate() {
  
  if (sleepstate_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::SleepState>(GetArena());
    sleepstate_ = p;
  }
  return sleepstate_;
}
inline ::ibeam_rawpanel::SleepState* OutboundMessage::mutable_sleepstate() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.OutboundMessage.SleepState)
  return _internal_mutable_sleepstate();
}
inline void OutboundMessage::set_allocated_sleepstate(::ibeam_rawpanel::SleepState* sleepstate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete sleepstate_;
  }
  if (sleepstate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(sleepstate);
    if (message_arena != submessage_arena) {
      sleepstate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sleepstate, submessage_arena);
    }
    
  } else {
    
  }
  sleepstate_ = sleepstate;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.OutboundMessage.SleepState)
}

// repeated .ibeam_rawpanel.HWCEvent Events = 8;
inline int OutboundMessage::_internal_events_size() const {
  return events_.size();
}
inline int OutboundMessage::events_size() const {
  return _internal_events_size();
}
inline void OutboundMessage::clear_events() {
  events_.Clear();
}
inline ::ibeam_rawpanel::HWCEvent* OutboundMessage::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.OutboundMessage.Events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCEvent >*
OutboundMessage::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:ibeam_rawpanel.OutboundMessage.Events)
  return &events_;
}
inline const ::ibeam_rawpanel::HWCEvent& OutboundMessage::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::ibeam_rawpanel::HWCEvent& OutboundMessage::events(int index) const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.OutboundMessage.Events)
  return _internal_events(index);
}
inline ::ibeam_rawpanel::HWCEvent* OutboundMessage::_internal_add_events() {
  return events_.Add();
}
inline ::ibeam_rawpanel::HWCEvent* OutboundMessage::add_events() {
  // @@protoc_insertion_point(field_add:ibeam_rawpanel.OutboundMessage.Events)
  return _internal_add_events();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ibeam_rawpanel::HWCEvent >&
OutboundMessage::events() const {
  // @@protoc_insertion_point(field_list:ibeam_rawpanel.OutboundMessage.Events)
  return events_;
}

// -------------------------------------------------------------------

// SleepState

// bool IsSleeping = 1;
inline void SleepState::clear_issleeping() {
  issleeping_ = false;
}
inline bool SleepState::_internal_issleeping() const {
  return issleeping_;
}
inline bool SleepState::issleeping() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.SleepState.IsSleeping)
  return _internal_issleeping();
}
inline void SleepState::_internal_set_issleeping(bool value) {
  
  issleeping_ = value;
}
inline void SleepState::set_issleeping(bool value) {
  _internal_set_issleeping(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.SleepState.IsSleeping)
}

// -------------------------------------------------------------------

// HWCEvent

// uint32 HWCID = 1;
inline void HWCEvent::clear_hwcid() {
  hwcid_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCEvent::_internal_hwcid() const {
  return hwcid_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCEvent::hwcid() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.HWCID)
  return _internal_hwcid();
}
inline void HWCEvent::_internal_set_hwcid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  hwcid_ = value;
}
inline void HWCEvent::set_hwcid(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hwcid(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCEvent.HWCID)
}

// uint32 Timestamp = 6;
inline void HWCEvent::clear_timestamp() {
  timestamp_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCEvent::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 HWCEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.Timestamp)
  return _internal_timestamp();
}
inline void HWCEvent::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  timestamp_ = value;
}
inline void HWCEvent::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.HWCEvent.Timestamp)
}

// .ibeam_rawpanel.BinaryEvent Binary = 2;
inline bool HWCEvent::_internal_has_binary() const {
  return this != internal_default_instance() && binary_ != nullptr;
}
inline bool HWCEvent::has_binary() const {
  return _internal_has_binary();
}
inline void HWCEvent::clear_binary() {
  if (GetArena() == nullptr && binary_ != nullptr) {
    delete binary_;
  }
  binary_ = nullptr;
}
inline const ::ibeam_rawpanel::BinaryEvent& HWCEvent::_internal_binary() const {
  const ::ibeam_rawpanel::BinaryEvent* p = binary_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::BinaryEvent&>(
      ::ibeam_rawpanel::_BinaryEvent_default_instance_);
}
inline const ::ibeam_rawpanel::BinaryEvent& HWCEvent::binary() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.Binary)
  return _internal_binary();
}
inline void HWCEvent::unsafe_arena_set_allocated_binary(
    ::ibeam_rawpanel::BinaryEvent* binary) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(binary_);
  }
  binary_ = binary;
  if (binary) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCEvent.Binary)
}
inline ::ibeam_rawpanel::BinaryEvent* HWCEvent::release_binary() {
  
  ::ibeam_rawpanel::BinaryEvent* temp = binary_;
  binary_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::BinaryEvent* HWCEvent::unsafe_arena_release_binary() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCEvent.Binary)
  
  ::ibeam_rawpanel::BinaryEvent* temp = binary_;
  binary_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::BinaryEvent* HWCEvent::_internal_mutable_binary() {
  
  if (binary_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::BinaryEvent>(GetArena());
    binary_ = p;
  }
  return binary_;
}
inline ::ibeam_rawpanel::BinaryEvent* HWCEvent::mutable_binary() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCEvent.Binary)
  return _internal_mutable_binary();
}
inline void HWCEvent::set_allocated_binary(::ibeam_rawpanel::BinaryEvent* binary) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete binary_;
  }
  if (binary) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(binary);
    if (message_arena != submessage_arena) {
      binary = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, binary, submessage_arena);
    }
    
  } else {
    
  }
  binary_ = binary;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCEvent.Binary)
}

// .ibeam_rawpanel.PulsedEvent Pulsed = 3;
inline bool HWCEvent::_internal_has_pulsed() const {
  return this != internal_default_instance() && pulsed_ != nullptr;
}
inline bool HWCEvent::has_pulsed() const {
  return _internal_has_pulsed();
}
inline void HWCEvent::clear_pulsed() {
  if (GetArena() == nullptr && pulsed_ != nullptr) {
    delete pulsed_;
  }
  pulsed_ = nullptr;
}
inline const ::ibeam_rawpanel::PulsedEvent& HWCEvent::_internal_pulsed() const {
  const ::ibeam_rawpanel::PulsedEvent* p = pulsed_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::PulsedEvent&>(
      ::ibeam_rawpanel::_PulsedEvent_default_instance_);
}
inline const ::ibeam_rawpanel::PulsedEvent& HWCEvent::pulsed() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.Pulsed)
  return _internal_pulsed();
}
inline void HWCEvent::unsafe_arena_set_allocated_pulsed(
    ::ibeam_rawpanel::PulsedEvent* pulsed) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pulsed_);
  }
  pulsed_ = pulsed;
  if (pulsed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCEvent.Pulsed)
}
inline ::ibeam_rawpanel::PulsedEvent* HWCEvent::release_pulsed() {
  
  ::ibeam_rawpanel::PulsedEvent* temp = pulsed_;
  pulsed_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::PulsedEvent* HWCEvent::unsafe_arena_release_pulsed() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCEvent.Pulsed)
  
  ::ibeam_rawpanel::PulsedEvent* temp = pulsed_;
  pulsed_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::PulsedEvent* HWCEvent::_internal_mutable_pulsed() {
  
  if (pulsed_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::PulsedEvent>(GetArena());
    pulsed_ = p;
  }
  return pulsed_;
}
inline ::ibeam_rawpanel::PulsedEvent* HWCEvent::mutable_pulsed() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCEvent.Pulsed)
  return _internal_mutable_pulsed();
}
inline void HWCEvent::set_allocated_pulsed(::ibeam_rawpanel::PulsedEvent* pulsed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete pulsed_;
  }
  if (pulsed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(pulsed);
    if (message_arena != submessage_arena) {
      pulsed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pulsed, submessage_arena);
    }
    
  } else {
    
  }
  pulsed_ = pulsed;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCEvent.Pulsed)
}

// .ibeam_rawpanel.AbsoluteEvent Absolute = 4;
inline bool HWCEvent::_internal_has_absolute() const {
  return this != internal_default_instance() && absolute_ != nullptr;
}
inline bool HWCEvent::has_absolute() const {
  return _internal_has_absolute();
}
inline void HWCEvent::clear_absolute() {
  if (GetArena() == nullptr && absolute_ != nullptr) {
    delete absolute_;
  }
  absolute_ = nullptr;
}
inline const ::ibeam_rawpanel::AbsoluteEvent& HWCEvent::_internal_absolute() const {
  const ::ibeam_rawpanel::AbsoluteEvent* p = absolute_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::AbsoluteEvent&>(
      ::ibeam_rawpanel::_AbsoluteEvent_default_instance_);
}
inline const ::ibeam_rawpanel::AbsoluteEvent& HWCEvent::absolute() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.Absolute)
  return _internal_absolute();
}
inline void HWCEvent::unsafe_arena_set_allocated_absolute(
    ::ibeam_rawpanel::AbsoluteEvent* absolute) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(absolute_);
  }
  absolute_ = absolute;
  if (absolute) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCEvent.Absolute)
}
inline ::ibeam_rawpanel::AbsoluteEvent* HWCEvent::release_absolute() {
  
  ::ibeam_rawpanel::AbsoluteEvent* temp = absolute_;
  absolute_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::AbsoluteEvent* HWCEvent::unsafe_arena_release_absolute() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCEvent.Absolute)
  
  ::ibeam_rawpanel::AbsoluteEvent* temp = absolute_;
  absolute_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::AbsoluteEvent* HWCEvent::_internal_mutable_absolute() {
  
  if (absolute_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::AbsoluteEvent>(GetArena());
    absolute_ = p;
  }
  return absolute_;
}
inline ::ibeam_rawpanel::AbsoluteEvent* HWCEvent::mutable_absolute() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCEvent.Absolute)
  return _internal_mutable_absolute();
}
inline void HWCEvent::set_allocated_absolute(::ibeam_rawpanel::AbsoluteEvent* absolute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete absolute_;
  }
  if (absolute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(absolute);
    if (message_arena != submessage_arena) {
      absolute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, absolute, submessage_arena);
    }
    
  } else {
    
  }
  absolute_ = absolute;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCEvent.Absolute)
}

// .ibeam_rawpanel.SpeedEvent Speed = 5;
inline bool HWCEvent::_internal_has_speed() const {
  return this != internal_default_instance() && speed_ != nullptr;
}
inline bool HWCEvent::has_speed() const {
  return _internal_has_speed();
}
inline void HWCEvent::clear_speed() {
  if (GetArena() == nullptr && speed_ != nullptr) {
    delete speed_;
  }
  speed_ = nullptr;
}
inline const ::ibeam_rawpanel::SpeedEvent& HWCEvent::_internal_speed() const {
  const ::ibeam_rawpanel::SpeedEvent* p = speed_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::SpeedEvent&>(
      ::ibeam_rawpanel::_SpeedEvent_default_instance_);
}
inline const ::ibeam_rawpanel::SpeedEvent& HWCEvent::speed() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.Speed)
  return _internal_speed();
}
inline void HWCEvent::unsafe_arena_set_allocated_speed(
    ::ibeam_rawpanel::SpeedEvent* speed) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(speed_);
  }
  speed_ = speed;
  if (speed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCEvent.Speed)
}
inline ::ibeam_rawpanel::SpeedEvent* HWCEvent::release_speed() {
  
  ::ibeam_rawpanel::SpeedEvent* temp = speed_;
  speed_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::SpeedEvent* HWCEvent::unsafe_arena_release_speed() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCEvent.Speed)
  
  ::ibeam_rawpanel::SpeedEvent* temp = speed_;
  speed_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::SpeedEvent* HWCEvent::_internal_mutable_speed() {
  
  if (speed_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::SpeedEvent>(GetArena());
    speed_ = p;
  }
  return speed_;
}
inline ::ibeam_rawpanel::SpeedEvent* HWCEvent::mutable_speed() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCEvent.Speed)
  return _internal_mutable_speed();
}
inline void HWCEvent::set_allocated_speed(::ibeam_rawpanel::SpeedEvent* speed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete speed_;
  }
  if (speed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(speed);
    if (message_arena != submessage_arena) {
      speed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, speed, submessage_arena);
    }
    
  } else {
    
  }
  speed_ = speed;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCEvent.Speed)
}

// .ibeam_rawpanel.RawAnalogEvent RawAnalog = 7;
inline bool HWCEvent::_internal_has_rawanalog() const {
  return this != internal_default_instance() && rawanalog_ != nullptr;
}
inline bool HWCEvent::has_rawanalog() const {
  return _internal_has_rawanalog();
}
inline void HWCEvent::clear_rawanalog() {
  if (GetArena() == nullptr && rawanalog_ != nullptr) {
    delete rawanalog_;
  }
  rawanalog_ = nullptr;
}
inline const ::ibeam_rawpanel::RawAnalogEvent& HWCEvent::_internal_rawanalog() const {
  const ::ibeam_rawpanel::RawAnalogEvent* p = rawanalog_;
  return p != nullptr ? *p : reinterpret_cast<const ::ibeam_rawpanel::RawAnalogEvent&>(
      ::ibeam_rawpanel::_RawAnalogEvent_default_instance_);
}
inline const ::ibeam_rawpanel::RawAnalogEvent& HWCEvent::rawanalog() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.HWCEvent.RawAnalog)
  return _internal_rawanalog();
}
inline void HWCEvent::unsafe_arena_set_allocated_rawanalog(
    ::ibeam_rawpanel::RawAnalogEvent* rawanalog) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(rawanalog_);
  }
  rawanalog_ = rawanalog;
  if (rawanalog) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ibeam_rawpanel.HWCEvent.RawAnalog)
}
inline ::ibeam_rawpanel::RawAnalogEvent* HWCEvent::release_rawanalog() {
  
  ::ibeam_rawpanel::RawAnalogEvent* temp = rawanalog_;
  rawanalog_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::ibeam_rawpanel::RawAnalogEvent* HWCEvent::unsafe_arena_release_rawanalog() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.HWCEvent.RawAnalog)
  
  ::ibeam_rawpanel::RawAnalogEvent* temp = rawanalog_;
  rawanalog_ = nullptr;
  return temp;
}
inline ::ibeam_rawpanel::RawAnalogEvent* HWCEvent::_internal_mutable_rawanalog() {
  
  if (rawanalog_ == nullptr) {
    auto* p = CreateMaybeMessage<::ibeam_rawpanel::RawAnalogEvent>(GetArena());
    rawanalog_ = p;
  }
  return rawanalog_;
}
inline ::ibeam_rawpanel::RawAnalogEvent* HWCEvent::mutable_rawanalog() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.HWCEvent.RawAnalog)
  return _internal_mutable_rawanalog();
}
inline void HWCEvent::set_allocated_rawanalog(::ibeam_rawpanel::RawAnalogEvent* rawanalog) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete rawanalog_;
  }
  if (rawanalog) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(rawanalog);
    if (message_arena != submessage_arena) {
      rawanalog = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rawanalog, submessage_arena);
    }
    
  } else {
    
  }
  rawanalog_ = rawanalog;
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.HWCEvent.RawAnalog)
}

// -------------------------------------------------------------------

// BinaryEvent

// bool Pressed = 1;
inline void BinaryEvent::clear_pressed() {
  pressed_ = false;
}
inline bool BinaryEvent::_internal_pressed() const {
  return pressed_;
}
inline bool BinaryEvent::pressed() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.BinaryEvent.Pressed)
  return _internal_pressed();
}
inline void BinaryEvent::_internal_set_pressed(bool value) {
  
  pressed_ = value;
}
inline void BinaryEvent::set_pressed(bool value) {
  _internal_set_pressed(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.BinaryEvent.Pressed)
}

// .ibeam_rawpanel.BinaryEvent.EdgeID Edge = 2;
inline void BinaryEvent::clear_edge() {
  edge_ = 0;
}
inline ::ibeam_rawpanel::BinaryEvent_EdgeID BinaryEvent::_internal_edge() const {
  return static_cast< ::ibeam_rawpanel::BinaryEvent_EdgeID >(edge_);
}
inline ::ibeam_rawpanel::BinaryEvent_EdgeID BinaryEvent::edge() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.BinaryEvent.Edge)
  return _internal_edge();
}
inline void BinaryEvent::_internal_set_edge(::ibeam_rawpanel::BinaryEvent_EdgeID value) {
  
  edge_ = value;
}
inline void BinaryEvent::set_edge(::ibeam_rawpanel::BinaryEvent_EdgeID value) {
  _internal_set_edge(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.BinaryEvent.Edge)
}

// -------------------------------------------------------------------

// PulsedEvent

// sint32 Value = 1;
inline void PulsedEvent::clear_value() {
  value_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PulsedEvent::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 PulsedEvent::value() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PulsedEvent.Value)
  return _internal_value();
}
inline void PulsedEvent::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  value_ = value;
}
inline void PulsedEvent::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PulsedEvent.Value)
}

// -------------------------------------------------------------------

// AbsoluteEvent

// uint32 Value = 1;
inline void AbsoluteEvent::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AbsoluteEvent::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AbsoluteEvent::value() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.AbsoluteEvent.Value)
  return _internal_value();
}
inline void AbsoluteEvent::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void AbsoluteEvent::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.AbsoluteEvent.Value)
}

// -------------------------------------------------------------------

// SpeedEvent

// sint32 Value = 1;
inline void SpeedEvent::clear_value() {
  value_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpeedEvent::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SpeedEvent::value() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.SpeedEvent.Value)
  return _internal_value();
}
inline void SpeedEvent::_internal_set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  value_ = value;
}
inline void SpeedEvent::set_value(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.SpeedEvent.Value)
}

// -------------------------------------------------------------------

// RawAnalogEvent

// uint32 Value = 1;
inline void RawAnalogEvent::clear_value() {
  value_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RawAnalogEvent::_internal_value() const {
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RawAnalogEvent::value() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.RawAnalogEvent.Value)
  return _internal_value();
}
inline void RawAnalogEvent::_internal_set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  value_ = value;
}
inline void RawAnalogEvent::set_value(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.RawAnalogEvent.Value)
}

// -------------------------------------------------------------------

// PanelInfo

// string Model = 1;
inline void PanelInfo::clear_model() {
  model_.ClearToEmpty();
}
inline const std::string& PanelInfo::model() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PanelInfo.Model)
  return _internal_model();
}
inline void PanelInfo::set_model(const std::string& value) {
  _internal_set_model(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PanelInfo.Model)
}
inline std::string* PanelInfo::mutable_model() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.PanelInfo.Model)
  return _internal_mutable_model();
}
inline const std::string& PanelInfo::_internal_model() const {
  return model_.Get();
}
inline void PanelInfo::_internal_set_model(const std::string& value) {
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PanelInfo::set_model(std::string&& value) {
  
  model_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.PanelInfo.Model)
}
inline void PanelInfo::set_model(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.PanelInfo.Model)
}
inline void PanelInfo::set_model(const char* value,
    size_t size) {
  
  model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.PanelInfo.Model)
}
inline std::string* PanelInfo::_internal_mutable_model() {
  
  return model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PanelInfo::release_model() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.PanelInfo.Model)
  return model_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PanelInfo::set_allocated_model(std::string* model) {
  if (model != nullptr) {
    
  } else {
    
  }
  model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), model,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.PanelInfo.Model)
}

// string Serial = 2;
inline void PanelInfo::clear_serial() {
  serial_.ClearToEmpty();
}
inline const std::string& PanelInfo::serial() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PanelInfo.Serial)
  return _internal_serial();
}
inline void PanelInfo::set_serial(const std::string& value) {
  _internal_set_serial(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PanelInfo.Serial)
}
inline std::string* PanelInfo::mutable_serial() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.PanelInfo.Serial)
  return _internal_mutable_serial();
}
inline const std::string& PanelInfo::_internal_serial() const {
  return serial_.Get();
}
inline void PanelInfo::_internal_set_serial(const std::string& value) {
  
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PanelInfo::set_serial(std::string&& value) {
  
  serial_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.PanelInfo.Serial)
}
inline void PanelInfo::set_serial(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.PanelInfo.Serial)
}
inline void PanelInfo::set_serial(const char* value,
    size_t size) {
  
  serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.PanelInfo.Serial)
}
inline std::string* PanelInfo::_internal_mutable_serial() {
  
  return serial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PanelInfo::release_serial() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.PanelInfo.Serial)
  return serial_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PanelInfo::set_allocated_serial(std::string* serial) {
  if (serial != nullptr) {
    
  } else {
    
  }
  serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serial,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.PanelInfo.Serial)
}

// string Name = 3;
inline void PanelInfo::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PanelInfo::name() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PanelInfo.Name)
  return _internal_name();
}
inline void PanelInfo::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PanelInfo.Name)
}
inline std::string* PanelInfo::mutable_name() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.PanelInfo.Name)
  return _internal_mutable_name();
}
inline const std::string& PanelInfo::_internal_name() const {
  return name_.Get();
}
inline void PanelInfo::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PanelInfo::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.PanelInfo.Name)
}
inline void PanelInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.PanelInfo.Name)
}
inline void PanelInfo::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.PanelInfo.Name)
}
inline std::string* PanelInfo::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PanelInfo::release_name() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.PanelInfo.Name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PanelInfo::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.PanelInfo.Name)
}

// string SoftwareVersion = 4;
inline void PanelInfo::clear_softwareversion() {
  softwareversion_.ClearToEmpty();
}
inline const std::string& PanelInfo::softwareversion() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PanelInfo.SoftwareVersion)
  return _internal_softwareversion();
}
inline void PanelInfo::set_softwareversion(const std::string& value) {
  _internal_set_softwareversion(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PanelInfo.SoftwareVersion)
}
inline std::string* PanelInfo::mutable_softwareversion() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.PanelInfo.SoftwareVersion)
  return _internal_mutable_softwareversion();
}
inline const std::string& PanelInfo::_internal_softwareversion() const {
  return softwareversion_.Get();
}
inline void PanelInfo::_internal_set_softwareversion(const std::string& value) {
  
  softwareversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PanelInfo::set_softwareversion(std::string&& value) {
  
  softwareversion_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.PanelInfo.SoftwareVersion)
}
inline void PanelInfo::set_softwareversion(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  softwareversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.PanelInfo.SoftwareVersion)
}
inline void PanelInfo::set_softwareversion(const char* value,
    size_t size) {
  
  softwareversion_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.PanelInfo.SoftwareVersion)
}
inline std::string* PanelInfo::_internal_mutable_softwareversion() {
  
  return softwareversion_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PanelInfo::release_softwareversion() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.PanelInfo.SoftwareVersion)
  return softwareversion_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PanelInfo::set_allocated_softwareversion(std::string* softwareversion) {
  if (softwareversion != nullptr) {
    
  } else {
    
  }
  softwareversion_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), softwareversion,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.PanelInfo.SoftwareVersion)
}

// string Platform = 5;
inline void PanelInfo::clear_platform() {
  platform_.ClearToEmpty();
}
inline const std::string& PanelInfo::platform() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PanelInfo.Platform)
  return _internal_platform();
}
inline void PanelInfo::set_platform(const std::string& value) {
  _internal_set_platform(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PanelInfo.Platform)
}
inline std::string* PanelInfo::mutable_platform() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.PanelInfo.Platform)
  return _internal_mutable_platform();
}
inline const std::string& PanelInfo::_internal_platform() const {
  return platform_.Get();
}
inline void PanelInfo::_internal_set_platform(const std::string& value) {
  
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PanelInfo::set_platform(std::string&& value) {
  
  platform_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.PanelInfo.Platform)
}
inline void PanelInfo::set_platform(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.PanelInfo.Platform)
}
inline void PanelInfo::set_platform(const char* value,
    size_t size) {
  
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.PanelInfo.Platform)
}
inline std::string* PanelInfo::_internal_mutable_platform() {
  
  return platform_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PanelInfo::release_platform() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.PanelInfo.Platform)
  return platform_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PanelInfo::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    
  } else {
    
  }
  platform_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.PanelInfo.Platform)
}

// -------------------------------------------------------------------

// PanelTopology

// string Svgbase = 1;
inline void PanelTopology::clear_svgbase() {
  svgbase_.ClearToEmpty();
}
inline const std::string& PanelTopology::svgbase() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PanelTopology.Svgbase)
  return _internal_svgbase();
}
inline void PanelTopology::set_svgbase(const std::string& value) {
  _internal_set_svgbase(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PanelTopology.Svgbase)
}
inline std::string* PanelTopology::mutable_svgbase() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.PanelTopology.Svgbase)
  return _internal_mutable_svgbase();
}
inline const std::string& PanelTopology::_internal_svgbase() const {
  return svgbase_.Get();
}
inline void PanelTopology::_internal_set_svgbase(const std::string& value) {
  
  svgbase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PanelTopology::set_svgbase(std::string&& value) {
  
  svgbase_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.PanelTopology.Svgbase)
}
inline void PanelTopology::set_svgbase(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  svgbase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.PanelTopology.Svgbase)
}
inline void PanelTopology::set_svgbase(const char* value,
    size_t size) {
  
  svgbase_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.PanelTopology.Svgbase)
}
inline std::string* PanelTopology::_internal_mutable_svgbase() {
  
  return svgbase_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PanelTopology::release_svgbase() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.PanelTopology.Svgbase)
  return svgbase_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PanelTopology::set_allocated_svgbase(std::string* svgbase) {
  if (svgbase != nullptr) {
    
  } else {
    
  }
  svgbase_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), svgbase,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.PanelTopology.Svgbase)
}

// string Json = 2;
inline void PanelTopology::clear_json() {
  json_.ClearToEmpty();
}
inline const std::string& PanelTopology::json() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.PanelTopology.Json)
  return _internal_json();
}
inline void PanelTopology::set_json(const std::string& value) {
  _internal_set_json(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.PanelTopology.Json)
}
inline std::string* PanelTopology::mutable_json() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.PanelTopology.Json)
  return _internal_mutable_json();
}
inline const std::string& PanelTopology::_internal_json() const {
  return json_.Get();
}
inline void PanelTopology::_internal_set_json(const std::string& value) {
  
  json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void PanelTopology::set_json(std::string&& value) {
  
  json_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.PanelTopology.Json)
}
inline void PanelTopology::set_json(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.PanelTopology.Json)
}
inline void PanelTopology::set_json(const char* value,
    size_t size) {
  
  json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.PanelTopology.Json)
}
inline std::string* PanelTopology::_internal_mutable_json() {
  
  return json_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* PanelTopology::release_json() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.PanelTopology.Json)
  return json_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void PanelTopology::set_allocated_json(std::string* json) {
  if (json != nullptr) {
    
  } else {
    
  }
  json_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), json,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.PanelTopology.Json)
}

// -------------------------------------------------------------------

// BurninProfile

// string Json = 1;
inline void BurninProfile::clear_json() {
  json_.ClearToEmpty();
}
inline const std::string& BurninProfile::json() const {
  // @@protoc_insertion_point(field_get:ibeam_rawpanel.BurninProfile.Json)
  return _internal_json();
}
inline void BurninProfile::set_json(const std::string& value) {
  _internal_set_json(value);
  // @@protoc_insertion_point(field_set:ibeam_rawpanel.BurninProfile.Json)
}
inline std::string* BurninProfile::mutable_json() {
  // @@protoc_insertion_point(field_mutable:ibeam_rawpanel.BurninProfile.Json)
  return _internal_mutable_json();
}
inline const std::string& BurninProfile::_internal_json() const {
  return json_.Get();
}
inline void BurninProfile::_internal_set_json(const std::string& value) {
  
  json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void BurninProfile::set_json(std::string&& value) {
  
  json_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:ibeam_rawpanel.BurninProfile.Json)
}
inline void BurninProfile::set_json(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:ibeam_rawpanel.BurninProfile.Json)
}
inline void BurninProfile::set_json(const char* value,
    size_t size) {
  
  json_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:ibeam_rawpanel.BurninProfile.Json)
}
inline std::string* BurninProfile::_internal_mutable_json() {
  
  return json_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* BurninProfile::release_json() {
  // @@protoc_insertion_point(field_release:ibeam_rawpanel.BurninProfile.Json)
  return json_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void BurninProfile::set_allocated_json(std::string* json) {
  if (json != nullptr) {
    
  } else {
    
  }
  json_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), json,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:ibeam_rawpanel.BurninProfile.Json)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ibeam_rawpanel

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ibeam_rawpanel::InboundMessage_FlowMsg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::InboundMessage_FlowMsg>() {
  return ::ibeam_rawpanel::InboundMessage_FlowMsg_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCMode_StateE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCMode_StateE>() {
  return ::ibeam_rawpanel::HWCMode_StateE_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCExtended_InterpretationE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCExtended_InterpretationE>() {
  return ::ibeam_rawpanel::HWCExtended_InterpretationE_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::ColorIndex_Colors> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::ColorIndex_Colors>() {
  return ::ibeam_rawpanel::ColorIndex_Colors_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCText_ScaleM_ScaleTypeE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCText_ScaleM_ScaleTypeE>() {
  return ::ibeam_rawpanel::HWCText_ScaleM_ScaleTypeE_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFaceE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFaceE>() {
  return ::ibeam_rawpanel::HWCText_TextStyle_Font_FontFaceE_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCText_FormattingE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCText_FormattingE>() {
  return ::ibeam_rawpanel::HWCText_FormattingE_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCText_StateIconE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCText_StateIconE>() {
  return ::ibeam_rawpanel::HWCText_StateIconE_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCText_ModifierIconE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCText_ModifierIconE>() {
  return ::ibeam_rawpanel::HWCText_ModifierIconE_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCText_PairModeE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCText_PairModeE>() {
  return ::ibeam_rawpanel::HWCText_PairModeE_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::HWCGfx_ImageTypeE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::HWCGfx_ImageTypeE>() {
  return ::ibeam_rawpanel::HWCGfx_ImageTypeE_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::ImgConvert_FileTypeE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::ImgConvert_FileTypeE>() {
  return ::ibeam_rawpanel::ImgConvert_FileTypeE_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::ImgConvert_ScalingE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::ImgConvert_ScalingE>() {
  return ::ibeam_rawpanel::ImgConvert_ScalingE_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::OutboundMessage_FlowMsg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::OutboundMessage_FlowMsg>() {
  return ::ibeam_rawpanel::OutboundMessage_FlowMsg_descriptor();
}
template <> struct is_proto_enum< ::ibeam_rawpanel::BinaryEvent_EdgeID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ibeam_rawpanel::BinaryEvent_EdgeID>() {
  return ::ibeam_rawpanel::BinaryEvent_EdgeID_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ibeam_2drawpanel_2eproto
